<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.2.15">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">

<meta name="author" content="Dan Simpson">
<meta name="dcterms.date" content="2022-05-14">
<meta name="description" content="Takes a long drag on cigarette. JAX? Where was he when I had my cancer?">

<title>Un garçon pas comme les autres (Bayes) - Sparse Matrices 3: Failing at JAX</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1.6em;
  vertical-align: middle;
}
pre > code.sourceCode { white-space: pre; position: relative; }
pre > code.sourceCode > span { display: inline-block; line-height: 1.25; }
pre > code.sourceCode > span:empty { height: 1.2em; }
.sourceCode { overflow: visible; }
code.sourceCode > span { color: inherit; text-decoration: inherit; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
pre > code.sourceCode { white-space: pre-wrap; }
pre > code.sourceCode > span { text-indent: -5em; padding-left: 5em; }
}
pre.numberSource code
  { counter-reset: source-line 0; }
pre.numberSource code > span
  { position: relative; left: -4em; counter-increment: source-line; }
pre.numberSource code > span > a:first-child::before
  { content: counter(source-line);
    position: relative; left: -1em; text-align: right; vertical-align: baseline;
    border: none; display: inline-block;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
    color: #aaaaaa;
  }
pre.numberSource { margin-left: 3em; border-left: 1px solid #aaaaaa;  padding-left: 4px; }
div.sourceCode
  {   }
@media screen {
pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
}
code span.al { color: #ff0000; font-weight: bold; } /* Alert */
code span.an { color: #60a0b0; font-weight: bold; font-style: italic; } /* Annotation */
code span.at { color: #7d9029; } /* Attribute */
code span.bn { color: #40a070; } /* BaseN */
code span.bu { color: #008000; } /* BuiltIn */
code span.cf { color: #007020; font-weight: bold; } /* ControlFlow */
code span.ch { color: #4070a0; } /* Char */
code span.cn { color: #880000; } /* Constant */
code span.co { color: #60a0b0; font-style: italic; } /* Comment */
code span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } /* CommentVar */
code span.do { color: #ba2121; font-style: italic; } /* Documentation */
code span.dt { color: #902000; } /* DataType */
code span.dv { color: #40a070; } /* DecVal */
code span.er { color: #ff0000; font-weight: bold; } /* Error */
code span.ex { } /* Extension */
code span.fl { color: #40a070; } /* Float */
code span.fu { color: #06287e; } /* Function */
code span.im { color: #008000; font-weight: bold; } /* Import */
code span.in { color: #60a0b0; font-weight: bold; font-style: italic; } /* Information */
code span.kw { color: #007020; font-weight: bold; } /* Keyword */
code span.op { color: #666666; } /* Operator */
code span.ot { color: #007020; } /* Other */
code span.pp { color: #bc7a00; } /* Preprocessor */
code span.sc { color: #4070a0; } /* SpecialChar */
code span.ss { color: #bb6688; } /* SpecialString */
code span.st { color: #4070a0; } /* String */
code span.va { color: #19177c; } /* Variable */
code span.vs { color: #4070a0; } /* VerbatimString */
code span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } /* Warning */
</style>


<script src="../../site_libs/quarto-nav/quarto-nav.js"></script>
<script src="../../site_libs/quarto-nav/headroom.min.js"></script>
<script src="../../site_libs/clipboard/clipboard.min.js"></script>
<script src="../../site_libs/quarto-search/autocomplete.umd.js"></script>
<script src="../../site_libs/quarto-search/fuse.min.js"></script>
<script src="../../site_libs/quarto-search/quarto-search.js"></script>
<meta name="quarto:offset" content="../../">
<script src="../../site_libs/quarto-html/quarto.js"></script>
<script src="../../site_libs/quarto-html/popper.min.js"></script>
<script src="../../site_libs/quarto-html/tippy.umd.min.js"></script>
<script src="../../site_libs/quarto-html/anchor.min.js"></script>
<link href="../../site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="../../site_libs/quarto-html/quarto-syntax-highlighting.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="../../site_libs/bootstrap/bootstrap.min.js"></script>
<link href="../../site_libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="../../site_libs/bootstrap/bootstrap.min.css" rel="stylesheet" id="quarto-bootstrap" data-mode="light">
<script id="quarto-search-options" type="application/json">{
  "location": "navbar",
  "copy-button": false,
  "collapse-after": 3,
  "panel-placement": "end",
  "type": "overlay",
  "limit": 20,
  "language": {
    "search-no-results-text": "No results",
    "search-matching-documents-text": "matching documents",
    "search-copy-link-title": "Copy link to search",
    "search-hide-matches-text": "Hide additional matches",
    "search-more-match-text": "more match in this document",
    "search-more-matches-text": "more matches in this document",
    "search-clear-button-title": "Clear",
    "search-detached-cancel-button-title": "Cancel",
    "search-submit-button-title": "Submit"
  }
}</script>

  <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml-full.js" type="text/javascript"></script>

<link rel="stylesheet" href="../../styles.css">
<meta property="og:title" content="Un garçon pas comme les autres (Bayes) - Sparse Matrices 3: Failing at JAX">
<meta property="og:description" content="Takes a long drag on cigarette. JAX? Where was he when I had my cancer?">
<meta property="og:image" content="https://dansblog.netlify.app/posts/2022-05-14-jax-ing-a-sparse-cholesky-factorisation-part-3-in-an-ongoing-journey/alien.JPG">
<meta property="og:site-name" content="Un garçon pas comme les autres (Bayes)">
<meta name="twitter:title" content="Sparse Matrices 3: Failing at JAX">
<meta name="twitter:description" content="Takes a long drag on cigarette. JAX? Where was he when I had my cancer?">
<meta name="twitter:image" content="https://dansblog.netlify.app/posts/2022-05-14-jax-ing-a-sparse-cholesky-factorisation-part-3-in-an-ongoing-journey/alien.JPG">
<meta name="twitter:creator" content="@dan_p_simpson">
<meta name="twitter:card" content="summary_large_image">
</head>

<body class="floating nav-fixed">

<div id="quarto-search-results"></div>
  <header id="quarto-header" class="headroom fixed-top">
    <nav class="navbar navbar-expand-lg navbar-dark ">
      <div class="navbar-container container-fluid">
      <div class="navbar-brand-container">
    <a class="navbar-brand" href="../../index.html">
    <span class="navbar-title">Un garçon pas comme les autres (Bayes)</span>
    </a>
  </div>
          <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbarCollapse" aria-controls="navbarCollapse" aria-expanded="false" aria-label="Toggle navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">
  <span class="navbar-toggler-icon"></span>
</button>
          <div class="collapse navbar-collapse" id="navbarCollapse">
            <ul class="navbar-nav navbar-nav-scroll ms-auto">
  <li class="nav-item">
    <a class="nav-link" href="../../about.html">About this blog</a>
  </li>  
  <li class="nav-item compact">
    <a class="nav-link" href="https://twitter.com/dan_p_simpson"><i class="bi bi-twitter" role="img" aria-label="twitter">
</i> 
 </a>
  </li>  
  <li class="nav-item compact">
    <a class="nav-link" href="https://github.com/dpsimpson"><i class="bi bi-github" role="img" aria-label="github">
</i> 
 </a>
  </li>  
  <li class="nav-item compact">
    <a class="nav-link" href="https://dansblog.netlify.app"><i class="bi bi-person-circle" role="img" aria-label="website">
</i> 
 </a>
  </li>  
  <li class="nav-item compact">
    <a class="nav-link" href="../../index.xml"><i class="bi bi-rss" role="img">
</i> 
 </a>
  </li>  
</ul>
              <div id="quarto-search" class="" title="Search"></div>
          </div> <!-- /navcollapse -->
      </div> <!-- /container-fluid -->
    </nav>
</header>
<!-- content -->
<header id="title-block-header" class="quarto-title-block default toc-left page-columns page-full">
  <div class="quarto-title-banner page-columns page-full">
    <div class="quarto-title column-body">
      <h1 class="title">Sparse Matrices 3: Failing at JAX</h1>
                  <div>
        <div class="description">
          <p><em>Takes a long drag on cigarette.</em> JAX? Where was he when I had my cancer?</p>
        </div>
      </div>
                          <div class="quarto-categories">
                <div class="quarto-category">Sparse matrices</div>
                <div class="quarto-category">Sparse Cholesky factorisation</div>
                <div class="quarto-category">Python</div>
                <div class="quarto-category">JAX</div>
              </div>
                  </div>
  </div>
    
  
  <div class="quarto-title-meta">

      <div>
      <div class="quarto-title-meta-heading">Author</div>
      <div class="quarto-title-meta-contents">
               <p>Dan Simpson </p>
            </div>
    </div>
      
      <div>
      <div class="quarto-title-meta-heading">Published</div>
      <div class="quarto-title-meta-contents">
        <p class="date">May 14, 2022</p>
      </div>
    </div>
      
    </div>
    
  
  </header><div id="quarto-content" class="quarto-container page-columns page-rows-contents page-layout-article page-navbar">
<!-- sidebar -->
  <nav id="quarto-sidebar" class="sidebar collapse sidebar-navigation floating overflow-auto">
    <nav id="TOC" role="doc-toc" class="toc-active">
    <h2 id="toc-title">Table of contents</h2>
   
  <ul>
  <li><a href="#what-is-jax" id="toc-what-is-jax" class="nav-link active" data-scroll-target="#what-is-jax">What is JAX?</a></li>
  <li><a href="#to-jax-or-not-to-jax" id="toc-to-jax-or-not-to-jax" class="nav-link" data-scroll-target="#to-jax-or-not-to-jax">To JAX or not to JAX</a></li>
  <li><a href="#symbolic-factorisation" id="toc-symbolic-factorisation" class="nav-link" data-scroll-target="#symbolic-factorisation">Symbolic factorisation</a></li>
  <li><a href="#the-structure-changing-copy" id="toc-the-structure-changing-copy" class="nav-link" data-scroll-target="#the-structure-changing-copy">The structure-changing copy</a></li>
  <li><a href="#re-doing-the-data-structure." id="toc-re-doing-the-data-structure." class="nav-link" data-scroll-target="#re-doing-the-data-structure.">Re-doing the data structure.</a></li>
  <li><a href="#a-jax-tracable-structure-changing-copy" id="toc-a-jax-tracable-structure-changing-copy" class="nav-link" data-scroll-target="#a-jax-tracable-structure-changing-copy">A JAX-tracable structure-changing copy</a>
  <ul class="collapse">
  <li><a href="#testing-it-out" id="toc-testing-it-out" class="nav-link" data-scroll-target="#testing-it-out">Testing it out</a></li>
  </ul></li>
  <li><a href="#but-what-about-jit" id="toc-but-what-about-jit" class="nav-link" data-scroll-target="#but-what-about-jit">But what about JIT?</a></li>
  <li><a href="#lets-admit-failure" id="toc-lets-admit-failure" class="nav-link" data-scroll-target="#lets-admit-failure">Let’s admit failure</a></li>
  </ul>
</nav>
</nav>
<!-- margin-sidebar -->
    <div id="quarto-margin-sidebar" class="sidebar margin-sidebar">
    </div>
<!-- main -->
<main class="content quarto-banner-title-block" id="quarto-document-content">




<p>This is part three of an ongoing exercise in hubris. <a href="https://dansblog.netlify.app/posts/2022-03-22-a-linear-mixed-effects-model/">Part one is here.</a> <a href="https://dansblog.netlify.app/posts/2022-03-23-getting-jax-to-love-sparse-matrices/">Part two is here.</a> The overall aim of this series of posts is to look at how sparse Cholesky factorisations work, how JAX works, and how to marry the two with the ultimate aim of putting a bit of sparse matrix support into PyMC, which should allow for faster inference in linear mixed models, Gaussian spatial models. And hopefully, if anyone ever gets around to putting the Laplace approximation in, all sorts of GLMMs and non-Gaussian models with splines and spatial effects.</p>
<p>It’s been a couple of weeks since the last blog, but I’m going to just assume that you are fully on top of all of those details. To that end, let’s jump in.</p>
<section id="what-is-jax" class="level2">
<h2 class="anchored" data-anchor-id="what-is-jax">What is JAX?</h2>
<p><a href="https://jax.readthedocs.io/en/latest/index.html">JAX</a> is a minor miracle. It will take python+numpy code and make it cool. It will let you JIT<a href="#fn1" class="footnote-ref" id="fnref1" role="doc-noteref"><sup>1</sup></a> compile it! It will let you differentiate it! It will let you batch<a href="#fn2" class="footnote-ref" id="fnref2" role="doc-noteref"><sup>2</sup></a>. JAX refers to these three operations as <em>transformations</em>.</p>
<p>But, as The Mountain Goats tell us <a href="https://www.youtube.com/watch?v=-E4XeV33TvE"><em>God is present in the sweeping gesture, but the devil is in the details</em></a>. And oh boy are those details going to be really fucking important to us.</p>
<p>There are going to be two key things that will make our lives more difficult:</p>
<ol type="1">
<li><p>Not every operation can be transformed by every operation. For example, you can’t always JIT or take gradients of a <code>for</code> loop. This means that some things have to be re-written carefully to make sure it’s possible to get the advantages we need.</p></li>
<li><p>JAX arrays are <em>immutable</em>. That means that once a variable is defined it <em>cannot be changed</em>. This means that things like <code>a = a + 1</code> is not allowed! If you’ve come from an R/Python/C/Fortran world, this is the weirdest thing to deal with.</p></li>
</ol>
<p>There are really excellent reasons for both of these restrictions. And looking into the reasons is fascinating. But not a topic for this blog<a href="#fn3" class="footnote-ref" id="fnref3" role="doc-noteref"><sup>3</sup></a></p>
<p>JAX has some pretty decent<a href="#fn4" class="footnote-ref" id="fnref4" role="doc-noteref"><sup>4</sup></a> documentation, a core piece of which outlines some of the <a href="https://jax.readthedocs.io/en/latest/notebooks/Common_Gotchas_in_JAX.html">sharp edges</a> you will run into. As you read through the documentation, the design choices become clearer.</p>
<p>So let’s go and find some sharp edges together!</p>
</section>
<section id="to-jax-or-not-to-jax" class="level2">
<h2 class="anchored" data-anchor-id="to-jax-or-not-to-jax">To JAX or not to JAX</h2>
<p>But first, we need to ask ourselves <em>which functions do we need to JAX</em>?</p>
<p>In the context of our problem we, so far, have three functions:</p>
<ol type="1">
<li><code>_symbolic_factor_csc(A_indices, A_indptr)</code>, which finds the non-zero indices of the sparse Cholesky factor and return them in CSC format,</li>
<li><code>_deep_copy_csc(A_indices, A_indptr, A_x, L_indices, L_indptr)</code>, which takes the <em>entries</em> of the matrix <span class="math inline">\(A\)</span> and re-creates them so they can be indexed within the larger pattern of non-zero elements of <span class="math inline">\(L\)</span>,</li>
<li><code>_sparse_cholesky_csc_impl(L_indices, L_indptr, L_x)</code>, which actually does the sparse Cholesky factorisation.</li>
</ol>
<p>Let’s take them piece by piece, which is also a good opportunity to remind everyone what the code looked like.</p>
</section>
<section id="symbolic-factorisation" class="level2">
<h2 class="anchored" data-anchor-id="symbolic-factorisation">Symbolic factorisation</h2>
<div class="cell" data-execution_count="1">
<div class="sourceCode cell-code" id="cb1"><pre class="sourceCode numberSource python number-lines code-with-copy"><code class="sourceCode python"><span id="cb1-1"><a href="#cb1-1"></a><span class="kw">def</span> _symbolic_factor_csc(A_indices, A_indptr):</span>
<span id="cb1-2"><a href="#cb1-2"></a>  <span class="co"># Assumes A_indices and A_indptr index the lower triangle of $A$ ONLY.</span></span>
<span id="cb1-3"><a href="#cb1-3"></a>  n <span class="op">=</span> <span class="bu">len</span>(A_indptr) <span class="op">-</span> <span class="dv">1</span></span>
<span id="cb1-4"><a href="#cb1-4"></a>  L_sym <span class="op">=</span> [np.array([], dtype<span class="op">=</span><span class="bu">int</span>) <span class="cf">for</span> j <span class="kw">in</span> <span class="bu">range</span>(n)]</span>
<span id="cb1-5"><a href="#cb1-5"></a>  children <span class="op">=</span> [np.array([], dtype<span class="op">=</span><span class="bu">int</span>) <span class="cf">for</span> j <span class="kw">in</span> <span class="bu">range</span>(n)]</span>
<span id="cb1-6"><a href="#cb1-6"></a>  </span>
<span id="cb1-7"><a href="#cb1-7"></a>  <span class="cf">for</span> j <span class="kw">in</span> <span class="bu">range</span>(n):</span>
<span id="cb1-8"><a href="#cb1-8"></a>    L_sym[j] <span class="op">=</span> A_indices[A_indptr[j]:A_indptr[j <span class="op">+</span> <span class="dv">1</span>]]</span>
<span id="cb1-9"><a href="#cb1-9"></a>    <span class="cf">for</span> child <span class="kw">in</span> children[j]:</span>
<span id="cb1-10"><a href="#cb1-10"></a>      tmp <span class="op">=</span> L_sym[child][L_sym[child] <span class="op">&gt;</span> j]</span>
<span id="cb1-11"><a href="#cb1-11"></a>      L_sym[j] <span class="op">=</span> np.unique(np.append(L_sym[j], tmp))</span>
<span id="cb1-12"><a href="#cb1-12"></a>    <span class="cf">if</span> <span class="bu">len</span>(L_sym[j]) <span class="op">&gt;</span> <span class="dv">1</span>:</span>
<span id="cb1-13"><a href="#cb1-13"></a>      p <span class="op">=</span> L_sym[j][<span class="dv">1</span>]</span>
<span id="cb1-14"><a href="#cb1-14"></a>      children[p] <span class="op">=</span> np.append(children[p], j)</span>
<span id="cb1-15"><a href="#cb1-15"></a>        </span>
<span id="cb1-16"><a href="#cb1-16"></a>  L_indptr <span class="op">=</span> np.zeros(n<span class="op">+</span><span class="dv">1</span>, dtype<span class="op">=</span><span class="bu">int</span>)</span>
<span id="cb1-17"><a href="#cb1-17"></a>  L_indptr[<span class="dv">1</span>:] <span class="op">=</span> np.cumsum([<span class="bu">len</span>(x) <span class="cf">for</span> x <span class="kw">in</span> L_sym])</span>
<span id="cb1-18"><a href="#cb1-18"></a>  L_indices <span class="op">=</span> np.concatenate(L_sym)</span>
<span id="cb1-19"><a href="#cb1-19"></a>  </span>
<span id="cb1-20"><a href="#cb1-20"></a>  <span class="cf">return</span> L_indices, L_indptr</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>This function only needs to be computed once per non-zero pattern. In the applications I outlined in the first post, this non-zero pattern is <em>fixed</em>. This means that you only need to run this function <em>once</em> per analysis (unlike the others, that you will have to run once per iteration!).</p>
<p>As a general rule, if you only do something once, it isn’t all that necessary to devote <em>too much</em> time into optimising it. There are, however, some obvious things we could do.</p>
<p>It is, for instance, pretty easy to see how you would implement this with an explicit tree<a href="#fn5" class="footnote-ref" id="fnref5" role="doc-noteref"><sup>5</sup></a> structure instead of constantly <code>np.append</code>ing the <code>children</code> array. This is <em>far</em> better from a memory standpoint.</p>
<p>It’s also easy to imagine this as a two-pass algorithm, where you build the tree and count the number of non-zero elements in the first pass and then build and populate <code>L_indices</code> in the second pass.</p>
<p>The thing is, neither of these things fixes the core problem for using JAX to JIT this: the dimensions of the internal arrays depend on the <em>values</em> of the inputs. This is not possible.</p>
<p>It seems like this would be a huge limitation, but in reality it isn’t. Most functions aren’t like this one! And, if we remember that JAX is a domain language focussing mainly on ML applications, this is <em>very rarely</em> the case. It is always good to remember context!</p>
<p>So what are our options? We have two.</p>
<ol type="1">
<li>Leave it in Python and just eat the speed.</li>
<li>Build a <a href="https://jax.readthedocs.io/en/latest/notebooks/How_JAX_primitives_work.html">new JAX primitive</a> and write the XLA compilation rule<a href="#fn6" class="footnote-ref" id="fnref6" role="doc-noteref"><sup>6</sup></a>.</li>
</ol>
<p>Today are opting for the first option!</p>
</section>
<section id="the-structure-changing-copy" class="level2">
<h2 class="anchored" data-anchor-id="the-structure-changing-copy">The structure-changing copy</h2>
<div class="cell" data-execution_count="2">
<div class="sourceCode cell-code" id="cb2"><pre class="sourceCode numberSource python number-lines code-with-copy"><code class="sourceCode python"><span id="cb2-1"><a href="#cb2-1"></a><span class="kw">def</span> _deep_copy_csc(A_indices, A_indptr, A_x, L_indices, L_indptr):</span>
<span id="cb2-2"><a href="#cb2-2"></a>  n <span class="op">=</span> <span class="bu">len</span>(A_indptr) <span class="op">-</span> <span class="dv">1</span></span>
<span id="cb2-3"><a href="#cb2-3"></a>  L_x <span class="op">=</span> np.zeros(<span class="bu">len</span>(L_indices))</span>
<span id="cb2-4"><a href="#cb2-4"></a>  </span>
<span id="cb2-5"><a href="#cb2-5"></a>  <span class="cf">for</span> j <span class="kw">in</span> <span class="bu">range</span>(<span class="dv">0</span>, n):</span>
<span id="cb2-6"><a href="#cb2-6"></a>    copy_idx <span class="op">=</span> np.nonzero(np.in1d(L_indices[L_indptr[j]:L_indptr[j <span class="op">+</span> <span class="dv">1</span>]],</span>
<span id="cb2-7"><a href="#cb2-7"></a>                                  A_indices[A_indptr[j]:A_indptr[j<span class="op">+</span><span class="dv">1</span>]]))[<span class="dv">0</span>]</span>
<span id="cb2-8"><a href="#cb2-8"></a>    L_x[L_indptr[j] <span class="op">+</span> copy_idx] <span class="op">=</span> A_x[A_indptr[j]:A_indptr[j<span class="op">+</span><span class="dv">1</span>]]</span>
<span id="cb2-9"><a href="#cb2-9"></a>  <span class="cf">return</span> L_x</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>This is, fundamentally, a piece of bookkeeping. An annoyance of sparse matrices. Or, if you will, explicit <em>cast</em> between different sparse matrix types<a href="#fn7" class="footnote-ref" id="fnref7" role="doc-noteref"><sup>7</sup></a>. This is a thing that we do actually need to be able to differentiate, so it needs to live in JAX.</p>
<p>So where are the potential problems? Let’s go line by line.</p>
<ol type="1">
<li><p><code>n = len(A_indptr) - 1</code>: This is lovely. <code>n</code> is used in a for loop later, but because it is a function of the <em>shape</em> of <code>A_indptr</code>, it is considered static and we will be able to JIT over it!</p></li>
<li><p><code>L_x = np.zeros(len(L_indices))</code>: Again, this is fine. Sizes are derived from shapes, life is peachy.</p></li>
<li><p><code>for j in range(0, n):</code>: This could be a problem if <code>n</code> was an argument or derived from <em>values</em> of the arguments, but it’s derived from a shape so it is static. Praise be! Well, actually it’s a bit more involved than that.</p></li>
</ol>
<p>The problem with the <code>for</code> loop is what will happen when it is JIT’d.&nbsp;Essentially, the loop will be statically unrolled<a href="#fn8" class="footnote-ref" id="fnref8" role="doc-noteref"><sup>8</sup></a>. That is fine for small loops, but it’s a bit of a pain in the arse when <code>n</code> is large.</p>
<p>In this case, we might want to use the structured control flow in <code>jax.lax</code><a href="#fn9" class="footnote-ref" id="fnref9" role="doc-noteref"><sup>9</sup></a> In this case we would need <code>jax.lax.fori_loop(start, end, body_fun, init_value)</code>. This makes the code look less <em>pythonic</em>, but probably should make it faster. It is also, and I cannot stress this enough, an absolute dick to use.</p>
<p>(In actuality, we will see that we do not need this particular corner of the language here!)</p>
<ol start="4" type="1">
<li><code>copy_idx = np.nonzero(...)</code>: This looks like it’s going to be complicated, but actually it is a perfectly reasonable composition of <code>numpy</code> functions. Hence, we can use the same <code>jax.numpy</code> functions with minimal changes. The one change that we are going to need to make in order to end up with a JIT-able and differentiable function is that we need to tell JAX how many non-zero elements there are. Thankfully, we know this! Because the non-zero pattern of <span class="math inline">\(A\)</span> is a subset of the non-zero pattern of <span class="math inline">\(L\)</span>, we know that</li>
</ol>
<div class="cell" data-execution_count="3">
<div class="sourceCode cell-code" id="cb3"><pre class="sourceCode numberSource python number-lines code-with-copy"><code class="sourceCode python"><span id="cb3-1"><a href="#cb3-1"></a>np.in1d(L_indices[L_indptr[j]:L_indptr[j <span class="op">+</span> <span class="dv">1</span>]], A_indices[A_indptr[j]:A_indptr[j<span class="op">+</span><span class="dv">1</span>]])</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>will have exactly <code>len(A_indices[A_indptr[j]:A_indptr[j+1]])</code> <code>True</code> values, and so <code>np.nonzero(...)</code> will have that many. We can pass this information to <code>jnp.nonzero()</code> using the optional <code>size</code> argument.</p>
<p><strong>Oh no! We have a problem!</strong> This return size is <em>a function of the values</em> of <code>A_indptr</code> rather than a function of the shape. This means we’re a bit fucked.</p>
<p>There are two routes out:</p>
<ol type="1">
<li>Declare <code>A_indptr</code> to be a static parameter, or</li>
<li>Change the representation from CSC to something more convenient.</li>
</ol>
<p>In this case we could do either of these things, but I’m going to opt for the second option, as it’s going to be more useful going forward.</p>
<p>But before we do that, let’s look at the final line in the code.</p>
<ol start="5" type="1">
<li><code>L_x[L_indptr[j] + copy_idx] = A_x[A_indptr[j]:A_indptr[j+1]]</code>: The final non-trivial line of the code is also a problem. The issue is that these arrays are <em>immutable</em> and we are asking to change the values! That is not allowed!</li>
</ol>
<p>The solution here is to use a clunkier syntax. In JAX, we need to replace</p>
<div class="cell" data-execution_count="4">
<div class="sourceCode cell-code" id="cb4"><pre class="sourceCode numberSource python number-lines code-with-copy"><code class="sourceCode python"><span id="cb4-1"><a href="#cb4-1"></a>x[ind] <span class="op">=</span> a</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>with the less pleasant</p>
<div class="cell" data-execution_count="5">
<div class="sourceCode cell-code" id="cb5"><pre class="sourceCode numberSource python number-lines code-with-copy"><code class="sourceCode python"><span id="cb5-1"><a href="#cb5-1"></a>x <span class="op">=</span> x.at[ind].<span class="bu">set</span>(a)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>What is going on under the hood to make the second option ok while the first is an error is well beyond the scope of this little post. But the important thing is that they <em>compile down</em> to an in-place<a href="#fn10" class="footnote-ref" id="fnref10" role="doc-noteref"><sup>10</sup></a> update, which is all we really care about.</p>
</section>
<section id="re-doing-the-data-structure." class="level2">
<h2 class="anchored" data-anchor-id="re-doing-the-data-structure.">Re-doing the data structure.</h2>
<p>Ok. So we need a new data structure. That’s annoying. The rule, I guess, is always that if you need to innovate, you should innovate very little if you can get away with it, or a lot if you have to.</p>
<p>We are going to innovate only the tiniest of bits.</p>
<p>The idea is to keep the core structure of the CSC data structure, but to replace the <code>indptr</code> array with explicitly storing the row indices and row values as a <em>list</em> of <code>np.arrays</code>. So <code>A_index</code> will now be a <em>list</em> of <code>n</code> arrays that contain the row indices of the non-zero elements of <span class="math inline">\(A\)</span>, while <code>A_x</code>will now be a <em>list</em> of <code>n</code> arrays that contain the values of the non-zero elements of <span class="math inline">\(A\)</span>.</p>
<p>This means that the matrix <span class="math display">\[
B = \begin{pmatrix}
1 &amp;&amp;5 \\
2&amp;3&amp; \\
&amp;4&amp;6
\end{pmatrix}
\]</span> would be stored as</p>
<div class="cell" data-execution_count="6">
<div class="sourceCode cell-code" id="cb6"><pre class="sourceCode numberSource python number-lines code-with-copy"><code class="sourceCode python"><span id="cb6-1"><a href="#cb6-1"></a>B_index <span class="op">=</span> [np.array([<span class="dv">0</span>,<span class="dv">1</span>]), np.array([<span class="dv">1</span>,<span class="dv">2</span>]), np.array([<span class="dv">0</span>,<span class="dv">2</span>])]</span>
<span id="cb6-2"><a href="#cb6-2"></a>B_x <span class="op">=</span> [np.array([<span class="dv">1</span>,<span class="dv">2</span>]), np.array([<span class="dv">3</span>,<span class="dv">4</span>]), np.array([<span class="dv">5</span>,<span class="dv">6</span>])]</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>This is a considerably more <em>pythonic</em><a href="#fn11" class="footnote-ref" id="fnref11" role="doc-noteref"><sup>11</sup></a> version of CSC. So I guess that’s an advantage.</p>
<p>We can easily go from CSC storage to this modified storage.</p>
<div class="cell" data-execution_count="7">
<div class="sourceCode cell-code" id="cb7"><pre class="sourceCode numberSource python number-lines code-with-copy"><code class="sourceCode python"><span id="cb7-1"><a href="#cb7-1"></a><span class="kw">def</span> to_pythonic_csc(indices, indptr, x):</span>
<span id="cb7-2"><a href="#cb7-2"></a>  index <span class="op">=</span> np.split(indices, indptr[<span class="dv">1</span>:<span class="op">-</span><span class="dv">1</span>])</span>
<span id="cb7-3"><a href="#cb7-3"></a>  x <span class="op">=</span> np.split(x, indptr[<span class="dv">1</span>,<span class="op">-</span><span class="dv">1</span>])</span>
<span id="cb7-4"><a href="#cb7-4"></a>  <span class="cf">return</span> index, x</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
</section>
<section id="a-jax-tracable-structure-changing-copy" class="level2">
<h2 class="anchored" data-anchor-id="a-jax-tracable-structure-changing-copy">A JAX-tracable structure-changing copy</h2>
<p>So now it’s time to come back to that damn <code>for</code> loop. As flagged earlier, <code>for</code> loops can be a bit picky in JAX. If we use them <em>as is</em>, then the code that is generated and then compiled is <em>unrolled</em>. You can think of this as if the JIT compiler automatically writes a C++ program and then compiles it. If you were to examine that code, the for loop would be replaced by <code>n</code> almost identical blocks of code with only the index <code>j</code> changing between them. This leads to a potentially very large program to compile<a href="#fn12" class="footnote-ref" id="fnref12" role="doc-noteref"><sup>12</sup></a> and it limits the compiler’s ability to do clever things to make the compiled code run faster<a href="#fn13" class="footnote-ref" id="fnref13" role="doc-noteref"><sup>13</sup></a>.</p>
<p>The <code>lax.fori_loop()</code> function, on the other hand, compiles down to the equivalent of a single operation<a href="#fn14" class="footnote-ref" id="fnref14" role="doc-noteref"><sup>14</sup></a>. This lets the compiler be super clever.</p>
<p>But we don’t actually need this here. Because if you take a look at the original for loop we are just applying the same two lines of code to each triple of lists in <code>A_index</code>, <code>A_x</code>, and <code>L_index</code> (in our new<a href="#fn15" class="footnote-ref" id="fnref15" role="doc-noteref"><sup>15</sup></a> data structure).</p>
<p>This just <em>screams</em> out for a map applying a single function independently to each column.</p>
<p>The challenge is to find the right map function. An obvious hope would be <code>jax.vmap</code>. Sadly, <code>jax.vmap</code> does not do that. (At least not without more padding<a href="#fn16" class="footnote-ref" id="fnref16" role="doc-noteref"><sup>16</sup></a> than a drag queen.) The problem here is a misunderstanding of what different parts of JAX are for. Functions like <code>jax.vmap</code> are made for applying the same function to arrays <em>of the same size</em>. This makes sense in their context. (JAX is, after all, made for machine learning and these shape assumptions fit really well in that paradigm. They just don’t fit here.)</p>
<p>And I won’t lie. After this point I went <em>wild</em>. <code>lax.map</code> did not help. And I honest to god tried <code>lax.scan</code>, which is will solve the problem but <a href="https://www.youtube.com/watch?v=AOGzY9xShEI">at what cost?</a>.</p>
<p>But at some point, you read enough of the docs to find the answer.</p>
<p>The correct answer here is to use the JAX concept of a <code>pytree</code>. Pytrees are essentially<a href="#fn17" class="footnote-ref" id="fnref17" role="doc-noteref"><sup>17</sup></a> lists of arrays. They’re very flexible and they have a <code>jax.tree_map</code> function that lets you map over them! We are saved!</p>
<div class="cell" data-execution_count="8">
<div class="sourceCode cell-code" id="cb8"><pre class="sourceCode numberSource python number-lines code-with-copy"><code class="sourceCode python"><span id="cb8-1"><a href="#cb8-1"></a><span class="im">import</span> numpy <span class="im">as</span> np</span>
<span id="cb8-2"><a href="#cb8-2"></a><span class="im">from</span> jax <span class="im">import</span> numpy <span class="im">as</span> jnp</span>
<span id="cb8-3"><a href="#cb8-3"></a><span class="im">from</span> jax <span class="im">import</span> tree_map</span>
<span id="cb8-4"><a href="#cb8-4"></a></span>
<span id="cb8-5"><a href="#cb8-5"></a><span class="kw">def</span> _structured_copy_csc(A_index, A_x, L_index):</span>
<span id="cb8-6"><a href="#cb8-6"></a>    <span class="kw">def</span> body_fun(A_rows, A_vals, L_rows):</span>
<span id="cb8-7"><a href="#cb8-7"></a>      out <span class="op">=</span> jnp.zeros(<span class="bu">len</span>(L_rows))</span>
<span id="cb8-8"><a href="#cb8-8"></a>      copy_idx <span class="op">=</span>  jnp.nonzero(jnp.in1d(L_rows, A_rows), size <span class="op">=</span> <span class="bu">len</span>(A_rows))[<span class="dv">0</span>] </span>
<span id="cb8-9"><a href="#cb8-9"></a>      out <span class="op">=</span> out.at[copy_idx].<span class="bu">set</span>(A_vals)</span>
<span id="cb8-10"><a href="#cb8-10"></a>      <span class="cf">return</span> out</span>
<span id="cb8-11"><a href="#cb8-11"></a>    L_x <span class="op">=</span> tree_map(body_fun, A_index, A_x, L_index)</span>
<span id="cb8-12"><a href="#cb8-12"></a>    <span class="cf">return</span> L_x</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<section id="testing-it-out" class="level3">
<h3 class="anchored" data-anchor-id="testing-it-out">Testing it out</h3>
<p>Ok so now lets see if it works. To do that I’m going to define a very simple function <span class="math display">\[
f(A, \alpha, \beta) = \|\alpha I + \beta \operatorname{tril}(A)\|_F^2,
\]</span> that is the sum of the squares of all of the elements of <span class="math inline">\(\alpha I + \beta \operatorname{tril}(A)\)</span>. There’s obviously an easy way to do this, but I’m going to do it in a way that uses the function we just built.</p>
<div class="cell" data-execution_count="9">
<div class="sourceCode cell-code" id="cb9"><pre class="sourceCode numberSource python number-lines code-with-copy"><code class="sourceCode python"><span id="cb9-1"><a href="#cb9-1"></a><span class="kw">def</span> test_func(A_index, A_x, params):</span>
<span id="cb9-2"><a href="#cb9-2"></a>  I_index <span class="op">=</span> [jnp.array([j]) <span class="cf">for</span> j <span class="kw">in</span> <span class="bu">range</span>(<span class="bu">len</span>(A_index))]</span>
<span id="cb9-3"><a href="#cb9-3"></a>  I_x <span class="op">=</span> [jnp.array([params[<span class="dv">0</span>]]) <span class="cf">for</span> j <span class="kw">in</span> <span class="bu">range</span>(<span class="bu">len</span>(A_index))]</span>
<span id="cb9-4"><a href="#cb9-4"></a>  I_x2 <span class="op">=</span> _structured_copy_csc(I_index, I_x, A_index)</span>
<span id="cb9-5"><a href="#cb9-5"></a>  <span class="cf">return</span> jnp.<span class="bu">sum</span>((jnp.concatenate(I_x2) <span class="op">+</span> params[<span class="dv">1</span>] <span class="op">*</span> jnp.concatenate(A_x))<span class="op">**</span><span class="dv">2</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>Next, we need a test case. Once again, we will use the 2D Laplacian on a regular <span class="math inline">\(n \times n\)</span> grid (up to a scaling). This is a nice little function because it’s easy to make test problems of different sizes.</p>
<div class="cell" data-execution_count="10">
<div class="sourceCode cell-code" id="cb10"><pre class="sourceCode numberSource python number-lines code-with-copy"><code class="sourceCode python"><span id="cb10-1"><a href="#cb10-1"></a><span class="im">from</span> scipy <span class="im">import</span> sparse</span>
<span id="cb10-2"><a href="#cb10-2"></a></span>
<span id="cb10-3"><a href="#cb10-3"></a><span class="kw">def</span> make_matrix(n):</span>
<span id="cb10-4"><a href="#cb10-4"></a>    one_d <span class="op">=</span> sparse.diags([[<span class="op">-</span><span class="fl">1.</span>]<span class="op">*</span>(n<span class="op">-</span><span class="dv">1</span>), [<span class="fl">2.</span>]<span class="op">*</span>n, [<span class="op">-</span><span class="fl">1.</span>]<span class="op">*</span>(n<span class="op">-</span><span class="dv">1</span>)], [<span class="op">-</span><span class="dv">1</span>,<span class="dv">0</span>,<span class="dv">1</span>])</span>
<span id="cb10-5"><a href="#cb10-5"></a>    A_lower <span class="op">=</span> sparse.tril(sparse.kronsum(one_d, one_d) <span class="op">+</span> sparse.eye(n<span class="op">*</span>n), <span class="bu">format</span> <span class="op">=</span> <span class="st">"csc"</span>)</span>
<span id="cb10-6"><a href="#cb10-6"></a>    A_index <span class="op">=</span> jnp.split(jnp.array(A_lower.indices), A_lower.indptr[<span class="dv">1</span>:<span class="op">-</span><span class="dv">1</span>])</span>
<span id="cb10-7"><a href="#cb10-7"></a>    A_x <span class="op">=</span> jnp.split(jnp.array(A_lower.data), A_lower.indptr[<span class="dv">1</span>:<span class="op">-</span><span class="dv">1</span>])</span>
<span id="cb10-8"><a href="#cb10-8"></a>    <span class="cf">return</span> (A_index, A_x)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>With our test case in hand, we can check to see if JAX will differentiate for us!</p>
<div class="cell" data-execution_count="11">
<div class="sourceCode cell-code" id="cb11"><pre class="sourceCode numberSource python number-lines code-with-copy"><code class="sourceCode python"><span id="cb11-1"><a href="#cb11-1"></a><span class="im">from</span> jax <span class="im">import</span> grad, jit</span>
<span id="cb11-2"><a href="#cb11-2"></a><span class="im">from</span> jax.test_util <span class="im">import</span> check_grads</span>
<span id="cb11-3"><a href="#cb11-3"></a></span>
<span id="cb11-4"><a href="#cb11-4"></a>grad_func <span class="op">=</span> grad(test_func, argnums <span class="op">=</span> <span class="dv">2</span>)</span>
<span id="cb11-5"><a href="#cb11-5"></a></span>
<span id="cb11-6"><a href="#cb11-6"></a>A_index, A_x <span class="op">=</span> make_matrix(<span class="dv">50</span>)</span>
<span id="cb11-7"><a href="#cb11-7"></a><span class="bu">print</span>(<span class="ss">f"The value at (2.0, 2.0) is </span><span class="sc">{</span>test_func(A_index, A_x, (<span class="fl">2.0</span>, <span class="fl">2.0</span>))<span class="sc">}</span><span class="ss">."</span>)</span>
<span id="cb11-8"><a href="#cb11-8"></a><span class="bu">print</span>(<span class="ss">f"The gradient is </span><span class="sc">{</span>np<span class="sc">.</span>array(grad_func(A_index, A_x, (<span class="fl">2.0</span>, <span class="fl">2.0</span>)))<span class="sc">}</span><span class="ss">."</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>The value at (2.0, 2.0) is 379600.0.</code></pre>
</div>
<div class="cell-output cell-output-stdout">
<pre><code>The gradient is [ 60000. 319600.].</code></pre>
</div>
</div>
<p>Fabulous! That works!</p>
</section>
</section>
<section id="but-what-about-jit" class="level2">
<h2 class="anchored" data-anchor-id="but-what-about-jit">But what about JIT?</h2>
<p>JIT took fucking <em>ages</em>. I’m talking “it threw a message” amounts of time. I’m not even going to pretend that I understand why. But I can hazard a guess.</p>
<p>My running assumption, taken from the docs, is that as long as the function only relies of quantities that are derived from the <em>shapes</em> of the inputs (and not the values), then JAX will be able to trace through and JIT through the functions with ease.</p>
<p>This might not be true for <code>tree_map</code>s. The docs are, as far as I can tell, silent on this matter. And a cursory look through the github repo did not give me any hints as to how <code>tree_map()</code> is translated.</p>
<p>Let’s take a look to see if this is true.</p>
<div class="cell" data-execution_count="12">
<div class="sourceCode cell-code" id="cb14"><pre class="sourceCode numberSource python number-lines code-with-copy"><code class="sourceCode python"><span id="cb14-1"><a href="#cb14-1"></a><span class="im">import</span> timeit</span>
<span id="cb14-2"><a href="#cb14-2"></a><span class="im">from</span> functools <span class="im">import</span> partial</span>
<span id="cb14-3"><a href="#cb14-3"></a>jit_test_func <span class="op">=</span> jit(test_func)</span>
<span id="cb14-4"><a href="#cb14-4"></a></span>
<span id="cb14-5"><a href="#cb14-5"></a>A_index, A_x <span class="op">=</span> make_matrix(<span class="dv">5</span>)</span>
<span id="cb14-6"><a href="#cb14-6"></a>times <span class="op">=</span> timeit.repeat(partial(jit_test_func, A_index, A_x, (<span class="fl">2.0</span>, <span class="fl">2.0</span>)), number <span class="op">=</span> <span class="dv">1</span>)</span>
<span id="cb14-7"><a href="#cb14-7"></a><span class="bu">print</span>(<span class="ss">f"n = 5: </span><span class="sc">{</span>[<span class="bu">round</span>(t, <span class="dv">4</span>) <span class="cf">for</span> t <span class="kw">in</span> times]<span class="sc">}</span><span class="ss">"</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>n = 5: [1.6695, 0.0001, 0.0, 0.0, 0.0]</code></pre>
</div>
</div>
<p>We can see that the first run includes compilation time, but after that it runs a bunch faster. This is how a JIT system is supposed to work! But the question is: will it recompile when we run it for a different matrix?</p>
<div class="cell" data-execution_count="13">
<div class="sourceCode cell-code" id="cb16"><pre class="sourceCode numberSource python number-lines code-with-copy"><code class="sourceCode python"><span id="cb16-1"><a href="#cb16-1"></a>_ <span class="op">=</span> jit_test_func(A_index, A_x, (<span class="fl">2.0</span>, <span class="fl">2.0</span>)) </span>
<span id="cb16-2"><a href="#cb16-2"></a>A_index, A_x <span class="op">=</span> make_matrix(<span class="dv">20</span>)</span>
<span id="cb16-3"><a href="#cb16-3"></a>times <span class="op">=</span> timeit.repeat(partial(jit_test_func, A_index, A_x, (<span class="fl">2.0</span>, <span class="fl">2.0</span>)), number <span class="op">=</span> <span class="dv">1</span>)</span>
<span id="cb16-4"><a href="#cb16-4"></a><span class="bu">print</span>(<span class="ss">f"n = 20: </span><span class="sc">{</span>[<span class="bu">round</span>(t, <span class="dv">4</span>) <span class="cf">for</span> t <span class="kw">in</span> times]<span class="sc">}</span><span class="ss">"</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>n = 20: [38.5779, 0.0006, 0.0003, 0.0003, 0.0003]</code></pre>
</div>
</div>
<p>Damn. It recompiles. But, as we will see, it does not recompile if we only change <code>A_x</code>.</p>
<div class="cell" data-execution_count="14">
<div class="sourceCode cell-code" id="cb18"><pre class="sourceCode numberSource python number-lines code-with-copy"><code class="sourceCode python"><span id="cb18-1"><a href="#cb18-1"></a><span class="co"># What if we change A_x only</span></span>
<span id="cb18-2"><a href="#cb18-2"></a>_ <span class="op">=</span> jit_test_func(A_index, A_x, (<span class="fl">2.0</span>, <span class="fl">2.0</span>)) </span>
<span id="cb18-3"><a href="#cb18-3"></a>A_x2 <span class="op">=</span> tree_map(<span class="kw">lambda</span> x: x <span class="op">+</span> <span class="fl">1.0</span>, A_x)</span>
<span id="cb18-4"><a href="#cb18-4"></a>times <span class="op">=</span> timeit.repeat(partial(jit_test_func, A_index, A_x2, (<span class="fl">2.0</span>, <span class="fl">2.0</span>)), number <span class="op">=</span> <span class="dv">1</span>)</span>
<span id="cb18-5"><a href="#cb18-5"></a><span class="bu">print</span>(<span class="ss">f"n = 20, new A_x: </span><span class="sc">{</span>[<span class="bu">round</span>(t, <span class="dv">4</span>) <span class="cf">for</span> t <span class="kw">in</span> times]<span class="sc">}</span><span class="ss">"</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>n = 20, new A_x: [0.0006, 0.0007, 0.0005, 0.0003, 0.0003]</code></pre>
</div>
</div>
<p>This gives us some hope! This is because the <em>structure</em> of A (aka <code>A_index</code>) is fixed in our application, but the values <code>A_x</code> changes. So as long as the initial JIT compilation is reasonable, we should be ok.</p>
<p>Unfortunately, there is something bad happening with the compilation. For <span class="math inline">\(n=10\)</span>, it takes (on my machine) about 2 seconds for the initial compilation. For <span class="math inline">\(n=20\)</span>, that increases to 16 seconds. Once <span class="math inline">\(n = 30\)</span>, this balloons up to 51 seconds. Once we reach the lofty peaks<a href="#fn18" class="footnote-ref" id="fnref18" role="doc-noteref"><sup>18</sup></a> of <span class="math inline">\(n=40\)</span>, we are up at 149 seconds to compile.</p>
<p>This is not good. The function we are JIT-ing is <em>very</em> simple: just one <code>tree_map</code>. I do not know enough<a href="#fn19" class="footnote-ref" id="fnref19" role="doc-noteref"><sup>19</sup></a> about the internals of JAX, so I don’t want to speculate too wildly. But it seems like it might be unrolling the <code>tree_map</code> before compilation, which is … bad.</p>
</section>
<section id="lets-admit-failure" class="level2">
<h2 class="anchored" data-anchor-id="lets-admit-failure">Let’s admit failure</h2>
<p>Ok. So that didn’t bloody work. I’m not going to make such broad statements as <em>you can’t use the JAX library in python to write a transformable sparse Cholesky factorisation</em>, but I am more than prepared to say that <em>I</em> cannot do such a thing.</p>
<p>But, if I’m totally honest, I’m not <em>enormously</em> surprised. Even in looking at the very simple operation we focussed on today, it’s pretty clear that the operations required to work on a sparse matrix don’t look an awful lot like the types of operations you need to do the types of machine learning work that is JAX’s <em>raison d’être</em>.</p>
<p>And it is <em>never</em> surprising to find that a library designed to do a fundamentally different thing does not easily adapt to whatever random task I decide to throw at it.</p>
<p>But there is a light: JAX is an extensible language. We can build a new JAX primitive (or, new JAX primitives) and manually write all of the transformations (batching, JIT, and autodiffing).</p>
<p>And that is what we shall do next! It’s gonna be a blast!</p>


</section>


<div id="quarto-appendix" class="default"><section id="footnotes" class="footnotes footnotes-end-of-document" role="doc-endnotes"><h2 class="anchored quarto-appendix-heading">Footnotes</h2>

<ol>
<li id="fn1"><p>If you’ve never come across this term before, you can Google it for actual details, but the squishy version is that it will <em>compile</em> your code so it runs fast (like C code) instead of slow (like python code). JIT stands for <em>just in time</em>, which means that the code is compiled when it’s needed rather than before everything else is run. It’s a good thing. It makes the machine go <em>bing</em> faster.<a href="#fnref1" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn2"><p>I give less of a shit about the third transformation in this context. I’m not completely sure what you would batch when you’re dealing with a linear mixed-ish model. But hey. Why not.<a href="#fnref2" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn3"><p>If you’ve ever spoken to a Scala advocate (or any other pure functional language), you can probably see the edges of why the arrays need to be immutable.<span class="math display">\[
\phantom{a}
\]</span> Restrictions to JIT-able control flow has to do with how it’s translated onto the XLA compiler, which involves <em>tracing</em> through the code with an abstract data type with the same shape as the one that it’s being called with. Because this abstract data type does not have any values, structural parts of the code that <em>require</em> knowledge of specific values of the arguments will be lost. You can get around this partially by declaring those important values to be <em>static</em>, which would make the JIT compiler re-compile the function each time that value changes. We are not going to do that. <span class="math display">\[
\phantom{a}
\]</span> Restrictions to gradients have to do (I assume) with reverse-mode autodiff needing to construct the autodiff tree at compile time, which means you need to be able to compute the number of operations from the types and shapes of the input variables and not from their values.<a href="#fnref3" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn4"><p>Coverage is pretty good on the <em>using</em> bit, but, as is usual, the bits on extending the system are occasionally a bit … sparse. (What in the hairy Christ is a <a href="https://jax.readthedocs.io/en/latest/notebooks/How_JAX_primitives_work.html#transposition">transposition</a> rule actually supposed to do????)<a href="#fnref4" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn5"><p>Forest<a href="#fnref5" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn6"><p>aka implement the damn thing in C++ and then do some proper work on it.<a href="#fnref6" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn7"><p>It is useful to think of a sparse matrix type as the triple <code>(value_type, indices, indptr)</code>. This means that if we are going to do something like add sparse matrices, we need to first cast them both to have the same type. After the cast, addition of two different sparse matrices becomes the addition of their <code>x</code> attributes. The same holds for scalar multiplication. Sparse matrix-matrix multiplication is a bit different because you once again need to symbolically work out the sparsity structure (aka the type) of the product. <a href="#fnref7" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn8"><p>I think. That’s certainly what’s implied <a href="https://jax.readthedocs.io/en/latest/notebooks/Common_Gotchas_in_JAX.html#python-control-flow-jit">by the docs</a>, but I don’t want to give the impression that I’m sure. Because this is <a href="https://www.youtube.com/watch?v=5NPBIwQyPWE">complicated.</a><a href="#fnref8" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn9"><p>What is <code>jax.lax</code>? Oh honey you don’t want to know.<a href="#fnref9" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn10"><p>aka there’s no weird copying<a href="#fnref10" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn11"><p><a href="https://www.youtube.com/watch?v=1hRvQqyeI2g">Whatever that means anyway</a><a href="#fnref11" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn12"><p>slowwwwww to compile<a href="#fnref12" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn13"><p>The XLA compiler does very clever things. Incidentally, loop unrolling is actually one of the optimisations that compilers have in their pocket. Just not one that’s usually used for loops as large as this.<a href="#fnref13" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn14"><p>Read about XLA High Level Operations (HLOs) <a href="https://www.tensorflow.org/xla/architecture">here</a>. The XLA documentation is not extensive, but there’s still a lot to read.<a href="#fnref14" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn15"><p>This is why we have a new data structure.<a href="#fnref15" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn16"><p>My kingdom for a ragged array.<a href="#fnref16" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn17"><p>Yes. They are more complicated than this. But for our purposes they are lists of arrays.<a href="#fnref17" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn18"><p><span class="math inline">\(n=50\)</span> takes so long it prints a message telling us what to do if we need to do if we want to file a bug! Compilation eventually clocks in at 361 seconds.<a href="#fnref18" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn19"><p>aka I know sweet bugger all<a href="#fnref19" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
</ol>
</section><section class="quarto-appendix-contents"><h2 class="anchored quarto-appendix-heading">Reuse</h2><div quarto-reuse="quarto-reuse" class="quarto-appendix-contents"><a rel="license" href="https://creativecommons.org/licenses/by-nc/4.0/">https://creativecommons.org/licenses/by-nc/4.0/</a></div></section><section class="quarto-appendix-contents"><h2 class="anchored quarto-appendix-heading">Citation</h2><div><div class="quarto-appendix-secondary-label">BibTeX citation:</div><pre class="sourceCode code-with-copy quarto-appendix-bibtex"><code class="sourceCode bibtex">@online{simpson2022,
  author = {Dan Simpson},
  editor = {},
  title = {Sparse {Matrices} 3: {Failing} at {JAX}},
  date = {2022-05-14},
  url = {https://dansblog.netlify.app/2022-05-14-jax-ing-a-sparse-cholesky-factorisation-part-3-in-an-ongoing-journey},
  langid = {en}
}
</code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre><div class="quarto-appendix-secondary-label">For attribution, please cite this work as:</div><div id="ref-simpson2022" class="csl-entry quarto-appendix-citeas" role="doc-biblioentry">
Dan Simpson. 2022. <span>“Sparse Matrices 3: Failing at JAX.”</span> May
14, 2022. <a href="https://dansblog.netlify.app/2022-05-14-jax-ing-a-sparse-cholesky-factorisation-part-3-in-an-ongoing-journey">https://dansblog.netlify.app/2022-05-14-jax-ing-a-sparse-cholesky-factorisation-part-3-in-an-ongoing-journey</a>.
</div></div></section></div></main> <!-- /main -->
<script id="quarto-html-after-body" type="application/javascript">
window.document.addEventListener("DOMContentLoaded", function (event) {
  const toggleBodyColorMode = (bsSheetEl) => {
    const mode = bsSheetEl.getAttribute("data-mode");
    const bodyEl = window.document.querySelector("body");
    if (mode === "dark") {
      bodyEl.classList.add("quarto-dark");
      bodyEl.classList.remove("quarto-light");
    } else {
      bodyEl.classList.add("quarto-light");
      bodyEl.classList.remove("quarto-dark");
    }
  }
  const toggleBodyColorPrimary = () => {
    const bsSheetEl = window.document.querySelector("link#quarto-bootstrap");
    if (bsSheetEl) {
      toggleBodyColorMode(bsSheetEl);
    }
  }
  toggleBodyColorPrimary();  
  const icon = "";
  const anchorJS = new window.AnchorJS();
  anchorJS.options = {
    placement: 'right',
    icon: icon
  };
  anchorJS.add('.anchored');
  const clipboard = new window.ClipboardJS('.code-copy-button', {
    target: function(trigger) {
      return trigger.previousElementSibling;
    }
  });
  clipboard.on('success', function(e) {
    // button target
    const button = e.trigger;
    // don't keep focus
    button.blur();
    // flash "checked"
    button.classList.add('code-copy-button-checked');
    var currentTitle = button.getAttribute("title");
    button.setAttribute("title", "Copied!");
    setTimeout(function() {
      button.setAttribute("title", currentTitle);
      button.classList.remove('code-copy-button-checked');
    }, 1000);
    // clear code selection
    e.clearSelection();
  });
  function tippyHover(el, contentFn) {
    const config = {
      allowHTML: true,
      content: contentFn,
      maxWidth: 500,
      delay: 100,
      arrow: false,
      appendTo: function(el) {
          return el.parentElement;
      },
      interactive: true,
      interactiveBorder: 10,
      theme: 'quarto',
      placement: 'bottom-start'
    };
    window.tippy(el, config); 
  }
  const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
  for (var i=0; i<noterefs.length; i++) {
    const ref = noterefs[i];
    tippyHover(ref, function() {
      // use id or data attribute instead here
      let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
      try { href = new URL(href).hash; } catch {}
      const id = href.replace(/^#\/?/, "");
      const note = window.document.getElementById(id);
      return note.innerHTML;
    });
  }
  var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
  for (var i=0; i<bibliorefs.length; i++) {
    const ref = bibliorefs[i];
    const cites = ref.parentNode.getAttribute('data-cites').split(' ');
    tippyHover(ref, function() {
      var popup = window.document.createElement('div');
      cites.forEach(function(cite) {
        var citeDiv = window.document.createElement('div');
        citeDiv.classList.add('hanging-indent');
        citeDiv.classList.add('csl-entry');
        var biblioDiv = window.document.getElementById('ref-' + cite);
        if (biblioDiv) {
          citeDiv.innerHTML = biblioDiv.innerHTML;
        }
        popup.appendChild(citeDiv);
      });
      return popup.innerHTML;
    });
  }
});
</script>
</div> <!-- /content -->



</body></html>