<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.2.15">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">

<meta name="author" content="Dan Simpson">
<meta name="dcterms.date" content="2022-05-20">
<meta name="description" content="A new JAX primitive? In this economy?">

<title>Un garçon pas comme les autres (Bayes) - Sparse Matrices 5: I bind you Nancy</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1.6em;
  vertical-align: middle;
}
pre > code.sourceCode { white-space: pre; position: relative; }
pre > code.sourceCode > span { display: inline-block; line-height: 1.25; }
pre > code.sourceCode > span:empty { height: 1.2em; }
.sourceCode { overflow: visible; }
code.sourceCode > span { color: inherit; text-decoration: inherit; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
pre > code.sourceCode { white-space: pre-wrap; }
pre > code.sourceCode > span { text-indent: -5em; padding-left: 5em; }
}
pre.numberSource code
  { counter-reset: source-line 0; }
pre.numberSource code > span
  { position: relative; left: -4em; counter-increment: source-line; }
pre.numberSource code > span > a:first-child::before
  { content: counter(source-line);
    position: relative; left: -1em; text-align: right; vertical-align: baseline;
    border: none; display: inline-block;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
    color: #aaaaaa;
  }
pre.numberSource { margin-left: 3em; border-left: 1px solid #aaaaaa;  padding-left: 4px; }
div.sourceCode
  {   }
@media screen {
pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
}
code span.al { color: #ff0000; font-weight: bold; } /* Alert */
code span.an { color: #60a0b0; font-weight: bold; font-style: italic; } /* Annotation */
code span.at { color: #7d9029; } /* Attribute */
code span.bn { color: #40a070; } /* BaseN */
code span.bu { color: #008000; } /* BuiltIn */
code span.cf { color: #007020; font-weight: bold; } /* ControlFlow */
code span.ch { color: #4070a0; } /* Char */
code span.cn { color: #880000; } /* Constant */
code span.co { color: #60a0b0; font-style: italic; } /* Comment */
code span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } /* CommentVar */
code span.do { color: #ba2121; font-style: italic; } /* Documentation */
code span.dt { color: #902000; } /* DataType */
code span.dv { color: #40a070; } /* DecVal */
code span.er { color: #ff0000; font-weight: bold; } /* Error */
code span.ex { } /* Extension */
code span.fl { color: #40a070; } /* Float */
code span.fu { color: #06287e; } /* Function */
code span.im { color: #008000; font-weight: bold; } /* Import */
code span.in { color: #60a0b0; font-weight: bold; font-style: italic; } /* Information */
code span.kw { color: #007020; font-weight: bold; } /* Keyword */
code span.op { color: #666666; } /* Operator */
code span.ot { color: #007020; } /* Other */
code span.pp { color: #bc7a00; } /* Preprocessor */
code span.sc { color: #4070a0; } /* SpecialChar */
code span.ss { color: #bb6688; } /* SpecialString */
code span.st { color: #4070a0; } /* String */
code span.va { color: #19177c; } /* Variable */
code span.vs { color: #4070a0; } /* VerbatimString */
code span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } /* Warning */
</style>


<script src="../../site_libs/quarto-nav/quarto-nav.js"></script>
<script src="../../site_libs/quarto-nav/headroom.min.js"></script>
<script src="../../site_libs/clipboard/clipboard.min.js"></script>
<script src="../../site_libs/quarto-search/autocomplete.umd.js"></script>
<script src="../../site_libs/quarto-search/fuse.min.js"></script>
<script src="../../site_libs/quarto-search/quarto-search.js"></script>
<meta name="quarto:offset" content="../../">
<script src="../../site_libs/quarto-html/quarto.js"></script>
<script src="../../site_libs/quarto-html/popper.min.js"></script>
<script src="../../site_libs/quarto-html/tippy.umd.min.js"></script>
<script src="../../site_libs/quarto-html/anchor.min.js"></script>
<link href="../../site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="../../site_libs/quarto-html/quarto-syntax-highlighting.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="../../site_libs/bootstrap/bootstrap.min.js"></script>
<link href="../../site_libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="../../site_libs/bootstrap/bootstrap.min.css" rel="stylesheet" id="quarto-bootstrap" data-mode="light">
<script id="quarto-search-options" type="application/json">{
  "location": "navbar",
  "copy-button": false,
  "collapse-after": 3,
  "panel-placement": "end",
  "type": "overlay",
  "limit": 20,
  "language": {
    "search-no-results-text": "No results",
    "search-matching-documents-text": "matching documents",
    "search-copy-link-title": "Copy link to search",
    "search-hide-matches-text": "Hide additional matches",
    "search-more-match-text": "more match in this document",
    "search-more-matches-text": "more matches in this document",
    "search-clear-button-title": "Clear",
    "search-detached-cancel-button-title": "Cancel",
    "search-submit-button-title": "Submit"
  }
}</script>

  <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml-full.js" type="text/javascript"></script>

<link rel="stylesheet" href="../../styles.css">
<meta property="og:title" content="Un garçon pas comme les autres (Bayes) - Sparse Matrices 5: I bind you Nancy">
<meta property="og:description" content="A new JAX primitive? In this economy?">
<meta property="og:image" content="https://dansblog.netlify.app/posts/2022-05-18-sparse4-some-primatives/nancy.jpg">
<meta property="og:site-name" content="Un garçon pas comme les autres (Bayes)">
<meta name="twitter:title" content="Sparse Matrices 5: I bind you Nancy">
<meta name="twitter:description" content="A new JAX primitive? In this economy?">
<meta name="twitter:image" content="https://dansblog.netlify.app/posts/2022-05-18-sparse4-some-primatives/nancy.jpg">
<meta name="twitter:creator" content="@dan_p_simpson">
<meta name="twitter:card" content="summary_large_image">
</head>

<body class="floating nav-fixed">

<div id="quarto-search-results"></div>
  <header id="quarto-header" class="headroom fixed-top">
    <nav class="navbar navbar-expand-lg navbar-dark ">
      <div class="navbar-container container-fluid">
      <div class="navbar-brand-container">
    <a class="navbar-brand" href="../../index.html">
    <span class="navbar-title">Un garçon pas comme les autres (Bayes)</span>
    </a>
  </div>
          <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbarCollapse" aria-controls="navbarCollapse" aria-expanded="false" aria-label="Toggle navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">
  <span class="navbar-toggler-icon"></span>
</button>
          <div class="collapse navbar-collapse" id="navbarCollapse">
            <ul class="navbar-nav navbar-nav-scroll ms-auto">
  <li class="nav-item">
    <a class="nav-link" href="../../about.html">About this blog</a>
  </li>  
  <li class="nav-item compact">
    <a class="nav-link" href="https://twitter.com/dan_p_simpson"><i class="bi bi-twitter" role="img" aria-label="twitter">
</i> 
 </a>
  </li>  
  <li class="nav-item compact">
    <a class="nav-link" href="https://github.com/dpsimpson"><i class="bi bi-github" role="img" aria-label="github">
</i> 
 </a>
  </li>  
  <li class="nav-item compact">
    <a class="nav-link" href="https://dansblog.netlify.app"><i class="bi bi-person-circle" role="img" aria-label="website">
</i> 
 </a>
  </li>  
</ul>
              <div id="quarto-search" class="" title="Search"></div>
          </div> <!-- /navcollapse -->
      </div> <!-- /container-fluid -->
    </nav>
</header>
<!-- content -->
<header id="title-block-header" class="quarto-title-block default toc-left page-columns page-full">
  <div class="quarto-title-banner page-columns page-full">
    <div class="quarto-title column-body">
      <h1 class="title">Sparse Matrices 5: I bind you Nancy</h1>
                  <div>
        <div class="description">
          <p>A new JAX primitive? In this economy?</p>
        </div>
      </div>
                          <div class="quarto-categories">
                <div class="quarto-category">Sparse matrices</div>
                <div class="quarto-category">Sparse Cholesky factorisation</div>
                <div class="quarto-category">Python</div>
                <div class="quarto-category">JAX</div>
              </div>
                  </div>
  </div>
    
  
  <div class="quarto-title-meta">

      <div>
      <div class="quarto-title-meta-heading">Author</div>
      <div class="quarto-title-meta-contents">
               <p>Dan Simpson </p>
            </div>
    </div>
      
      <div>
      <div class="quarto-title-meta-heading">Published</div>
      <div class="quarto-title-meta-contents">
        <p class="date">May 20, 2022</p>
      </div>
    </div>
      
    </div>
    
  
  </header><div id="quarto-content" class="quarto-container page-columns page-rows-contents page-layout-article page-navbar">
<!-- sidebar -->
  <nav id="quarto-sidebar" class="sidebar collapse sidebar-navigation floating overflow-auto">
    <nav id="TOC" role="doc-toc" class="toc-active">
    <h2 id="toc-title">Table of contents</h2>
   
  <ul>
  <li><a href="#but-how-do-you-add-a-primative-to-jax" id="toc-but-how-do-you-add-a-primative-to-jax" class="nav-link active" data-scroll-target="#but-how-do-you-add-a-primative-to-jax">But how do you add a primative to JAX?</a></li>
  <li><a href="#first-things-first-some-primitives" id="toc-first-things-first-some-primitives" class="nav-link" data-scroll-target="#first-things-first-some-primitives">First things first, some primitives</a>
  <ul class="collapse">
  <li><a href="#primitive-one-a-1b" id="toc-primitive-one-a-1b" class="nav-link" data-scroll-target="#primitive-one-a-1b">Primitive one: <span class="math inline">\(A^{-1}b\)</span></a></li>
  </ul></li>
  <li><a href="#primitive-two-the-triangular-solve" id="toc-primitive-two-the-triangular-solve" class="nav-link" data-scroll-target="#primitive-two-the-triangular-solve">Primitive two: The triangular solve</a>
  <ul class="collapse">
  <li><a href="#primitive-three-the-sparse-cholesky" id="toc-primitive-three-the-sparse-cholesky" class="nav-link" data-scroll-target="#primitive-three-the-sparse-cholesky">Primitive three: The sparse cholesky</a></li>
  </ul></li>
  <li><a href="#primitive-four-loga" id="toc-primitive-four-loga" class="nav-link" data-scroll-target="#primitive-four-loga">Primitive four: <span class="math inline">\(\log(|A|)\)</span></a></li>
  <li><a href="#where-are-we-now-but-nowhere" id="toc-where-are-we-now-but-nowhere" class="nav-link" data-scroll-target="#where-are-we-now-but-nowhere">Where are we now but nowhere?</a></li>
  </ul>
</nav>
</nav>
<!-- margin-sidebar -->
    <div id="quarto-margin-sidebar" class="sidebar margin-sidebar">
    </div>
<!-- main -->
<main class="content quarto-banner-title-block" id="quarto-document-content">




<p>This is part <em>five</em> of our <a href="https://dansblog.netlify.app/posts/2022-03-22-a-linear-mixed-effects-model/">ongoing</a> <a href="https://dansblog.netlify.app/posts/2022-03-23-getting-jax-to-love-sparse-matrices/">series</a> <a href="https://dansblog.netlify.app/posts/2022-05-14-jax-ing-a-sparse-cholesky-factorisation-part-3-in-an-ongoing-journey/">on</a> <a href="https://dansblog.netlify.app/posts/2022-05-16-design-is-my-passion-sparse-matrices-part-four/">implementing</a> differentiable sparse linear algebra in JAX. In some sense this is the last boring post before we get to the derivatives. Was this post going to include the derivatives? It sure was but then I realised that a different choice was to go to bed so I can get up nice and early in the morning and vote in our election.</p>
<p>It goes without saying that before I split the posts, it was more than twice as long and I was nowhere near finished. So probably the split was a good choice.</p>
<section id="but-how-do-you-add-a-primative-to-jax" class="level2">
<h2 class="anchored" data-anchor-id="but-how-do-you-add-a-primative-to-jax">But how do you add a primative to JAX?</h2>
<p>Well, the first step is you <a href="https://jax.readthedocs.io/en/latest/notebooks/How_JAX_primitives_work.html">read the docs.</a></p>
<p>They tell you that you need to implement a few things:</p>
<ul>
<li>An implementation of the call with “abstract types”</li>
<li>An implementation of the call with concrete types (aka evaluation the damn function)</li>
</ul>
<p>Then,</p>
<ul>
<li><p>if you want your primitive to be JIT-able, you need to implement a compilation rule.</p></li>
<li><p>if you want your primitive to be batch-able, you need to implement a batching rule.</p></li>
<li><p>if you want your primitive to be differentiable, you need to implement the derivatives in a way that allows them to be propagated appropriately.</p></li>
</ul>
<p>In this post, we are going to do the first task: we are going to register JAX-traceable versions of the four main primitives we are going to need for our task. For the most part, the implementations here will be replaced with C++ bindings (because only a fool writes their own linear algebra code). But this is the beginning<a href="#fn1" class="footnote-ref" id="fnref1" role="doc-noteref"><sup>1</sup></a> of our serious journey into JAX.</p>
</section>
<section id="first-things-first-some-primitives" class="level2">
<h2 class="anchored" data-anchor-id="first-things-first-some-primitives">First things first, some primitives</h2>
<p>In JAX-speak, a primitive is a function that is JAX-traceable<a href="#fn2" class="footnote-ref" id="fnref2" role="doc-noteref"><sup>2</sup></a>. It is not necessary for every possible transformation to be implemented. In fact, today I’m not going to implement <em>any</em> transformations. That is a problem for future Dan.</p>
<p>We have enough today problems.</p>
<p>Because today we need to write four new primitives.</p>
<p>But first of all, let’s build up a test matrix so we can at least check that this code runs. This is the same example from <a href="https://dansblog.netlify.app/posts/2022-05-14-jax-ing-a-sparse-cholesky-factorisation-part-3-in-an-ongoing-journey/">blog 3</a>. You can tell my PhD was in numerical analysis because I fucking love a 2D Laplacian.</p>
<div class="cell" data-execution_count="1">
<div class="sourceCode cell-code" id="cb1"><pre class="sourceCode numberSource python number-lines code-with-copy"><code class="sourceCode python"><span id="cb1-1"><a href="#cb1-1"></a><span class="im">from</span> scipy <span class="im">import</span> sparse</span>
<span id="cb1-2"><a href="#cb1-2"></a><span class="im">import</span> numpy <span class="im">as</span> np</span>
<span id="cb1-3"><a href="#cb1-3"></a></span>
<span id="cb1-4"><a href="#cb1-4"></a><span class="kw">def</span> make_matrix(n):</span>
<span id="cb1-5"><a href="#cb1-5"></a>    one_d <span class="op">=</span> sparse.diags([[<span class="op">-</span><span class="fl">1.</span>]<span class="op">*</span>(n<span class="op">-</span><span class="dv">1</span>), [<span class="fl">2.</span>]<span class="op">*</span>n, [<span class="op">-</span><span class="fl">1.</span>]<span class="op">*</span>(n<span class="op">-</span><span class="dv">1</span>)], [<span class="op">-</span><span class="dv">1</span>,<span class="dv">0</span>,<span class="dv">1</span>])</span>
<span id="cb1-6"><a href="#cb1-6"></a>    A <span class="op">=</span> (sparse.kronsum(one_d, one_d) <span class="op">+</span> sparse.eye(n<span class="op">*</span>n)).tocsc()</span>
<span id="cb1-7"><a href="#cb1-7"></a>    A_lower <span class="op">=</span> sparse.tril(A, <span class="bu">format</span> <span class="op">=</span> <span class="st">"csc"</span>)</span>
<span id="cb1-8"><a href="#cb1-8"></a>    A_index <span class="op">=</span> A_lower.indices</span>
<span id="cb1-9"><a href="#cb1-9"></a>    A_indptr <span class="op">=</span> A_lower.indptr</span>
<span id="cb1-10"><a href="#cb1-10"></a>    A_x <span class="op">=</span> A_lower.data</span>
<span id="cb1-11"><a href="#cb1-11"></a>    <span class="cf">return</span> (A_index, A_indptr, A_x, A)</span>
<span id="cb1-12"><a href="#cb1-12"></a></span>
<span id="cb1-13"><a href="#cb1-13"></a>A_indices, A_indptr, A_x, A <span class="op">=</span> make_matrix(<span class="dv">10</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<section id="primitive-one-a-1b" class="level3">
<h3 class="anchored" data-anchor-id="primitive-one-a-1b">Primitive one: <span class="math inline">\(A^{-1}b\)</span></h3>
<p>Because I’m feeling lazy today and we don’t actually need the Cholesky directly for any of this, I’m going to just use scipy. Why? Well, honestly, just because I’m lazy. But also so I can prove an important point: the implementation of the primitive <em>does not</em> need to be JAX traceable. So I’m implementing it in a way that is not now and will likely never be JAX traceable<a href="#fn3" class="footnote-ref" id="fnref3" role="doc-noteref"><sup>3</sup></a>.</p>
<p>First off, we need to write the solve function and bind it<a href="#fn4" class="footnote-ref" id="fnref4" role="doc-noteref"><sup>4</sup></a> to JAX. Specific information about what exactly some of these commands are doing can be found <a href="https://jax.readthedocs.io/en/latest/notebooks/How_JAX_primitives_work.html#primal-evaluation-rules">in the docs</a>, but the key thing is that there is <em>no reason</em> to dick around whit JAX types in any of these implementation functions. They are only ever called using (essentially) numpy<a href="#fn5" class="footnote-ref" id="fnref5" role="doc-noteref"><sup>5</sup></a> arrays. So we can just program like normal human beings.</p>
<div class="cell" data-execution_count="2">
<div class="sourceCode cell-code" id="cb2"><pre class="sourceCode numberSource python number-lines code-with-copy"><code class="sourceCode python"><span id="cb2-1"><a href="#cb2-1"></a><span class="im">from</span> jax <span class="im">import</span> numpy <span class="im">as</span> jnp</span>
<span id="cb2-2"><a href="#cb2-2"></a><span class="im">from</span> jax <span class="im">import</span> core</span>
<span id="cb2-3"><a href="#cb2-3"></a></span>
<span id="cb2-4"><a href="#cb2-4"></a>sparse_solve_p <span class="op">=</span> core.Primitive(<span class="st">"sparse_solve"</span>)</span>
<span id="cb2-5"><a href="#cb2-5"></a></span>
<span id="cb2-6"><a href="#cb2-6"></a><span class="kw">def</span> sparse_solve(A_indices, A_indptr, A_x, b):</span>
<span id="cb2-7"><a href="#cb2-7"></a>  <span class="co">"""A JAX traceable sparse solve"""</span></span>
<span id="cb2-8"><a href="#cb2-8"></a>  <span class="cf">return</span> sparse_solve_p.bind(A_indices, A_indptr, A_x, b)</span>
<span id="cb2-9"><a href="#cb2-9"></a></span>
<span id="cb2-10"><a href="#cb2-10"></a><span class="at">@sparse_solve_p.def_impl</span></span>
<span id="cb2-11"><a href="#cb2-11"></a><span class="kw">def</span> sparse_solve_impl(A_indices, A_indptr, A_x, b):</span>
<span id="cb2-12"><a href="#cb2-12"></a>  <span class="co">"""The implementation of the sparse solve. This is not JAX traceable."""</span></span>
<span id="cb2-13"><a href="#cb2-13"></a>  A_lower <span class="op">=</span> sparse.csc_array((A_x, A_indices, A_indptr)) </span>
<span id="cb2-14"><a href="#cb2-14"></a>  </span>
<span id="cb2-15"><a href="#cb2-15"></a>  <span class="cf">assert</span> A_lower.shape[<span class="dv">0</span>] <span class="op">==</span> A_lower.shape[<span class="dv">1</span>]</span>
<span id="cb2-16"><a href="#cb2-16"></a>  <span class="cf">assert</span> A_lower.shape[<span class="dv">0</span>] <span class="op">==</span> b.shape[<span class="dv">0</span>]</span>
<span id="cb2-17"><a href="#cb2-17"></a>  </span>
<span id="cb2-18"><a href="#cb2-18"></a>  A <span class="op">=</span> A_lower <span class="op">+</span> A_lower.T <span class="op">-</span> sparse.diags(A_lower.diagonal())</span>
<span id="cb2-19"><a href="#cb2-19"></a>  <span class="cf">return</span> sparse.linalg.spsolve(A, b)</span>
<span id="cb2-20"><a href="#cb2-20"></a></span>
<span id="cb2-21"><a href="#cb2-21"></a><span class="co">## Check it works</span></span>
<span id="cb2-22"><a href="#cb2-22"></a>b <span class="op">=</span> jnp.ones(<span class="dv">100</span>)</span>
<span id="cb2-23"><a href="#cb2-23"></a>x <span class="op">=</span> sparse_solve(A_indices, A_indptr, A_x, b)</span>
<span id="cb2-24"><a href="#cb2-24"></a></span>
<span id="cb2-25"><a href="#cb2-25"></a><span class="bu">print</span>(<span class="ss">f"The error in the sparse sovle is </span><span class="sc">{</span>np<span class="sc">.</span><span class="bu">sum</span>(np.<span class="bu">abs</span>(b <span class="op">-</span> A <span class="op">@</span> x))<span class="sc">: .2e}</span><span class="ss">"</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>The error in the sparse sovle is  0.00e+00</code></pre>
</div>
</div>
<p>In order to facilitate its transformations, JAX will occasionally<a href="#fn6" class="footnote-ref" id="fnref6" role="doc-noteref"><sup>6</sup></a> call functions using <em>abstract</em> data types. These data types know the shape of the inputs and their data type. So our next step is to specialise the <code>sparse_solve</code> function for this case. We might as well do some shape checking while we’re just hanging around. But the essential part of this function is just saying that the output of <span class="math inline">\(A^{-1}b\)</span> is the same shape as <span class="math inline">\(b\)</span> (which is usually a vector, but the code is no more complex if it’s a [dense] matrix).</p>
<div class="cell" data-execution_count="3">
<div class="sourceCode cell-code" id="cb4"><pre class="sourceCode numberSource python number-lines code-with-copy"><code class="sourceCode python"><span id="cb4-1"><a href="#cb4-1"></a><span class="im">from</span> jax._src <span class="im">import</span> abstract_arrays</span>
<span id="cb4-2"><a href="#cb4-2"></a></span>
<span id="cb4-3"><a href="#cb4-3"></a><span class="at">@sparse_solve_p.def_abstract_eval</span></span>
<span id="cb4-4"><a href="#cb4-4"></a><span class="kw">def</span> sparse_solve_abstract_eval(A_indices, A_indptr, A_x, b):</span>
<span id="cb4-5"><a href="#cb4-5"></a>  <span class="cf">assert</span> A_indices.shape[<span class="dv">0</span>] <span class="op">==</span> A_x.shape[<span class="dv">0</span>]</span>
<span id="cb4-6"><a href="#cb4-6"></a>  <span class="cf">assert</span> b.shape[<span class="dv">0</span>] <span class="op">==</span> A_indptr.shape[<span class="dv">0</span>] <span class="op">-</span> <span class="dv">1</span></span>
<span id="cb4-7"><a href="#cb4-7"></a>  <span class="cf">return</span> abstract_arrays.ShapedArray(b.shape, b.dtype)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
</section>
</section>
<section id="primitive-two-the-triangular-solve" class="level2">
<h2 class="anchored" data-anchor-id="primitive-two-the-triangular-solve">Primitive two: The triangular solve</h2>
<p>This is very similar. We need to have a function that computes <span class="math inline">\(L^{-1}b\)</span> and <span class="math inline">\(L^{-T}b\)</span>. The extra wrinkle from the last time around is that we need to pass a keyword argument <code>transpose</code> to indicate which system should be solved.</p>
<p>Once again, we are going to use the appropriate <code>scipy</code> function (in this case <code>sparse.linalg.spsolve_triangular</code>). There’s a little bit of casting between sparse matrix types here as <code>sparse.linalg.spsolve_triangular</code> assumes the matrix is in CSR format.</p>
<div class="cell" data-execution_count="4">
<div class="sourceCode cell-code" id="cb5"><pre class="sourceCode numberSource python number-lines code-with-copy"><code class="sourceCode python"><span id="cb5-1"><a href="#cb5-1"></a>sparse_triangular_solve_p <span class="op">=</span> core.Primitive(<span class="st">"sparse_triangular_solve"</span>)</span>
<span id="cb5-2"><a href="#cb5-2"></a></span>
<span id="cb5-3"><a href="#cb5-3"></a><span class="kw">def</span> sparse_triangular_solve(L_indices, L_indptr, L_x, b, <span class="op">*</span>, transpose: <span class="bu">bool</span> <span class="op">=</span> <span class="va">False</span>):</span>
<span id="cb5-4"><a href="#cb5-4"></a>  <span class="co">"""A JAX traceable sparse  triangular solve"""</span></span>
<span id="cb5-5"><a href="#cb5-5"></a>  <span class="cf">return</span> sparse_triangular_solve_p.bind(L_indices, L_indptr, L_x, b, transpose <span class="op">=</span> transpose)</span>
<span id="cb5-6"><a href="#cb5-6"></a></span>
<span id="cb5-7"><a href="#cb5-7"></a><span class="at">@sparse_triangular_solve_p.def_impl</span></span>
<span id="cb5-8"><a href="#cb5-8"></a><span class="kw">def</span> sparse_triangular_solve_impl(L_indices, L_indptr, L_x, b, <span class="op">*</span>, transpose <span class="op">=</span> <span class="va">False</span>):</span>
<span id="cb5-9"><a href="#cb5-9"></a>  <span class="co">"""The implementation of the sparse triangular solve. This is not JAX traceable."""</span></span>
<span id="cb5-10"><a href="#cb5-10"></a>  L <span class="op">=</span> sparse.csc_array((L_x, L_indices, L_indptr)) </span>
<span id="cb5-11"><a href="#cb5-11"></a>  </span>
<span id="cb5-12"><a href="#cb5-12"></a>  <span class="cf">assert</span> L.shape[<span class="dv">0</span>] <span class="op">==</span> L.shape[<span class="dv">1</span>]</span>
<span id="cb5-13"><a href="#cb5-13"></a>  <span class="cf">assert</span> L.shape[<span class="dv">0</span>] <span class="op">==</span> b.shape[<span class="dv">0</span>]</span>
<span id="cb5-14"><a href="#cb5-14"></a>  </span>
<span id="cb5-15"><a href="#cb5-15"></a>  <span class="cf">if</span> transpose:</span>
<span id="cb5-16"><a href="#cb5-16"></a>    <span class="cf">return</span> sparse.linalg.spsolve_triangular(L.T, b, lower <span class="op">=</span> <span class="va">False</span>)</span>
<span id="cb5-17"><a href="#cb5-17"></a>  <span class="cf">else</span>:</span>
<span id="cb5-18"><a href="#cb5-18"></a>    <span class="cf">return</span> sparse.linalg.spsolve_triangular(L.tocsr(), b, lower <span class="op">=</span> <span class="va">True</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>Now we can check if it works. We can use the fact that our matrix <code>(A_indices, A_indptr, A_x)</code> is lower-triangular (because we only store the lower triangle) to make our test case.</p>
<div class="cell" data-execution_count="5">
<div class="sourceCode cell-code" id="cb6"><pre class="sourceCode numberSource python number-lines code-with-copy"><code class="sourceCode python"><span id="cb6-1"><a href="#cb6-1"></a><span class="co">## Check if it works</span></span>
<span id="cb6-2"><a href="#cb6-2"></a>b <span class="op">=</span> np.random.standard_normal(<span class="dv">100</span>)</span>
<span id="cb6-3"><a href="#cb6-3"></a>x1 <span class="op">=</span> sparse_triangular_solve(A_indices, A_indptr, A_x, b)</span>
<span id="cb6-4"><a href="#cb6-4"></a>x2 <span class="op">=</span> sparse_triangular_solve(A_indices, A_indptr, A_x, b, transpose <span class="op">=</span> <span class="va">True</span>)</span>
<span id="cb6-5"><a href="#cb6-5"></a><span class="bu">print</span>(<span class="ss">f"""Error in trianglular solve: </span><span class="sc">{</span>np<span class="sc">.</span><span class="bu">sum</span>(np.<span class="bu">abs</span>(b <span class="op">-</span> sparse.tril(A) <span class="op">@</span> x1))<span class="sc">: .2e}</span></span>
<span id="cb6-6"><a href="#cb6-6"></a><span class="ss">Error in triangular transpose solve: </span><span class="sc">{</span>np<span class="sc">.</span><span class="bu">sum</span>(np.<span class="bu">abs</span>(b <span class="op">-</span> sparse.triu(A) <span class="op">@</span> x2))<span class="sc">: .2e}</span><span class="ss">"""</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>Error in trianglular solve:  3.53e-15
Error in triangular transpose solve:  5.08e-15</code></pre>
</div>
</div>
<p>And we can also do the abstract evaluation.</p>
<div class="cell" data-execution_count="6">
<div class="sourceCode cell-code" id="cb8"><pre class="sourceCode numberSource python number-lines code-with-copy"><code class="sourceCode python"><span id="cb8-1"><a href="#cb8-1"></a><span class="at">@sparse_triangular_solve_p.def_abstract_eval</span></span>
<span id="cb8-2"><a href="#cb8-2"></a><span class="kw">def</span> sparse_triangular_solve_abstract_eval(L_indices, L_indptr, L_x, b, <span class="op">*</span>, transpose <span class="op">=</span> <span class="va">False</span>):</span>
<span id="cb8-3"><a href="#cb8-3"></a>  <span class="cf">assert</span> L_indices.shape[<span class="dv">0</span>] <span class="op">==</span> L_x.shape[<span class="dv">0</span>]</span>
<span id="cb8-4"><a href="#cb8-4"></a>  <span class="cf">assert</span> b.shape[<span class="dv">0</span>] <span class="op">==</span> L_indptr.shape[<span class="dv">0</span>] <span class="op">-</span> <span class="dv">1</span></span>
<span id="cb8-5"><a href="#cb8-5"></a>  <span class="cf">return</span> abstract_arrays.ShapedArray(b.shape, b.dtype)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>Great! Now on to the next one!</p>
<section id="primitive-three-the-sparse-cholesky" class="level3">
<h3 class="anchored" data-anchor-id="primitive-three-the-sparse-cholesky">Primitive three: The sparse cholesky</h3>
<p>Ok. This one is gonna be a pain in the arse. But we need to do it. Why? Because we are going to need a JAX-traceable version further on down the track.</p>
<p>The issue here is that the non-zero pattern of the Cholesky decomposition is computed <em>on the fly</em>. This is absolutely not allowed in JAX. It <em>must</em> know the shape of all things at the moment it is called.</p>
<p>This is going to make for a somewhat shitty user experience for this function. It’s unavoidable with JAX designed<a href="#fn7" class="footnote-ref" id="fnref7" role="doc-noteref"><sup>7</sup></a> the way it is.</p>
<p>The code in <code>jax.experimental.sparse.bcoo.fromdense</code> has this exact problem. In their case, they are turning a dense matrix into a sparse matrix and they can’t know until they see the dense matrix how many non-zeros there are. So they do the sensible thing and ask the user to specify it. They do this using the <code>nse</code> keyword parameter. If you’re curious what <code>nse</code> stands for, it turns out it’s not “non-standard evaluation” but rather “number of specified entries”. Most other systems use the abbreviation <code>nnz</code> for “number of non-zeros”, but I’m going to stick with the JAX notation.</p>
<p>The one little thing we need to add to this code is a guard to make sure that if the <code>sparse_cholesky</code> function is called without specifying</p>
<div class="cell" data-execution_count="7">
<div class="sourceCode cell-code" id="cb9"><pre class="sourceCode numberSource python number-lines code-with-copy"><code class="sourceCode python"><span id="cb9-1"><a href="#cb9-1"></a>sparse_cholesky_p <span class="op">=</span> core.Primitive(<span class="st">"sparse_cholesky"</span>)</span>
<span id="cb9-2"><a href="#cb9-2"></a></span>
<span id="cb9-3"><a href="#cb9-3"></a><span class="kw">def</span> sparse_cholesky(A_indices, A_indptr, A_x, <span class="op">*</span>, L_nse: <span class="bu">int</span> <span class="op">=</span> <span class="va">None</span>):</span>
<span id="cb9-4"><a href="#cb9-4"></a>  <span class="co">"""A JAX traceable sparse cholesky decomposition"""</span></span>
<span id="cb9-5"><a href="#cb9-5"></a>  <span class="cf">if</span> L_nse <span class="kw">is</span> <span class="va">None</span>:</span>
<span id="cb9-6"><a href="#cb9-6"></a>    err_string <span class="op">=</span> <span class="st">"You need to pass a value to L_nse when doing fancy sparse_cholesky."</span></span>
<span id="cb9-7"><a href="#cb9-7"></a>    _ <span class="op">=</span> core.concrete_or_error(<span class="va">None</span>, A_x, err_string)</span>
<span id="cb9-8"><a href="#cb9-8"></a>  <span class="cf">return</span> sparse_cholesky_p.bind(A_indices, A_indptr, A_x, L_nse <span class="op">=</span> L_nse)</span>
<span id="cb9-9"><a href="#cb9-9"></a></span>
<span id="cb9-10"><a href="#cb9-10"></a><span class="at">@sparse_cholesky_p.def_impl</span></span>
<span id="cb9-11"><a href="#cb9-11"></a><span class="kw">def</span> sparse_cholesky_impl(A_indices, A_indptr, A_x, <span class="op">*</span>, L_nse <span class="op">=</span> <span class="va">None</span>):</span>
<span id="cb9-12"><a href="#cb9-12"></a>  <span class="co">"""The implementation of the sparse cholesky This is not JAX traceable."""</span></span>
<span id="cb9-13"><a href="#cb9-13"></a>  </span>
<span id="cb9-14"><a href="#cb9-14"></a>  L_indices, L_indptr<span class="op">=</span> _symbolic_factor(A_indices, A_indptr)</span>
<span id="cb9-15"><a href="#cb9-15"></a>  <span class="cf">if</span> L_nse <span class="kw">is</span> <span class="kw">not</span> <span class="va">None</span>:</span>
<span id="cb9-16"><a href="#cb9-16"></a>    <span class="cf">assert</span> <span class="bu">len</span>(L_indices) <span class="op">==</span> nse</span>
<span id="cb9-17"><a href="#cb9-17"></a>    </span>
<span id="cb9-18"><a href="#cb9-18"></a>  L_x <span class="op">=</span> _structured_copy(A_indices, A_indptr, A_x, L_indices, L_indptr)</span>
<span id="cb9-19"><a href="#cb9-19"></a>  L_x <span class="op">=</span> _sparse_cholesky_impl(L_indices, L_indptr, L_x)</span>
<span id="cb9-20"><a href="#cb9-20"></a>  <span class="cf">return</span> L_indices, L_indptr, L_x</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>The rest of the code is just the sparse Cholesky code from <a href="https://dansblog.netlify.app/posts/2022-03-23-getting-jax-to-love-sparse-matrices/">blog 2</a> and I’ve hidden it under the fold. (You would think I would package this up properly, but I simply haven’t. Why not? Who knows<a href="#fn8" class="footnote-ref" id="fnref8" role="doc-noteref"><sup>8</sup></a>.)</p>
<details>
<summary>
Click here to see the implementation
</summary>
<div class="cell" data-execution_count="8">
<div class="sourceCode cell-code" id="cb10"><pre class="sourceCode numberSource python number-lines code-with-copy"><code class="sourceCode python"><span id="cb10-1"><a href="#cb10-1"></a><span class="kw">def</span> _symbolic_factor(A_indices, A_indptr):</span>
<span id="cb10-2"><a href="#cb10-2"></a>  <span class="co"># Assumes A_indices and A_indptr index the lower triangle of $A$ ONLY.</span></span>
<span id="cb10-3"><a href="#cb10-3"></a>  n <span class="op">=</span> <span class="bu">len</span>(A_indptr) <span class="op">-</span> <span class="dv">1</span></span>
<span id="cb10-4"><a href="#cb10-4"></a>  L_sym <span class="op">=</span> [np.array([], dtype<span class="op">=</span><span class="bu">int</span>) <span class="cf">for</span> j <span class="kw">in</span> <span class="bu">range</span>(n)]</span>
<span id="cb10-5"><a href="#cb10-5"></a>  children <span class="op">=</span> [np.array([], dtype<span class="op">=</span><span class="bu">int</span>) <span class="cf">for</span> j <span class="kw">in</span> <span class="bu">range</span>(n)]</span>
<span id="cb10-6"><a href="#cb10-6"></a>  </span>
<span id="cb10-7"><a href="#cb10-7"></a>  <span class="cf">for</span> j <span class="kw">in</span> <span class="bu">range</span>(n):</span>
<span id="cb10-8"><a href="#cb10-8"></a>    L_sym[j] <span class="op">=</span> A_indices[A_indptr[j]:A_indptr[j <span class="op">+</span> <span class="dv">1</span>]]</span>
<span id="cb10-9"><a href="#cb10-9"></a>    <span class="cf">for</span> child <span class="kw">in</span> children[j]:</span>
<span id="cb10-10"><a href="#cb10-10"></a>      tmp <span class="op">=</span> L_sym[child][L_sym[child] <span class="op">&gt;</span> j]</span>
<span id="cb10-11"><a href="#cb10-11"></a>      L_sym[j] <span class="op">=</span> np.unique(np.append(L_sym[j], tmp))</span>
<span id="cb10-12"><a href="#cb10-12"></a>    <span class="cf">if</span> <span class="bu">len</span>(L_sym[j]) <span class="op">&gt;</span> <span class="dv">1</span>:</span>
<span id="cb10-13"><a href="#cb10-13"></a>      p <span class="op">=</span> L_sym[j][<span class="dv">1</span>]</span>
<span id="cb10-14"><a href="#cb10-14"></a>      children[p] <span class="op">=</span> np.append(children[p], j)</span>
<span id="cb10-15"><a href="#cb10-15"></a>        </span>
<span id="cb10-16"><a href="#cb10-16"></a>  L_indptr <span class="op">=</span> np.zeros(n<span class="op">+</span><span class="dv">1</span>, dtype<span class="op">=</span><span class="bu">int</span>)</span>
<span id="cb10-17"><a href="#cb10-17"></a>  L_indptr[<span class="dv">1</span>:] <span class="op">=</span> np.cumsum([<span class="bu">len</span>(x) <span class="cf">for</span> x <span class="kw">in</span> L_sym])</span>
<span id="cb10-18"><a href="#cb10-18"></a>  L_indices <span class="op">=</span> np.concatenate(L_sym)</span>
<span id="cb10-19"><a href="#cb10-19"></a>  </span>
<span id="cb10-20"><a href="#cb10-20"></a>  <span class="cf">return</span> L_indices, L_indptr</span>
<span id="cb10-21"><a href="#cb10-21"></a></span>
<span id="cb10-22"><a href="#cb10-22"></a></span>
<span id="cb10-23"><a href="#cb10-23"></a></span>
<span id="cb10-24"><a href="#cb10-24"></a><span class="kw">def</span> _structured_copy(A_indices, A_indptr, A_x, L_indices, L_indptr):</span>
<span id="cb10-25"><a href="#cb10-25"></a>  n <span class="op">=</span> <span class="bu">len</span>(A_indptr) <span class="op">-</span> <span class="dv">1</span></span>
<span id="cb10-26"><a href="#cb10-26"></a>  L_x <span class="op">=</span> np.zeros(<span class="bu">len</span>(L_indices))</span>
<span id="cb10-27"><a href="#cb10-27"></a>  </span>
<span id="cb10-28"><a href="#cb10-28"></a>  <span class="cf">for</span> j <span class="kw">in</span> <span class="bu">range</span>(<span class="dv">0</span>, n):</span>
<span id="cb10-29"><a href="#cb10-29"></a>    copy_idx <span class="op">=</span> np.nonzero(np.in1d(L_indices[L_indptr[j]:L_indptr[j <span class="op">+</span> <span class="dv">1</span>]],</span>
<span id="cb10-30"><a href="#cb10-30"></a>                                  A_indices[A_indptr[j]:A_indptr[j<span class="op">+</span><span class="dv">1</span>]]))[<span class="dv">0</span>]</span>
<span id="cb10-31"><a href="#cb10-31"></a>    L_x[L_indptr[j] <span class="op">+</span> copy_idx] <span class="op">=</span> A_x[A_indptr[j]:A_indptr[j<span class="op">+</span><span class="dv">1</span>]]</span>
<span id="cb10-32"><a href="#cb10-32"></a>  <span class="cf">return</span> L_x</span>
<span id="cb10-33"><a href="#cb10-33"></a></span>
<span id="cb10-34"><a href="#cb10-34"></a><span class="kw">def</span> _sparse_cholesky_impl(L_indices, L_indptr, L_x):</span>
<span id="cb10-35"><a href="#cb10-35"></a>  n <span class="op">=</span> <span class="bu">len</span>(L_indptr) <span class="op">-</span> <span class="dv">1</span></span>
<span id="cb10-36"><a href="#cb10-36"></a>  descendant <span class="op">=</span> [[] <span class="cf">for</span> j <span class="kw">in</span> <span class="bu">range</span>(<span class="dv">0</span>, n)]</span>
<span id="cb10-37"><a href="#cb10-37"></a>  <span class="cf">for</span> j <span class="kw">in</span> <span class="bu">range</span>(<span class="dv">0</span>, n):</span>
<span id="cb10-38"><a href="#cb10-38"></a>    tmp <span class="op">=</span> L_x[L_indptr[j]:L_indptr[j <span class="op">+</span> <span class="dv">1</span>]]</span>
<span id="cb10-39"><a href="#cb10-39"></a>    <span class="cf">for</span> bebe <span class="kw">in</span> descendant[j]:</span>
<span id="cb10-40"><a href="#cb10-40"></a>      k <span class="op">=</span> bebe[<span class="dv">0</span>]</span>
<span id="cb10-41"><a href="#cb10-41"></a>      Ljk<span class="op">=</span> L_x[bebe[<span class="dv">1</span>]]</span>
<span id="cb10-42"><a href="#cb10-42"></a>      pad <span class="op">=</span> np.nonzero(                                                       <span class="op">\</span></span>
<span id="cb10-43"><a href="#cb10-43"></a>          L_indices[L_indptr[k]:L_indptr[k<span class="op">+</span><span class="dv">1</span>]] <span class="op">==</span> L_indices[L_indptr[j]])[<span class="dv">0</span>][<span class="dv">0</span>]</span>
<span id="cb10-44"><a href="#cb10-44"></a>      update_idx <span class="op">=</span> np.nonzero(np.in1d(                                        <span class="op">\</span></span>
<span id="cb10-45"><a href="#cb10-45"></a>                    L_indices[L_indptr[j]:L_indptr[j<span class="op">+</span><span class="dv">1</span>]],                     <span class="op">\</span></span>
<span id="cb10-46"><a href="#cb10-46"></a>                    L_indices[(L_indptr[k] <span class="op">+</span> pad):L_indptr[k<span class="op">+</span><span class="dv">1</span>]]))[<span class="dv">0</span>]</span>
<span id="cb10-47"><a href="#cb10-47"></a>      tmp[update_idx] <span class="op">=</span> tmp[update_idx] <span class="op">-</span>                                     <span class="op">\</span></span>
<span id="cb10-48"><a href="#cb10-48"></a>                        Ljk <span class="op">*</span> L_x[(L_indptr[k] <span class="op">+</span> pad):L_indptr[k <span class="op">+</span> <span class="dv">1</span>]]</span>
<span id="cb10-49"><a href="#cb10-49"></a>            </span>
<span id="cb10-50"><a href="#cb10-50"></a>    diag <span class="op">=</span> np.sqrt(tmp[<span class="dv">0</span>])</span>
<span id="cb10-51"><a href="#cb10-51"></a>    L_x[L_indptr[j]] <span class="op">=</span> diag</span>
<span id="cb10-52"><a href="#cb10-52"></a>    L_x[(L_indptr[j] <span class="op">+</span> <span class="dv">1</span>):L_indptr[j <span class="op">+</span> <span class="dv">1</span>]] <span class="op">=</span> tmp[<span class="dv">1</span>:] <span class="op">/</span> diag</span>
<span id="cb10-53"><a href="#cb10-53"></a>    <span class="cf">for</span> idx <span class="kw">in</span> <span class="bu">range</span>(L_indptr[j] <span class="op">+</span> <span class="dv">1</span>, L_indptr[j <span class="op">+</span> <span class="dv">1</span>]):</span>
<span id="cb10-54"><a href="#cb10-54"></a>      descendant[L_indices[idx]].append((j, idx))</span>
<span id="cb10-55"><a href="#cb10-55"></a>  <span class="cf">return</span> L_x</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
</details>
<p>Once again, we can check to see if this worked!</p>
<div class="cell" data-execution_count="9">
<div class="sourceCode cell-code" id="cb11"><pre class="sourceCode numberSource python number-lines code-with-copy"><code class="sourceCode python"><span id="cb11-1"><a href="#cb11-1"></a>L_indices, L_indptr, L_x <span class="op">=</span> sparse_cholesky(A_indices, A_indptr, A_x)</span>
<span id="cb11-2"><a href="#cb11-2"></a>L <span class="op">=</span> sparse.csc_array((L_x, L_indices, L_indptr))</span>
<span id="cb11-3"><a href="#cb11-3"></a><span class="bu">print</span>(<span class="ss">f"The error in the sparse cholesky is </span><span class="sc">{</span>np<span class="sc">.</span><span class="bu">sum</span>(np.<span class="bu">abs</span>((A <span class="op">-</span> L <span class="op">@</span> L.T).todense()))<span class="sc">: .2e}</span><span class="ss">"</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>The error in the sparse cholesky is  1.02e-13</code></pre>
</div>
</div>
<p>And, of course, we can do abstract evaluation. Here is where we actually need to use <code>L_nse</code> to work out the dimension of our output.</p>
<div class="cell" data-execution_count="10">
<div class="sourceCode cell-code" id="cb13"><pre class="sourceCode numberSource python number-lines code-with-copy"><code class="sourceCode python"><span id="cb13-1"><a href="#cb13-1"></a><span class="at">@sparse_cholesky_p.def_abstract_eval</span></span>
<span id="cb13-2"><a href="#cb13-2"></a><span class="kw">def</span> sparse_cholesky_abstract_eval(A_indices, A_indptr, A_x, <span class="op">*</span>, L_nse):</span>
<span id="cb13-3"><a href="#cb13-3"></a>  <span class="cf">return</span> core.ShapedArray((L_nse,), A_indices.dtype),                   <span class="op">\</span></span>
<span id="cb13-4"><a href="#cb13-4"></a>         core.ShapedArray(A_indptr.shape, A_indptr.dtype),             <span class="op">\</span></span>
<span id="cb13-5"><a href="#cb13-5"></a>         core.ShapedArray((L_nse,), A_x.dtype)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
</section>
</section>
<section id="primitive-four-loga" class="level2">
<h2 class="anchored" data-anchor-id="primitive-four-loga">Primitive four: <span class="math inline">\(\log(|A|)\)</span></h2>
<p>And now we have our final primitive: the log determinant! Wow. So much binding. For this one, we compute the Cholesky factorisation and note that <span class="math display">\[\begin{align*}
|A| = |LL^T| = |L||L^T| = |L|^2.
\end{align*}\]</span> If we successfully remember that the determinant of a triangular matrix is the product of its diagonal entries, we have a formula we can implement.</p>
<p>Same deal as last time.</p>
<div class="cell" data-execution_count="11">
<div class="sourceCode cell-code" id="cb14"><pre class="sourceCode numberSource python number-lines code-with-copy"><code class="sourceCode python"><span id="cb14-1"><a href="#cb14-1"></a>sparse_log_det_p <span class="op">=</span> core.Primitive(<span class="st">"sparse_log_det"</span>)</span>
<span id="cb14-2"><a href="#cb14-2"></a></span>
<span id="cb14-3"><a href="#cb14-3"></a><span class="kw">def</span> sparse_log_det(A_indices, A_indptr, A_x):</span>
<span id="cb14-4"><a href="#cb14-4"></a>  <span class="co">"""A JAX traceable sparse log-determinant"""</span></span>
<span id="cb14-5"><a href="#cb14-5"></a>  <span class="cf">return</span> sparse_log_det_p.bind(A_indices, A_indptr, A_x)</span>
<span id="cb14-6"><a href="#cb14-6"></a></span>
<span id="cb14-7"><a href="#cb14-7"></a><span class="at">@sparse_log_det_p.def_impl</span></span>
<span id="cb14-8"><a href="#cb14-8"></a><span class="kw">def</span> sparse_log_det_impl(A_indices, A_indptr, A_x):</span>
<span id="cb14-9"><a href="#cb14-9"></a>  <span class="co">"""The implementation of the sparse log-determinant. This is not JAX traceable.</span></span>
<span id="cb14-10"><a href="#cb14-10"></a><span class="co">  """</span></span>
<span id="cb14-11"><a href="#cb14-11"></a>  L_indices, L_indptr, L_x <span class="op">=</span> sparse_cholesky_impl(A_indices, A_indptr, A_x)</span>
<span id="cb14-12"><a href="#cb14-12"></a>  <span class="cf">return</span> <span class="fl">2.0</span> <span class="op">*</span> <span class="bu">sum</span>(np.log(L_x[L_indptr[:<span class="op">-</span><span class="dv">1</span>]]))</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>A canny reader may notice that I’m assuming that the first element in each column is the diagonal. This will be true as long as the diagonal elements of <span class="math inline">\(L\)</span> are non-zero, which is true as long as <span class="math inline">\(A\)</span> is symmetric positive definite.</p>
<p>Let’s test<a href="#fn9" class="footnote-ref" id="fnref9" role="doc-noteref"><sup>9</sup></a> it out.</p>
<div class="cell" data-execution_count="12">
<div class="sourceCode cell-code" id="cb15"><pre class="sourceCode numberSource python number-lines code-with-copy"><code class="sourceCode python"><span id="cb15-1"><a href="#cb15-1"></a>ld <span class="op">=</span> sparse_log_det(A_indices, A_indptr, A_x)</span>
<span id="cb15-2"><a href="#cb15-2"></a>LU <span class="op">=</span> sparse.linalg.splu(A)</span>
<span id="cb15-3"><a href="#cb15-3"></a>ld_true <span class="op">=</span> <span class="bu">sum</span>(np.log(LU.U.diagonal()))</span>
<span id="cb15-4"><a href="#cb15-4"></a><span class="bu">print</span>(<span class="ss">f"The error in the log-determinant is </span><span class="sc">{</span>ld <span class="op">-</span> ld_true<span class="sc">: .2e}</span><span class="ss">"</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>The error in the log-determinant is  0.00e+00</code></pre>
</div>
</div>
<p>Finally, we can do the abstract evaluation.</p>
<div class="cell" data-execution_count="13">
<div class="sourceCode cell-code" id="cb17"><pre class="sourceCode numberSource python number-lines code-with-copy"><code class="sourceCode python"><span id="cb17-1"><a href="#cb17-1"></a><span class="at">@sparse_log_det_p.def_abstract_eval</span></span>
<span id="cb17-2"><a href="#cb17-2"></a><span class="kw">def</span> sparse_log_det_abstract_eval(A_indices, A_indptr, A_x):</span>
<span id="cb17-3"><a href="#cb17-3"></a>  <span class="cf">return</span> core.ShapedArray((<span class="dv">1</span>,), A_x.dtype)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
</section>
<section id="where-are-we-now-but-nowhere" class="level2">
<h2 class="anchored" data-anchor-id="where-are-we-now-but-nowhere">Where are we now but nowhere?</h2>
<p>So we are done for today. Our next step will be to implement all of the bits that are needed to make the derivatives work. So in the next instalment we will differentiate log-determinants, Cholesky decompositions, and all kinds of other fun things.</p>
<p>It should be a blast.</p>


</section>


<div id="quarto-appendix" class="default"><section id="footnotes" class="footnotes footnotes-end-of-document" role="doc-endnotes"><h2 class="anchored quarto-appendix-heading">Footnotes</h2>

<ol>
<li id="fn1"><p>The second half of this post is half written but, to be honest, I want to go to bed more than I want to implement more derivatives, so I’m splitting the post.<a href="#fnref1" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn2"><p>aka JAX can map out how the pieces of the function go together and it can then use that map to make its weird transformations<a href="#fnref2" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn3"><p>But mostly because although I’m going to have to implement the Cholesky and triangular solves later on down the line, I’m writing this in order and I don’t wanna.<a href="#fnref3" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn4"><p>The JAX docs don’t use decorators for their bindings but I use decorators because I like decorators.<a href="#fnref4" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn5"><p>Something something duck type. They’re arrays with numbers in them that work in numpy and scipy. Get off my arse.<a href="#fnref5" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn6"><p>This is mostly for JIT, so it’s not necessary today, but to be very honest it’s the only easy thing to do here and I’m not above giving myself a participation trophy.<a href="#fnref6" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn7"><p>This is a … fringe problem in JAX-land, so it makes sense that there is a less than beautiful solution to the problem. I think this would be less of a design problem in Stan, where it’s possible to make the number of unknowns in the autodiff tree depend on <code>int</code> arrays is a complex way.<a href="#fnref7" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn8"><p>Well, me. I’m who knows. I’m still treating this like scratch code in a notepad. Although we are moving towards the point where I’m going to have to set everything out properly. Maybe that’s the next post?<a href="#fnref8" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn9"><p>Full disclosure: first time out I forgot to multiply by two. This is why we test.<a href="#fnref9" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
</ol>
</section><section class="quarto-appendix-contents"><h2 class="anchored quarto-appendix-heading">Reuse</h2><div quarto-reuse="quarto-reuse" class="quarto-appendix-contents"><a rel="license" href="https://creativecommons.org/licenses/by-nc/4.0/">https://creativecommons.org/licenses/by-nc/4.0/</a></div></section><section class="quarto-appendix-contents"><h2 class="anchored quarto-appendix-heading">Citation</h2><div><div class="quarto-appendix-secondary-label">BibTeX citation:</div><pre class="sourceCode code-with-copy quarto-appendix-bibtex"><code class="sourceCode bibtex">@online{simpson2022,
  author = {Dan Simpson},
  editor = {},
  title = {Sparse {Matrices} 5: {I} Bind You {Nancy}},
  date = {2022-05-20},
  url = {https://dansblog.netlify.app/2022-05-18-sparse4-some-primatives},
  langid = {en}
}
</code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre><div class="quarto-appendix-secondary-label">For attribution, please cite this work as:</div><div id="ref-simpson2022" class="csl-entry quarto-appendix-citeas" role="doc-biblioentry">
Dan Simpson. 2022. <span>“Sparse Matrices 5: I Bind You Nancy.”</span>
May 20, 2022. <a href="https://dansblog.netlify.app/2022-05-18-sparse4-some-primatives">https://dansblog.netlify.app/2022-05-18-sparse4-some-primatives</a>.
</div></div></section></div></main> <!-- /main -->
<script id="quarto-html-after-body" type="application/javascript">
window.document.addEventListener("DOMContentLoaded", function (event) {
  const toggleBodyColorMode = (bsSheetEl) => {
    const mode = bsSheetEl.getAttribute("data-mode");
    const bodyEl = window.document.querySelector("body");
    if (mode === "dark") {
      bodyEl.classList.add("quarto-dark");
      bodyEl.classList.remove("quarto-light");
    } else {
      bodyEl.classList.add("quarto-light");
      bodyEl.classList.remove("quarto-dark");
    }
  }
  const toggleBodyColorPrimary = () => {
    const bsSheetEl = window.document.querySelector("link#quarto-bootstrap");
    if (bsSheetEl) {
      toggleBodyColorMode(bsSheetEl);
    }
  }
  toggleBodyColorPrimary();  
  const icon = "";
  const anchorJS = new window.AnchorJS();
  anchorJS.options = {
    placement: 'right',
    icon: icon
  };
  anchorJS.add('.anchored');
  const clipboard = new window.ClipboardJS('.code-copy-button', {
    target: function(trigger) {
      return trigger.previousElementSibling;
    }
  });
  clipboard.on('success', function(e) {
    // button target
    const button = e.trigger;
    // don't keep focus
    button.blur();
    // flash "checked"
    button.classList.add('code-copy-button-checked');
    var currentTitle = button.getAttribute("title");
    button.setAttribute("title", "Copied!");
    setTimeout(function() {
      button.setAttribute("title", currentTitle);
      button.classList.remove('code-copy-button-checked');
    }, 1000);
    // clear code selection
    e.clearSelection();
  });
  function tippyHover(el, contentFn) {
    const config = {
      allowHTML: true,
      content: contentFn,
      maxWidth: 500,
      delay: 100,
      arrow: false,
      appendTo: function(el) {
          return el.parentElement;
      },
      interactive: true,
      interactiveBorder: 10,
      theme: 'quarto',
      placement: 'bottom-start'
    };
    window.tippy(el, config); 
  }
  const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
  for (var i=0; i<noterefs.length; i++) {
    const ref = noterefs[i];
    tippyHover(ref, function() {
      // use id or data attribute instead here
      let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
      try { href = new URL(href).hash; } catch {}
      const id = href.replace(/^#\/?/, "");
      const note = window.document.getElementById(id);
      return note.innerHTML;
    });
  }
  var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
  for (var i=0; i<bibliorefs.length; i++) {
    const ref = bibliorefs[i];
    const cites = ref.parentNode.getAttribute('data-cites').split(' ');
    tippyHover(ref, function() {
      var popup = window.document.createElement('div');
      cites.forEach(function(cite) {
        var citeDiv = window.document.createElement('div');
        citeDiv.classList.add('hanging-indent');
        citeDiv.classList.add('csl-entry');
        var biblioDiv = window.document.getElementById('ref-' + cite);
        if (biblioDiv) {
          citeDiv.innerHTML = biblioDiv.innerHTML;
        }
        popup.appendChild(citeDiv);
      });
      return popup.innerHTML;
    });
  }
});
</script>
</div> <!-- /content -->



</body></html>