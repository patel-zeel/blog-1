<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.2.15">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">

<meta name="author" content="Dan Simpson">
<meta name="dcterms.date" content="2022-05-30">
<meta name="description" content="Open up the kennels, Kenneth. Mamma’s coming home tonight.">

<title>Un garçon pas comme les autres (Bayes) - Sparse matrices 6: To catch a derivative, first you’ve got to think like a derivative</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1.6em;
  vertical-align: middle;
}
pre > code.sourceCode { white-space: pre; position: relative; }
pre > code.sourceCode > span { display: inline-block; line-height: 1.25; }
pre > code.sourceCode > span:empty { height: 1.2em; }
.sourceCode { overflow: visible; }
code.sourceCode > span { color: inherit; text-decoration: inherit; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
pre > code.sourceCode { white-space: pre-wrap; }
pre > code.sourceCode > span { text-indent: -5em; padding-left: 5em; }
}
pre.numberSource code
  { counter-reset: source-line 0; }
pre.numberSource code > span
  { position: relative; left: -4em; counter-increment: source-line; }
pre.numberSource code > span > a:first-child::before
  { content: counter(source-line);
    position: relative; left: -1em; text-align: right; vertical-align: baseline;
    border: none; display: inline-block;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
    color: #aaaaaa;
  }
pre.numberSource { margin-left: 3em; border-left: 1px solid #aaaaaa;  padding-left: 4px; }
div.sourceCode
  {   }
@media screen {
pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
}
code span.al { color: #ff0000; font-weight: bold; } /* Alert */
code span.an { color: #60a0b0; font-weight: bold; font-style: italic; } /* Annotation */
code span.at { color: #7d9029; } /* Attribute */
code span.bn { color: #40a070; } /* BaseN */
code span.bu { color: #008000; } /* BuiltIn */
code span.cf { color: #007020; font-weight: bold; } /* ControlFlow */
code span.ch { color: #4070a0; } /* Char */
code span.cn { color: #880000; } /* Constant */
code span.co { color: #60a0b0; font-style: italic; } /* Comment */
code span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } /* CommentVar */
code span.do { color: #ba2121; font-style: italic; } /* Documentation */
code span.dt { color: #902000; } /* DataType */
code span.dv { color: #40a070; } /* DecVal */
code span.er { color: #ff0000; font-weight: bold; } /* Error */
code span.ex { } /* Extension */
code span.fl { color: #40a070; } /* Float */
code span.fu { color: #06287e; } /* Function */
code span.im { color: #008000; font-weight: bold; } /* Import */
code span.in { color: #60a0b0; font-weight: bold; font-style: italic; } /* Information */
code span.kw { color: #007020; font-weight: bold; } /* Keyword */
code span.op { color: #666666; } /* Operator */
code span.ot { color: #007020; } /* Other */
code span.pp { color: #bc7a00; } /* Preprocessor */
code span.sc { color: #4070a0; } /* SpecialChar */
code span.ss { color: #bb6688; } /* SpecialString */
code span.st { color: #4070a0; } /* String */
code span.va { color: #19177c; } /* Variable */
code span.vs { color: #4070a0; } /* VerbatimString */
code span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } /* Warning */
</style>


<script src="../../site_libs/quarto-nav/quarto-nav.js"></script>
<script src="../../site_libs/quarto-nav/headroom.min.js"></script>
<script src="../../site_libs/clipboard/clipboard.min.js"></script>
<script src="../../site_libs/quarto-search/autocomplete.umd.js"></script>
<script src="../../site_libs/quarto-search/fuse.min.js"></script>
<script src="../../site_libs/quarto-search/quarto-search.js"></script>
<meta name="quarto:offset" content="../../">
<script src="../../site_libs/quarto-html/quarto.js"></script>
<script src="../../site_libs/quarto-html/popper.min.js"></script>
<script src="../../site_libs/quarto-html/tippy.umd.min.js"></script>
<script src="../../site_libs/quarto-html/anchor.min.js"></script>
<link href="../../site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="../../site_libs/quarto-html/quarto-syntax-highlighting.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="../../site_libs/bootstrap/bootstrap.min.js"></script>
<link href="../../site_libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="../../site_libs/bootstrap/bootstrap.min.css" rel="stylesheet" id="quarto-bootstrap" data-mode="light">
<script id="quarto-search-options" type="application/json">{
  "location": "navbar",
  "copy-button": false,
  "collapse-after": 3,
  "panel-placement": "end",
  "type": "overlay",
  "limit": 20,
  "language": {
    "search-no-results-text": "No results",
    "search-matching-documents-text": "matching documents",
    "search-copy-link-title": "Copy link to search",
    "search-hide-matches-text": "Hide additional matches",
    "search-more-match-text": "more match in this document",
    "search-more-matches-text": "more matches in this document",
    "search-clear-button-title": "Clear",
    "search-detached-cancel-button-title": "Cancel",
    "search-submit-button-title": "Submit"
  }
}</script>

  <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml-full.js" type="text/javascript"></script>

<link rel="stylesheet" href="../../styles.css">
<meta property="og:title" content="Un garçon pas comme les autres (Bayes) - Sparse matrices 6: To catch a derivative, first you’ve got to think like a derivative">
<meta property="og:description" content="Open up the kennels, Kenneth. Mamma’s coming home tonight.">
<meta property="og:image" content="https://dansblog.netlify.app/posts/2022-05-20-to-catch-a-derivative-first-youve-got-to-think-like-a-derivative/sob.JPG">
<meta property="og:site-name" content="Un garçon pas comme les autres (Bayes)">
<meta name="twitter:title" content="twitter title">
<meta name="twitter:description" content="Open up the kennels, Kenneth. Mamma’s coming home tonight.">
<meta name="twitter:image" content="https://dansblog.netlify.app/posts/2022-05-20-to-catch-a-derivative-first-youve-got-to-think-like-a-derivative/sob.JPG">
<meta name="twitter:creator" content="@dan_p_simpson">
<meta name="twitter:card" content="summary_large_image">
</head>

<body class="floating nav-fixed">

<div id="quarto-search-results"></div>
  <header id="quarto-header" class="headroom fixed-top">
    <nav class="navbar navbar-expand-lg navbar-dark ">
      <div class="navbar-container container-fluid">
      <div class="navbar-brand-container">
    <a class="navbar-brand" href="../../index.html">
    <span class="navbar-title">Un garçon pas comme les autres (Bayes)</span>
    </a>
  </div>
          <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbarCollapse" aria-controls="navbarCollapse" aria-expanded="false" aria-label="Toggle navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">
  <span class="navbar-toggler-icon"></span>
</button>
          <div class="collapse navbar-collapse" id="navbarCollapse">
            <ul class="navbar-nav navbar-nav-scroll ms-auto">
  <li class="nav-item">
    <a class="nav-link" href="../../about.html">About this blog</a>
  </li>  
  <li class="nav-item compact">
    <a class="nav-link" href="https://twitter.com/dan_p_simpson"><i class="bi bi-twitter" role="img" aria-label="twitter">
</i> 
 </a>
  </li>  
  <li class="nav-item compact">
    <a class="nav-link" href="https://github.com/dpsimpson"><i class="bi bi-github" role="img" aria-label="github">
</i> 
 </a>
  </li>  
  <li class="nav-item compact">
    <a class="nav-link" href="https://dansblog.netlify.app"><i class="bi bi-person-circle" role="img" aria-label="website">
</i> 
 </a>
  </li>  
</ul>
              <div id="quarto-search" class="" title="Search"></div>
          </div> <!-- /navcollapse -->
      </div> <!-- /container-fluid -->
    </nav>
</header>
<!-- content -->
<header id="title-block-header" class="quarto-title-block default toc-left page-columns page-full">
  <div class="quarto-title-banner page-columns page-full">
    <div class="quarto-title column-body">
      <h1 class="title">Sparse matrices 6: To catch a derivative, first you’ve got to think like a derivative</h1>
                  <div>
        <div class="description">
          <p>Open up the kennels, Kenneth. Mamma’s coming home tonight.</p>
        </div>
      </div>
                          <div class="quarto-categories">
                <div class="quarto-category">JAX</div>
                <div class="quarto-category">Sparse matrices</div>
                <div class="quarto-category">Autodiff</div>
              </div>
                  </div>
  </div>
    
  
  <div class="quarto-title-meta">

      <div>
      <div class="quarto-title-meta-heading">Author</div>
      <div class="quarto-title-meta-contents">
               <p>Dan Simpson </p>
            </div>
    </div>
      
      <div>
      <div class="quarto-title-meta-heading">Published</div>
      <div class="quarto-title-meta-contents">
        <p class="date">May 30, 2022</p>
      </div>
    </div>
      
    </div>
    
  
  </header><div id="quarto-content" class="quarto-container page-columns page-rows-contents page-layout-article page-navbar">
<!-- sidebar -->
  <nav id="quarto-sidebar" class="sidebar collapse sidebar-navigation floating overflow-auto">
    <nav id="TOC" role="doc-toc" class="toc-active">
    <h2 id="toc-title">Table of contents</h2>
   
  <ul>
  <li><a href="#she-is-beauty-and-she-is-grace.-she-is-queen-of-50-states.-she-is-elegance-and-taste.-she-is-miss-autodiff" id="toc-she-is-beauty-and-she-is-grace.-she-is-queen-of-50-states.-she-is-elegance-and-taste.-she-is-miss-autodiff" class="nav-link active" data-scroll-target="#she-is-beauty-and-she-is-grace.-she-is-queen-of-50-states.-she-is-elegance-and-taste.-she-is-miss-autodiff">She is beauty and she is grace. She is queen of 50 states. She is elegance and taste. She is miss autodiff</a></li>
  <li><a href="#jvp-number-one-the-linear-solve." id="toc-jvp-number-one-the-linear-solve." class="nav-link" data-scroll-target="#jvp-number-one-the-linear-solve.">JVP number one: The linear solve.</a></li>
  <li><a href="#primitive-two-the-triangular-solve" id="toc-primitive-two-the-triangular-solve" class="nav-link" data-scroll-target="#primitive-two-the-triangular-solve">Primitive two: The triangular solve</a>
  <ul class="collapse">
  <li><a href="#the-jacobian-vector-product" id="toc-the-jacobian-vector-product" class="nav-link" data-scroll-target="#the-jacobian-vector-product">The Jacobian-vector product</a></li>
  <li><a href="#transposition" id="toc-transposition" class="nav-link" data-scroll-target="#transposition">Transposition</a></li>
  <li><a href="#testing-the-numerical-implementation-of-the-jacobian-vector-product" id="toc-testing-the-numerical-implementation-of-the-jacobian-vector-product" class="nav-link" data-scroll-target="#testing-the-numerical-implementation-of-the-jacobian-vector-product">Testing the numerical implementation of the Jacobian-vector product</a></li>
  <li><a href="#checking-on-the-plumbing" id="toc-checking-on-the-plumbing" class="nav-link" data-scroll-target="#checking-on-the-plumbing">Checking on the plumbing</a></li>
  </ul></li>
  <li><a href="#primitive-one-the-general-a-1b" id="toc-primitive-one-the-general-a-1b" class="nav-link" data-scroll-target="#primitive-one-the-general-a-1b">Primitive one: The general <span class="math inline">\(A^{-1}b\)</span></a>
  <ul class="collapse">
  <li><a href="#why-do-we-need-a-new-pattern-for-this-very-very-similar-problem" id="toc-why-do-we-need-a-new-pattern-for-this-very-very-similar-problem" class="nav-link" data-scroll-target="#why-do-we-need-a-new-pattern-for-this-very-very-similar-problem">Why do we need a new pattern for this very very similar problem?</a></li>
  <li><a href="#a-different-solution" id="toc-a-different-solution" class="nav-link" data-scroll-target="#a-different-solution">A different solution</a></li>
  <li><a href="#does-it-work" id="toc-does-it-work" class="nav-link" data-scroll-target="#does-it-work">Does it work?</a></li>
  <li><a href="#why-is-this-better-than-just-differentiating-through-the-cholesky-factorisation" id="toc-why-is-this-better-than-just-differentiating-through-the-cholesky-factorisation" class="nav-link" data-scroll-target="#why-is-this-better-than-just-differentiating-through-the-cholesky-factorisation">Why is this better than just differentiating through the Cholesky factorisation?</a></li>
  </ul></li>
  <li><a href="#primitive-three-the-dreaded-log-determinant" id="toc-primitive-three-the-dreaded-log-determinant" class="nav-link" data-scroll-target="#primitive-three-the-dreaded-log-determinant">Primitive three: The dreaded log determinant</a>
  <ul class="collapse">
  <li><a href="#computing-the-partial-inverse" id="toc-computing-the-partial-inverse" class="nav-link" data-scroll-target="#computing-the-partial-inverse">Computing the partial inverse</a></li>
  <li><a href="#putting-the-log-determinant-together" id="toc-putting-the-log-determinant-together" class="nav-link" data-scroll-target="#putting-the-log-determinant-together">Putting the log-determinant together</a></li>
  </ul></li>
  <li><a href="#wrapping-up" id="toc-wrapping-up" class="nav-link" data-scroll-target="#wrapping-up">Wrapping up</a></li>
  </ul>
</nav>
</nav>
<!-- margin-sidebar -->
    <div id="quarto-margin-sidebar" class="sidebar margin-sidebar">
    </div>
<!-- main -->
<main class="content quarto-banner-title-block" id="quarto-document-content">




<p>Welcome to part six!!! of our ongoing series on making sparse linear algebra differentiable in JAX with the eventual hope to be able to do some <a href="https://dansblog.netlify.app/posts/2022-03-22-a-linear-mixed-effects-model/">cool statistical shit</a>. We are <em>nowhere near done</em>.</p>
<p><a href="https://dansblog.netlify.app/posts/2022-05-14-sparse4-some-primatives/">Last time</a>, we looked at making JAX primitives. We built four of them. Today we are going to implement the corresponding differentiation rules! For three<a href="#fn1" class="footnote-ref" id="fnref1" role="doc-noteref"><sup>1</sup></a> of them.</p>
<p>So strap yourselves in. This is gonna be detailed.</p>
<p>If you’re interested in the code<a href="#fn2" class="footnote-ref" id="fnref2" role="doc-noteref"><sup>2</sup></a>, the git repo for this post is linked at the bottom and in there you will find a folder with the python code in a python file.</p>
<section id="she-is-beauty-and-she-is-grace.-she-is-queen-of-50-states.-she-is-elegance-and-taste.-she-is-miss-autodiff" class="level2">
<h2 class="anchored" data-anchor-id="she-is-beauty-and-she-is-grace.-she-is-queen-of-50-states.-she-is-elegance-and-taste.-she-is-miss-autodiff">She is beauty and she is grace. She is queen of 50 states. She is elegance and taste. She is miss autodiff</h2>
<p>Derivatives are computed in JAX through the glory and power of automatic differentiation. If you came to this blog hoping for a great description of how autodiff works, I am terribly sorry but I absolutely do not have time for that. Might I suggest google? Or maybe flick through <a href="https://arxiv.org/abs/1811.05031">this survey by Charles Margossian.</a>.</p>
<p>The most important thing to remember about algorithmic differentiation is that it is <em>not</em> symbolic differentiation. That is, it does not create the functional form of the derivative of the function and compute that. Instead, it is a system for cleverly composing derivatives in each bit of the program to compute the <em>value</em> of the derivative of the function.</p>
<p>But for that to work, we need to implement those clever little mini-derivatives. In particular, every function <span class="math inline">\(f(\cdot): \mathbb{R}^n \rightarrow \mathbb{R}^m\)</span> needs to have a function to compute the corresponding Jacobian-vector product <span class="math display">\[
(\theta, v) \rightarrow J(\theta) v,
\]</span> where the <span class="math inline">\(n \times m\)</span> matrix <span class="math inline">\(J(\theta)\)</span> has entries <span class="math display">\[
J(\theta)_{ij} = \frac{\partial f_j }{\partial \theta_j}.
\]</span></p>
<p>Ok. So let’s get onto this. We are going to derive and implement some Jacobian-vector products. And all of the assorted accoutrement. And by crikey. We are going to do it all in a JAX-traceable way.</p>
</section>
<section id="jvp-number-one-the-linear-solve." class="level2">
<h2 class="anchored" data-anchor-id="jvp-number-one-the-linear-solve.">JVP number one: The linear solve.</h2>
<p>The first of the derivatives that we need to work out is the derivative of a linear solve <span class="math inline">\(A^{-1}b\)</span>. Now, intrepid readers, the obvious thing to do is look the damn derivative up. You get exactly no hero points for computing it yourself.</p>
<p>But I’m not you, I’m a dickhead.</p>
<p>So I’m going to derive it. I could pretend there are reasons<a href="#fn3" class="footnote-ref" id="fnref3" role="doc-noteref"><sup>3</sup></a>, but that would just be lying. I’m doing it because I can.</p>
<p>Beyond the obvious fun of working out a matrix derivative from first principles, this is fun because we have <em>two</em> arguments instead of just one. Double the fun.</p>
<p>And we really should make sure the function is differentiated with respect to every reasonable argument. Why? Because if you write code other people might use, you don’t get to control how they use it (or what they will email you about). So it’s always good practice to limit surprises (like a function not being differentiable wrt some argument) to cases<a href="#fn4" class="footnote-ref" id="fnref4" role="doc-noteref"><sup>4</sup></a> where it absolutely necessary. This reduces the emails.</p>
<p>To that end, let’s take an arbitrary SPD matrix <span class="math inline">\(A\)</span> with a <em>fixed</em> sparsity pattern. Let’s take another symmetric matrix <span class="math inline">\(\Delta\)</span> with <em>the same sparsity pattern</em> and assume that <span class="math inline">\(\Delta\)</span> is small enough<a href="#fn5" class="footnote-ref" id="fnref5" role="doc-noteref"><sup>5</sup></a> that <span class="math inline">\(A + \Delta\)</span> is still symmetric positive definite. We also need a vector <span class="math inline">\(\delta\)</span> with a small <span class="math inline">\(\|\delta\|\)</span>.</p>
<p>Now let’s get algebraing. <span class="math display">\[\begin{align*}
f(A + \Delta, b + \delta) &amp;= (A+\Delta)^{-1}(b + \delta) \\
&amp;= (I + A^{-1}\Delta)^{-1}A^{-1}(b + \delta) \\
&amp;= (I - A^{-1}\Delta + o(\|\Delta\|))A^{-1}(b + \delta) \\
&amp;= A^{-1}b + A^{-1}(\delta - \Delta A^{-1}b ) + o(\|\Delta\| + \|\delta\|)
\end{align*}\]</span></p>
<p>Easy<a href="#fn6" class="footnote-ref" id="fnref6" role="doc-noteref"><sup>6</sup></a> as.</p>
<p>We’ve actually calculated the derivative now, but it’s a little more work to recognise it.</p>
<p>To do that, we need to remember the practical definition of the Jacobian of a function <span class="math inline">\(f(x)\)</span> that takes an <span class="math inline">\(n\)</span>-dimensional input and produces an <span class="math inline">\(m\)</span>-dimensional output. It is the <span class="math inline">\(n \times m\)</span> matrix <span class="math inline">\(J_f(x)\)</span> such that <span class="math display">\[
f(x + \delta)  = f(x) + J_f(x)\delta + o(\|\delta\|).
\]</span></p>
<p>The formulas further simplify if we write <span class="math inline">\(c = A^{-1}b\)</span>. Then, if we want the Jacobian-vector product for the first argument, it is <span class="math display">\[
-A^{-1}\Delta c,
\]</span> while the Jacobian-vector product for the second argument is <span class="math display">\[
A^{-1}\delta.
\]</span></p>
<p>The only wrinkle in doing this is we need to remember that we are only storing the lower triangle of <span class="math inline">\(A\)</span>. Because we need to represent <span class="math inline">\(\Delta\)</span> the same way, it is represented as a vector <code>Delta_x</code> that contains only the lower triangle of <span class="math inline">\(\Delta\)</span>. So we need to make sure we remember to form the <em>whole</em> matrix before we do the matrix-vector product <span class="math inline">\(\Delta c\)</span>!</p>
<p>But otherwise, the implementation is going to be pretty straightforward. The Jacobian-vector product costs one additional linear solve (beyond the one needed to compute the value <span class="math inline">\(c = A^{-1}b\)</span>).</p>
<p>In the language of JAX (and autodiff in general), we refer to <span class="math inline">\(\Delta\)</span> and <span class="math inline">\(\delta\)</span> as <em>tangent vectors</em>. In search of a moderately coherent naming convention, we are going to refer to the tangent associated with the variable <code>x</code> as <code>xt</code>.</p>
<p>So let’s implement this. Remember: it needs<a href="#fn7" class="footnote-ref" id="fnref7" role="doc-noteref"><sup>7</sup></a> to be JAX traceable.</p>
</section>
<section id="primitive-two-the-triangular-solve" class="level2">
<h2 class="anchored" data-anchor-id="primitive-two-the-triangular-solve">Primitive two: The triangular solve</h2>
<p>For some sense of continuity, we are going to keep the naming of the primitives from the last blog post, but we are <em>not</em> going to attack them in the same order. Why not? Because we work in order of complexity.</p>
<p>So first off we are going to do the triangular solve. As I have yet to package up the code (I promise, that will happen next<a href="#fn8" class="footnote-ref" id="fnref8" role="doc-noteref"><sup>8</sup></a>), I’m just putting it here under the fold.</p>
<details>
<summary>
The primal implementation
</summary>
<div class="cell" data-execution_count="1">
<div class="sourceCode cell-code" id="cb1"><pre class="sourceCode numberSource python number-lines code-with-copy"><code class="sourceCode python"><span id="cb1-1"><a href="#cb1-1"></a><span class="im">from</span> scipy <span class="im">import</span> sparse</span>
<span id="cb1-2"><a href="#cb1-2"></a><span class="im">import</span> numpy <span class="im">as</span> np</span>
<span id="cb1-3"><a href="#cb1-3"></a><span class="im">from</span> jax <span class="im">import</span> numpy <span class="im">as</span> jnp</span>
<span id="cb1-4"><a href="#cb1-4"></a><span class="im">from</span> jax <span class="im">import</span> core</span>
<span id="cb1-5"><a href="#cb1-5"></a><span class="im">from</span> jax._src <span class="im">import</span> abstract_arrays</span>
<span id="cb1-6"><a href="#cb1-6"></a><span class="im">from</span> jax <span class="im">import</span> core</span>
<span id="cb1-7"><a href="#cb1-7"></a></span>
<span id="cb1-8"><a href="#cb1-8"></a>sparse_triangular_solve_p <span class="op">=</span> core.Primitive(<span class="st">"sparse_triangular_solve"</span>)</span>
<span id="cb1-9"><a href="#cb1-9"></a></span>
<span id="cb1-10"><a href="#cb1-10"></a><span class="kw">def</span> sparse_triangular_solve(L_indices, L_indptr, L_x, b, <span class="op">*</span>, transpose: <span class="bu">bool</span> <span class="op">=</span> <span class="va">False</span>):</span>
<span id="cb1-11"><a href="#cb1-11"></a>  <span class="co">"""A JAX traceable sparse  triangular solve"""</span></span>
<span id="cb1-12"><a href="#cb1-12"></a>  <span class="cf">return</span> sparse_triangular_solve_p.bind(L_indices, L_indptr, L_x, b, transpose <span class="op">=</span> transpose)</span>
<span id="cb1-13"><a href="#cb1-13"></a></span>
<span id="cb1-14"><a href="#cb1-14"></a><span class="at">@sparse_triangular_solve_p.def_impl</span></span>
<span id="cb1-15"><a href="#cb1-15"></a><span class="kw">def</span> sparse_triangular_solve_impl(L_indices, L_indptr, L_x, b, <span class="op">*</span>, transpose <span class="op">=</span> <span class="va">False</span>):</span>
<span id="cb1-16"><a href="#cb1-16"></a>  <span class="co">"""The implementation of the sparse triangular solve. This is not JAX traceable."""</span></span>
<span id="cb1-17"><a href="#cb1-17"></a>  L <span class="op">=</span> sparse.csc_array((L_x, L_indices, L_indptr)) </span>
<span id="cb1-18"><a href="#cb1-18"></a>  </span>
<span id="cb1-19"><a href="#cb1-19"></a>  <span class="cf">assert</span> L.shape[<span class="dv">0</span>] <span class="op">==</span> L.shape[<span class="dv">1</span>]</span>
<span id="cb1-20"><a href="#cb1-20"></a>  <span class="cf">assert</span> L.shape[<span class="dv">0</span>] <span class="op">==</span> b.shape[<span class="dv">0</span>]</span>
<span id="cb1-21"><a href="#cb1-21"></a>  </span>
<span id="cb1-22"><a href="#cb1-22"></a>  <span class="cf">if</span> transpose:</span>
<span id="cb1-23"><a href="#cb1-23"></a>    <span class="cf">return</span> sparse.linalg.spsolve_triangular(L.T, b, lower <span class="op">=</span> <span class="va">False</span>)</span>
<span id="cb1-24"><a href="#cb1-24"></a>  <span class="cf">else</span>:</span>
<span id="cb1-25"><a href="#cb1-25"></a>    <span class="cf">return</span> sparse.linalg.spsolve_triangular(L.tocsr(), b, lower <span class="op">=</span> <span class="va">True</span>)</span>
<span id="cb1-26"><a href="#cb1-26"></a></span>
<span id="cb1-27"><a href="#cb1-27"></a><span class="at">@sparse_triangular_solve_p.def_abstract_eval</span></span>
<span id="cb1-28"><a href="#cb1-28"></a><span class="kw">def</span> sparse_triangular_solve_abstract_eval(L_indices, L_indptr, L_x, b, <span class="op">*</span>, transpose <span class="op">=</span> <span class="va">False</span>):</span>
<span id="cb1-29"><a href="#cb1-29"></a>  <span class="cf">assert</span> L_indices.shape[<span class="dv">0</span>] <span class="op">==</span> L_x.shape[<span class="dv">0</span>]</span>
<span id="cb1-30"><a href="#cb1-30"></a>  <span class="cf">assert</span> b.shape[<span class="dv">0</span>] <span class="op">==</span> L_indptr.shape[<span class="dv">0</span>] <span class="op">-</span> <span class="dv">1</span></span>
<span id="cb1-31"><a href="#cb1-31"></a>  <span class="cf">return</span> abstract_arrays.ShapedArray(b.shape, b.dtype)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
</details>
<section id="the-jacobian-vector-product" class="level3">
<h3 class="anchored" data-anchor-id="the-jacobian-vector-product">The Jacobian-vector product</h3>
<div class="cell" data-execution_count="2">
<div class="sourceCode cell-code" id="cb2"><pre class="sourceCode numberSource python number-lines code-with-copy"><code class="sourceCode python"><span id="cb2-1"><a href="#cb2-1"></a><span class="im">from</span> jax._src <span class="im">import</span> ad_util</span>
<span id="cb2-2"><a href="#cb2-2"></a><span class="im">from</span> jax.interpreters <span class="im">import</span> ad</span>
<span id="cb2-3"><a href="#cb2-3"></a><span class="im">from</span> jax <span class="im">import</span> lax</span>
<span id="cb2-4"><a href="#cb2-4"></a><span class="im">from</span> jax.experimental <span class="im">import</span> sparse <span class="im">as</span> jsparse</span>
<span id="cb2-5"><a href="#cb2-5"></a></span>
<span id="cb2-6"><a href="#cb2-6"></a><span class="kw">def</span> sparse_triangular_solve_value_and_jvp(arg_values, arg_tangent, <span class="op">*</span>, transpose):</span>
<span id="cb2-7"><a href="#cb2-7"></a>  <span class="co">"""</span></span>
<span id="cb2-8"><a href="#cb2-8"></a><span class="co">  A jax-traceable jacobian-vector product. In order to make it traceable, </span></span>
<span id="cb2-9"><a href="#cb2-9"></a><span class="co">  we use the experimental sparse CSC matrix in JAX.</span></span>
<span id="cb2-10"><a href="#cb2-10"></a><span class="co">  </span></span>
<span id="cb2-11"><a href="#cb2-11"></a><span class="co">  Input:</span></span>
<span id="cb2-12"><a href="#cb2-12"></a><span class="co">    arg_values:   A tuple of (L_indices, L_indptr, L_x, b) that describe</span></span>
<span id="cb2-13"><a href="#cb2-13"></a><span class="co">                  the triangular matrix L and the rhs vector b</span></span>
<span id="cb2-14"><a href="#cb2-14"></a><span class="co">    arg_tangent:  A tuple of tangent values (same lenght as arg_values).</span></span>
<span id="cb2-15"><a href="#cb2-15"></a><span class="co">                  The first two values are nonsense - we don't differentiate</span></span>
<span id="cb2-16"><a href="#cb2-16"></a><span class="co">                  wrt integers!</span></span>
<span id="cb2-17"><a href="#cb2-17"></a><span class="co">    transpose:    (boolean) If true, solve L^Tx = b. Otherwise solve Lx = b.</span></span>
<span id="cb2-18"><a href="#cb2-18"></a><span class="co">  Output:         A tuple containing the maybe_transpose(L)^{-1}b and the corresponding</span></span>
<span id="cb2-19"><a href="#cb2-19"></a><span class="co">                  Jacobian-vector product.</span></span>
<span id="cb2-20"><a href="#cb2-20"></a><span class="co">  """</span></span>
<span id="cb2-21"><a href="#cb2-21"></a>  L_indices, L_indptr, L_x, b <span class="op">=</span> arg_values</span>
<span id="cb2-22"><a href="#cb2-22"></a>  _, _, L_xt, bt <span class="op">=</span> arg_tangent</span>
<span id="cb2-23"><a href="#cb2-23"></a>  value <span class="op">=</span> sparse_triangular_solve(L_indices, L_indptr, L_x, b, transpose<span class="op">=</span>transpose)</span>
<span id="cb2-24"><a href="#cb2-24"></a>  <span class="cf">if</span> <span class="bu">type</span>(bt) <span class="kw">is</span> ad.Zero <span class="kw">and</span> <span class="bu">type</span>(L_xt) <span class="kw">is</span> ad.Zero:</span>
<span id="cb2-25"><a href="#cb2-25"></a>    <span class="co"># I legit do not think this ever happens. But I'm honestly not sure.</span></span>
<span id="cb2-26"><a href="#cb2-26"></a>    <span class="bu">print</span>(<span class="st">"I have arrived!"</span>)</span>
<span id="cb2-27"><a href="#cb2-27"></a>    <span class="cf">return</span> value, lax.zeros_like_array(value) </span>
<span id="cb2-28"><a href="#cb2-28"></a>  </span>
<span id="cb2-29"><a href="#cb2-29"></a>  <span class="cf">if</span> <span class="bu">type</span>(L_xt) <span class="kw">is</span> <span class="kw">not</span> ad.Zero:</span>
<span id="cb2-30"><a href="#cb2-30"></a>    <span class="co"># L is variable</span></span>
<span id="cb2-31"><a href="#cb2-31"></a>    <span class="cf">if</span> transpose:</span>
<span id="cb2-32"><a href="#cb2-32"></a>      Delta <span class="op">=</span> jsparse.CSC((L_xt, L_indices, L_indptr), shape <span class="op">=</span> (b.shape[<span class="dv">0</span>], b.shape[<span class="dv">0</span>])).transpose()</span>
<span id="cb2-33"><a href="#cb2-33"></a>    <span class="cf">else</span>:</span>
<span id="cb2-34"><a href="#cb2-34"></a>      Delta <span class="op">=</span> jsparse.CSC((L_xt, L_indices, L_indptr), shape <span class="op">=</span> (b.shape[<span class="dv">0</span>], b.shape[<span class="dv">0</span>]))</span>
<span id="cb2-35"><a href="#cb2-35"></a></span>
<span id="cb2-36"><a href="#cb2-36"></a>    jvp_Lx <span class="op">=</span> sparse_triangular_solve(L_indices, L_indptr, L_x, Delta <span class="op">@</span> value, transpose <span class="op">=</span> transpose) </span>
<span id="cb2-37"><a href="#cb2-37"></a>  <span class="cf">else</span>:</span>
<span id="cb2-38"><a href="#cb2-38"></a>    jvp_Lx <span class="op">=</span> lax.zeros_like_array(value) </span>
<span id="cb2-39"><a href="#cb2-39"></a></span>
<span id="cb2-40"><a href="#cb2-40"></a>  <span class="cf">if</span> <span class="bu">type</span>(bt) <span class="kw">is</span> <span class="kw">not</span> ad.Zero:</span>
<span id="cb2-41"><a href="#cb2-41"></a>    <span class="co"># b is variable</span></span>
<span id="cb2-42"><a href="#cb2-42"></a>    jvp_b <span class="op">=</span> sparse_triangular_solve(L_indices, L_indptr, L_x, bt, transpose <span class="op">=</span> transpose)</span>
<span id="cb2-43"><a href="#cb2-43"></a>  <span class="cf">else</span>:</span>
<span id="cb2-44"><a href="#cb2-44"></a>    jvp_b <span class="op">=</span> lax.zeros_like_array(value)</span>
<span id="cb2-45"><a href="#cb2-45"></a></span>
<span id="cb2-46"><a href="#cb2-46"></a>  <span class="cf">return</span> value, jvp_b <span class="op">-</span> jvp_Lx</span>
<span id="cb2-47"><a href="#cb2-47"></a></span>
<span id="cb2-48"><a href="#cb2-48"></a>ad.primitive_jvps[sparse_triangular_solve_p] <span class="op">=</span> sparse_triangular_solve_value_and_jvp</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>Before we see if this works, let’s first have talk about the structure of the function I just wrote. Generally speaking, we want a function that takes in the primals and tangents at tuples and then returns the value and the<a href="#fn9" class="footnote-ref" id="fnref9" role="doc-noteref"><sup>9</sup></a> Jacobian-vector product.</p>
<p>The main thing you will notice in the code is that there is <em>a lot</em> of checking for <code>ad.Zero</code>. This is a special type defined in JAX that is, essentially, telling the autodiff system that we are not differentiating wrt that variable. This is different to a tangent that just happens to be numerically equal to zero. Any code for a Jacobian-vector product needs to handle this special value.</p>
<p>As we have two arguments, we have 3 interesting options:</p>
<ol type="1">
<li><p>Both <code>L_xt</code> and <code>bt</code> are <code>ad.Zero</code>: This means the function is a constant and the derivative is zero. I am fairly certain that we do not need to manually handle this case, but because I don’t know and I do not like surprises, it’s in there.</p></li>
<li><p><code>L_xt</code> is <em>not</em> <code>ad.Zero</code>: This means that we need to differentiate wrt the matrix. In this case we need to compute <span class="math inline">\(\Delta c\)</span> or <span class="math inline">\(\Delta^T c\)</span>, depending on the <code>transpose</code> argument. In order to do this, I used the <code>jax.experimental.sparse.CSC</code> class, which has some very limited sparse matrix support (basically matrix-vector products). This is <em>extremely</em> convenient because it means I don’t need to write the matrix-vector product myself!</p></li>
<li><p><code>bt</code> is <em>not</em> <code>ad.Zero</code>: This means that we need to differentiate wrt the rhs vector. This part of the formula is pretty straightforward: just an application of the primal.</p></li>
</ol>
<p>In the case that either <code>L_xt</code> or <code>bt</code> are <code>ad.Zero</code>, we simply set the corresponding contribution to the jvp to zero.</p>
<p>It’s worth saying that you can bypass all of this <code>ad.Zero</code> logic by writing separate functions for the JVP contribution from each input and then chaining them together using<a href="#fn10" class="footnote-ref" id="fnref10" role="doc-noteref"><sup>10</sup></a> <code>ad.defjvp2()</code> to <a href="https://github.com/google/jax/blob/41417d70c03b6089c93a42325111a0d8348c2fa3/jax/_src/lax/linalg.py#L791">chain them together</a>. This is what the <code>lax.linalg.triangular_solve()</code> implementation does.</p>
<p>So why didn’t I do this? I avoided this because in the other primitives I have to implement, there are expensive computations (like Cholesky factorisations) that I want to share between the primal and the various tangent calculations. The <code>ad.defjvp</code> frameworks don’t allow for that. So I decided not to demonstrate/learn two separate patterns.</p>
</section>
<section id="transposition" class="level3">
<h3 class="anchored" data-anchor-id="transposition">Transposition</h3>
<p>Now I’ve never actively wanted a Jacobian-vector product in my whole life. I’m sorry. I want a gradient. Gimme a gradient. I am the Veruca Salt of gradients.</p>
<p>In may autodiff systems, if you want<a href="#fn11" class="footnote-ref" id="fnref11" role="doc-noteref"><sup>11</sup></a> a gradient, you need to implement vector-Jacobian products<a href="#fn12" class="footnote-ref" id="fnref12" role="doc-noteref"><sup>12</sup></a> explicitly.</p>
<p>One of the odder little innovations in JAX is that instead of forcing you to implement this as well<a href="#fn13" class="footnote-ref" id="fnref13" role="doc-noteref"><sup>13</sup></a>, you only need to implement half of it.</p>
<p>You see, some clever analysis that, as far as I far as I can tell<a href="#fn14" class="footnote-ref" id="fnref14" role="doc-noteref"><sup>14</sup></a>, is detailed in <a href="https://arxiv.org/abs/2204.10923">this paper</a> shows that you only need to form explicit vector-Jacobian products for the structurally linear arguments of the function.</p>
<p>In JAX (and maybe elsewhere), this is known as a <em>transposition rule</em>. The combination of a transopition rule and a JAX-traceable Jacobian-vector product is enough for JAX to compute all of the directional derivatives and gradients we could ever hope for.</p>
<p>As far as I understand, it is all about functions that are <em>structurally linear</em> in some arguments. For instance, if <span class="math inline">\(A(x)\)</span> is a matrix-valued function and <span class="math inline">\(x\)</span> and <span class="math inline">\(y\)</span> are vectors, then the function <span class="math display">\[
f(x, y) = A(x)y + g(x)
\]</span> is structurally linear in <span class="math inline">\(y\)</span> in the sense that for every fixed value of <span class="math inline">\(x\)</span>, the function <span class="math display">\[
f_x(y) = A(x) y + g(x)
\]</span> is linear in <span class="math inline">\(y\)</span>. The resulting transpositon rule is then</p>
<div class="cell" data-execution_count="3">
<div class="sourceCode cell-code" id="cb3"><pre class="sourceCode numberSource python number-lines code-with-copy"><code class="sourceCode python"><span id="cb3-1"><a href="#cb3-1"></a><span class="kw">def</span> f_transpose(x, y):</span>
<span id="cb3-2"><a href="#cb3-2"></a>  Ax <span class="op">=</span> A(x)</span>
<span id="cb3-3"><a href="#cb3-3"></a>  gx <span class="op">=</span> g(x)</span>
<span id="cb3-4"><a href="#cb3-4"></a>  <span class="cf">return</span> (<span class="va">None</span>, Ax.T <span class="op">@</span> y <span class="op">+</span> gx)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>The first element of the return is <code>None</code> because <span class="math inline">\(f(x,y)\)</span> is not<a href="#fn15" class="footnote-ref" id="fnref15" role="doc-noteref"><sup>15</sup></a> structurally linear in <span class="math inline">\(x\)</span> so there is nothing to transpose. The second element simply takes the matrix in the linear function and transposes it.</p>
<p>If you know anything about autodiff, you’ll think “this doesn’t <em>feel</em> like enough” and it’s not. JAX deals with the non-linear part of <span class="math inline">\(f(x,y)\)</span> by tracing the evaluation tree for its Jacobian-vector product and … manipulating<a href="#fn16" class="footnote-ref" id="fnref16" role="doc-noteref"><sup>16</sup></a> it.</p>
<p>We already built the abstract evaluation function last time around, so the tracing part can be done. All we need is the transposition rule.</p>
<p>The linear solve <span class="math inline">\(f(A, b) = A^{-1}b\)</span> is non-linear in the first argument but linear in the second argument. So we only need to implement <span class="math display">\[
J^T_b(A,b)w = A^{-T}w,
\]</span> where the subscript <span class="math inline">\(b\)</span> indicates we’re only computing the Jacobian wrt <span class="math inline">\(b\)</span>.</p>
<p>Initially, I struggled to work out what needed to be implemented here. The thing that clarified the process for me was looking at JAX’s <a href="https://github.com/google/jax/blob/41417d70c03b6089c93a42325111a0d8348c2fa3/jax/_src/lax/linalg.py#L747">internal implementation</a> of the Jacobian-vector product for a dense matrix. From there, I understood what this had to look like for a vector-valued function and this is the result.</p>
<div class="cell" data-execution_count="4">
<div class="sourceCode cell-code" id="cb4"><pre class="sourceCode numberSource python number-lines code-with-copy"><code class="sourceCode python"><span id="cb4-1"><a href="#cb4-1"></a><span class="kw">def</span> sparse_triangular_solve_transpose_rule(cotangent, L_indices, L_indptr, L_x, b, <span class="op">*</span>, transpose):</span>
<span id="cb4-2"><a href="#cb4-2"></a>  <span class="co">"""</span></span>
<span id="cb4-3"><a href="#cb4-3"></a><span class="co">  Transposition rule for the triangular solve. </span></span>
<span id="cb4-4"><a href="#cb4-4"></a><span class="co">  Translated from here https://github.com/google/jax/blob/41417d70c03b6089c93a42325111a0d8348c2fa3/jax/_src/lax/linalg.py#L747.</span></span>
<span id="cb4-5"><a href="#cb4-5"></a><span class="co">  Inputs:</span></span>
<span id="cb4-6"><a href="#cb4-6"></a><span class="co">    cotangent: Output cotangent (aka adjoint). (produced by JAX)</span></span>
<span id="cb4-7"><a href="#cb4-7"></a><span class="co">    L_indices, L_indptr, L_x: Represenation of sparse matrix. L_x should be concrete</span></span>
<span id="cb4-8"><a href="#cb4-8"></a><span class="co">    b: The right hand side. Must be an jax.interpreters.ad.UndefinedPrimal</span></span>
<span id="cb4-9"><a href="#cb4-9"></a><span class="co">    transpose: (boolean) True: solve $L^Tx = b$. False: Solve $Lx = b$.</span></span>
<span id="cb4-10"><a href="#cb4-10"></a><span class="co">  Output:</span></span>
<span id="cb4-11"><a href="#cb4-11"></a><span class="co">    A 4-tuple with the adjoints (None, None, None, b_adjoint)</span></span>
<span id="cb4-12"><a href="#cb4-12"></a><span class="co">  """</span></span>
<span id="cb4-13"><a href="#cb4-13"></a>  <span class="cf">assert</span> <span class="kw">not</span> ad.is_undefined_primal(L_x) <span class="kw">and</span> ad.is_undefined_primal(b)</span>
<span id="cb4-14"><a href="#cb4-14"></a>  <span class="cf">if</span> <span class="bu">type</span>(cotangent) <span class="kw">is</span> ad_util.Zero:</span>
<span id="cb4-15"><a href="#cb4-15"></a>    cot_b <span class="op">=</span> ad_util.Zero(b.aval)</span>
<span id="cb4-16"><a href="#cb4-16"></a>  <span class="cf">else</span>:</span>
<span id="cb4-17"><a href="#cb4-17"></a>    cot_b <span class="op">=</span> sparse_triangular_solve(L_indices, L_indptr, L_x, cotangent, transpose <span class="op">=</span> <span class="kw">not</span> transpose)</span>
<span id="cb4-18"><a href="#cb4-18"></a>  <span class="cf">return</span> <span class="va">None</span>, <span class="va">None</span>, <span class="va">None</span>, cot_b</span>
<span id="cb4-19"><a href="#cb4-19"></a></span>
<span id="cb4-20"><a href="#cb4-20"></a>ad.primitive_transposes[sparse_triangular_solve_p] <span class="op">=</span> sparse_triangular_solve_transpose_rule</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>If this doesn’t make a lot of sense to you, that’s because it’s confusing.</p>
<p>One way to think of it is in terms of the more ordinary notation. Mike Giles has <a href="https://people.maths.ox.ac.uk/gilesm/files/NA-08-01.pdf">a classic paper</a> that covers these results for basic linear algebra. The idea is to imagine that, as part of your larger program, you need to compute <span class="math inline">\(c = A^{-1}b\)</span>.</p>
<p>Forward-mode autodiff computes the <em>sensitivity</em> of <span class="math inline">\(c\)</span>, usually denoted <span class="math inline">\(\dot c\)</span> from the sensitivies <span class="math inline">\(\dot A\)</span> and <span class="math inline">\(\dot b\)</span>. These have already been computed. The formula in Giles is <span class="math display">\[
\dot c = A^{-1}(\dot b - \dot A c).
\]</span> The canny reader will recognise this as exactly<a href="#fn17" class="footnote-ref" id="fnref17" role="doc-noteref"><sup>17</sup></a> the formula for the Jacobian-vector product.</p>
<p>So what does reverse-mode autodiff do? Well it moves through the program in the other direction. So instead of starting with the sensitivities <span class="math inline">\(\dot A\)</span> and <span class="math inline">\(\dot b\)</span> already computed, we instead start with the<a href="#fn18" class="footnote-ref" id="fnref18" role="doc-noteref"><sup>18</sup></a> <em>adjoint sensitivity</em> <span class="math inline">\(\bar c\)</span>. Our aim is to compute <span class="math inline">\(\bar A\)</span> and <span class="math inline">\(\bar b\)</span> from <span class="math inline">\(\bar c\)</span>.</p>
<p>The details of how to do this are<a href="#fn19" class="footnote-ref" id="fnref19" role="doc-noteref"><sup>19</sup></a> <em>beyond the scope</em>, but without tooooooo much effort you can show that <span class="math display">\[
\bar b = A^{-T} \bar c,
\]</span> which you should recognise as the equation that was just implemented.</p>
<p>The thing that we <em>do not</em> have to implement in JAX is the other adjoint that, for dense matrices<a href="#fn20" class="footnote-ref" id="fnref20" role="doc-noteref"><sup>20</sup></a>, is <span class="math display">\[
\bar{A} = -\bar{b}c^T.
\]</span> Through the healing power of … something?—Truly I do not know.— JAX can work that bit out itself. woo.</p>
</section>
<section id="testing-the-numerical-implementation-of-the-jacobian-vector-product" class="level3">
<h3 class="anchored" data-anchor-id="testing-the-numerical-implementation-of-the-jacobian-vector-product">Testing the numerical implementation of the Jacobian-vector product</h3>
<p>So let’s see if this works. I’m not going to lie, I’m flying by the seat of my pants here. I’m not super familiar with the JAX internals, so I have written a lot of test cases. You may wish to skip this part. But rest assured that almost every single one of these cases was useful to me working out how this thing actually worked!</p>
<div class="cell" data-execution_count="5">
<div class="sourceCode cell-code" id="cb5"><pre class="sourceCode numberSource python number-lines code-with-copy"><code class="sourceCode python"><span id="cb5-1"><a href="#cb5-1"></a><span class="kw">def</span> make_matrix(n):</span>
<span id="cb5-2"><a href="#cb5-2"></a>    one_d <span class="op">=</span> sparse.diags([[<span class="op">-</span><span class="fl">1.</span>]<span class="op">*</span>(n<span class="op">-</span><span class="dv">1</span>), [<span class="fl">2.</span>]<span class="op">*</span>n, [<span class="op">-</span><span class="fl">1.</span>]<span class="op">*</span>(n<span class="op">-</span><span class="dv">1</span>)], [<span class="op">-</span><span class="dv">1</span>,<span class="dv">0</span>,<span class="dv">1</span>])</span>
<span id="cb5-3"><a href="#cb5-3"></a>    A <span class="op">=</span> (sparse.kronsum(one_d, one_d) <span class="op">+</span> sparse.eye(n<span class="op">*</span>n)).tocsc()</span>
<span id="cb5-4"><a href="#cb5-4"></a>    A_lower <span class="op">=</span> sparse.tril(A, <span class="bu">format</span> <span class="op">=</span> <span class="st">"csc"</span>)</span>
<span id="cb5-5"><a href="#cb5-5"></a>    A_index <span class="op">=</span> A_lower.indices</span>
<span id="cb5-6"><a href="#cb5-6"></a>    A_indptr <span class="op">=</span> A_lower.indptr</span>
<span id="cb5-7"><a href="#cb5-7"></a>    A_x <span class="op">=</span> A_lower.data</span>
<span id="cb5-8"><a href="#cb5-8"></a>    <span class="cf">return</span> (A_index, A_indptr, A_x, A)</span>
<span id="cb5-9"><a href="#cb5-9"></a></span>
<span id="cb5-10"><a href="#cb5-10"></a>A_indices, A_indptr, A_x, A <span class="op">=</span> make_matrix(<span class="dv">10</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>This is the same test case as the last blog. We will just use the lower triangle of <span class="math inline">\(A\)</span> as the test matrix.</p>
<p>First things first, let’s check out the numerical implementation of the function. We will do that by comparing the implemented Jacobian-vector product with the <em>definition</em> of the Jacobian-vector product (aka the forward<a href="#fn21" class="footnote-ref" id="fnref21" role="doc-noteref"><sup>21</sup></a> difference approximation).</p>
<p>There are lots of things that we could do here to turn these into <em>actual</em> tests. For instance, the test suite inside JAX has a lot of nice convenience functions for checking implementations of derivatives. But I went with homespun because that was how I was feeling.</p>
<p>You’ll also notice that I’m using random numbers here, which is fine for a blog. Not so fine for a test that you don’t want to be potentially<a href="#fn22" class="footnote-ref" id="fnref22" role="doc-noteref"><sup>22</sup></a> flaky.</p>
<p>The choice of <code>eps = 1e-4</code> is roughly<a href="#fn23" class="footnote-ref" id="fnref23" role="doc-noteref"><sup>23</sup></a> because it’s the square root of the single precision machine epsilon<a href="#fn24" class="footnote-ref" id="fnref24" role="doc-noteref"><sup>24</sup></a>. A very rough back of the envelope calculation for the forward difference approximation to the derivative shows that the square root of the machine epislon is about the size you want your perturbation to be.</p>
<div class="cell" data-execution_count="6">
<div class="sourceCode cell-code" id="cb6"><pre class="sourceCode numberSource python number-lines code-with-copy"><code class="sourceCode python"><span id="cb6-1"><a href="#cb6-1"></a>b <span class="op">=</span> np.random.standard_normal(<span class="dv">100</span>)</span>
<span id="cb6-2"><a href="#cb6-2"></a></span>
<span id="cb6-3"><a href="#cb6-3"></a>bt <span class="op">=</span> np.random.standard_normal(<span class="dv">100</span>)</span>
<span id="cb6-4"><a href="#cb6-4"></a>bt <span class="op">/=</span> np.linalg.norm(bt)</span>
<span id="cb6-5"><a href="#cb6-5"></a></span>
<span id="cb6-6"><a href="#cb6-6"></a>A_xt <span class="op">=</span> np.random.standard_normal(<span class="bu">len</span>(A_x))</span>
<span id="cb6-7"><a href="#cb6-7"></a>A_xt <span class="op">/=</span> np.linalg.norm(A_xt)</span>
<span id="cb6-8"><a href="#cb6-8"></a></span>
<span id="cb6-9"><a href="#cb6-9"></a>arg_values <span class="op">=</span> (A_indices, A_indptr, A_x, b )</span>
<span id="cb6-10"><a href="#cb6-10"></a></span>
<span id="cb6-11"><a href="#cb6-11"></a>arg_tangent_A <span class="op">=</span> (<span class="va">None</span>, <span class="va">None</span>, A_xt, ad.Zero(<span class="bu">type</span>(b)))</span>
<span id="cb6-12"><a href="#cb6-12"></a>arg_tangent_b <span class="op">=</span> (<span class="va">None</span>, <span class="va">None</span>, ad.Zero(<span class="bu">type</span>(A_xt)), bt)</span>
<span id="cb6-13"><a href="#cb6-13"></a>arg_tangent_Ab <span class="op">=</span> (<span class="va">None</span>, <span class="va">None</span>, A_xt, bt)</span>
<span id="cb6-14"><a href="#cb6-14"></a></span>
<span id="cb6-15"><a href="#cb6-15"></a>p, t_A <span class="op">=</span> sparse_triangular_solve_value_and_jvp(arg_values, arg_tangent_A, transpose <span class="op">=</span> <span class="va">False</span>)</span>
<span id="cb6-16"><a href="#cb6-16"></a>_, t_b <span class="op">=</span> sparse_triangular_solve_value_and_jvp(arg_values, arg_tangent_b, transpose <span class="op">=</span> <span class="va">False</span>)</span>
<span id="cb6-17"><a href="#cb6-17"></a>_, t_Ab <span class="op">=</span> sparse_triangular_solve_value_and_jvp(arg_values, arg_tangent_Ab, transpose <span class="op">=</span> <span class="va">False</span>)</span>
<span id="cb6-18"><a href="#cb6-18"></a>pT, t_AT <span class="op">=</span> sparse_triangular_solve_value_and_jvp(arg_values, arg_tangent_A, transpose <span class="op">=</span> <span class="va">True</span>)</span>
<span id="cb6-19"><a href="#cb6-19"></a>_, t_bT <span class="op">=</span> sparse_triangular_solve_value_and_jvp(arg_values, arg_tangent_b, transpose <span class="op">=</span> <span class="va">True</span>)</span>
<span id="cb6-20"><a href="#cb6-20"></a></span>
<span id="cb6-21"><a href="#cb6-21"></a>eps <span class="op">=</span> <span class="fl">1e-4</span></span>
<span id="cb6-22"><a href="#cb6-22"></a>tt_A <span class="op">=</span> (sparse_triangular_solve(A_indices, A_indptr, A_x <span class="op">+</span> eps <span class="op">*</span> A_xt, b) <span class="op">-</span> p) <span class="op">/</span>eps</span>
<span id="cb6-23"><a href="#cb6-23"></a>tt_b <span class="op">=</span> (sparse_triangular_solve(A_indices, A_indptr, A_x, b <span class="op">+</span> eps <span class="op">*</span> bt) <span class="op">-</span> p) <span class="op">/</span> eps</span>
<span id="cb6-24"><a href="#cb6-24"></a>tt_Ab <span class="op">=</span> (sparse_triangular_solve(A_indices, A_indptr, A_x <span class="op">+</span> eps <span class="op">*</span> A_xt, b <span class="op">+</span> eps <span class="op">*</span> bt) <span class="op">-</span> p) <span class="op">/</span> eps</span>
<span id="cb6-25"><a href="#cb6-25"></a>tt_AT <span class="op">=</span> (sparse_triangular_solve(A_indices, A_indptr, A_x <span class="op">+</span> eps <span class="op">*</span> A_xt, b, transpose <span class="op">=</span> <span class="va">True</span>) <span class="op">-</span> pT) <span class="op">/</span> eps</span>
<span id="cb6-26"><a href="#cb6-26"></a>tt_bT <span class="op">=</span> (sparse_triangular_solve(A_indices, A_indptr, A_x, b <span class="op">+</span> eps <span class="op">*</span> bt, transpose <span class="op">=</span> <span class="va">True</span>) <span class="op">-</span> pT) <span class="op">/</span> eps</span>
<span id="cb6-27"><a href="#cb6-27"></a></span>
<span id="cb6-28"><a href="#cb6-28"></a><span class="bu">print</span>(<span class="ss">f"""</span></span>
<span id="cb6-29"><a href="#cb6-29"></a><span class="ss">Transpose = False:</span></span>
<span id="cb6-30"><a href="#cb6-30"></a><span class="ss">  Error A varying: </span><span class="sc">{</span>np<span class="sc">.</span>linalg<span class="sc">.</span>norm(t_A <span class="op">-</span> tt_A)<span class="sc">: .2e}</span></span>
<span id="cb6-31"><a href="#cb6-31"></a><span class="ss">  Error b varying: </span><span class="sc">{</span>np<span class="sc">.</span>linalg<span class="sc">.</span>norm(t_b <span class="op">-</span> tt_b)<span class="sc">: .2e}</span></span>
<span id="cb6-32"><a href="#cb6-32"></a><span class="ss">  Error A and b varying: </span><span class="sc">{</span>np<span class="sc">.</span>linalg<span class="sc">.</span>norm(t_Ab <span class="op">-</span> tt_Ab)<span class="sc">: .2e}</span></span>
<span id="cb6-33"><a href="#cb6-33"></a></span>
<span id="cb6-34"><a href="#cb6-34"></a><span class="ss">Transpose = True:</span></span>
<span id="cb6-35"><a href="#cb6-35"></a><span class="ss">  Error A varying: </span><span class="sc">{</span>np<span class="sc">.</span>linalg<span class="sc">.</span>norm(t_AT <span class="op">-</span> tt_AT)<span class="sc">: .2e}</span></span>
<span id="cb6-36"><a href="#cb6-36"></a><span class="ss">  Error b varying: </span><span class="sc">{</span>np<span class="sc">.</span>linalg<span class="sc">.</span>norm(t_bT <span class="op">-</span> tt_bT)<span class="sc">: .2e}</span></span>
<span id="cb6-37"><a href="#cb6-37"></a><span class="ss">"""</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>
Transpose = False:
  Error A varying:  8.90e-08
  Error b varying:  0.00e+00
  Error A and b varying:  4.08e-07

Transpose = True:
  Error A varying:  1.01e-07
  Error b varying:  0.00e+00
</code></pre>
</div>
</div>
<p>Brilliant! Everythign correct withing single precision!</p>
</section>
<section id="checking-on-the-plumbing" class="level3">
<h3 class="anchored" data-anchor-id="checking-on-the-plumbing">Checking on the plumbing</h3>
<p>Making the numerical implementation work is only half the battle. We also have to make it work <em>in the context of JAX</em>.</p>
<p>Now I would be lying if I pretended this process went smoothly. But the first time is for experience. It’s mostly a matter of just reading the documentation carefully and going through similar examples that have already been implemented.</p>
<p>And testing. I learnt how this was supposed to work by testing it.</p>
<p>(For full disclosure, I also wrote a big block f-string in the <code>sparse_triangular_solve()</code> function at one point that told me the types, shapes, and what <code>transpose</code> was, which was how I worked out that my code was breaking because I forgot the first to <code>None</code> outputs in the transposition rule. When it doubt, print shit.)</p>
<p>As you will see from my testing code, I was not going for elegance. I was running the damn permutations. If you’re looking for elegance, look elsewhere.</p>
<div class="cell" data-execution_count="7">
<div class="sourceCode cell-code" id="cb8"><pre class="sourceCode numberSource python number-lines code-with-copy"><code class="sourceCode python"><span id="cb8-1"><a href="#cb8-1"></a><span class="im">from</span> jax <span class="im">import</span> jvp, grad</span>
<span id="cb8-2"><a href="#cb8-2"></a><span class="im">from</span> jax <span class="im">import</span> scipy <span class="im">as</span> jsp</span>
<span id="cb8-3"><a href="#cb8-3"></a></span>
<span id="cb8-4"><a href="#cb8-4"></a><span class="kw">def</span> f(theta):</span>
<span id="cb8-5"><a href="#cb8-5"></a>  Ax_theta <span class="op">=</span> jnp.array(A_x)</span>
<span id="cb8-6"><a href="#cb8-6"></a>  Ax_theta <span class="op">=</span> Ax_theta.at[A_indptr[<span class="dv">20</span>]].add(theta[<span class="dv">0</span>])</span>
<span id="cb8-7"><a href="#cb8-7"></a>  Ax_theta <span class="op">=</span> Ax_theta.at[A_indptr[<span class="dv">50</span>]].add(theta[<span class="dv">1</span>])</span>
<span id="cb8-8"><a href="#cb8-8"></a>  b <span class="op">=</span> jnp.ones(<span class="dv">100</span>)</span>
<span id="cb8-9"><a href="#cb8-9"></a>  <span class="cf">return</span> sparse_triangular_solve(A_indices, A_indptr, Ax_theta, b, transpose <span class="op">=</span> <span class="va">True</span>)</span>
<span id="cb8-10"><a href="#cb8-10"></a></span>
<span id="cb8-11"><a href="#cb8-11"></a><span class="kw">def</span> f_jax(theta):</span>
<span id="cb8-12"><a href="#cb8-12"></a>  Ax_theta <span class="op">=</span> jnp.array(sparse.tril(A).todense())</span>
<span id="cb8-13"><a href="#cb8-13"></a>  Ax_theta <span class="op">=</span> Ax_theta.at[<span class="dv">20</span>,<span class="dv">20</span>].add(theta[<span class="dv">0</span>])</span>
<span id="cb8-14"><a href="#cb8-14"></a>  Ax_theta <span class="op">=</span> Ax_theta.at[<span class="dv">50</span>,<span class="dv">50</span>].add(theta[<span class="dv">1</span>])</span>
<span id="cb8-15"><a href="#cb8-15"></a>  b <span class="op">=</span> jnp.ones(<span class="dv">100</span>)</span>
<span id="cb8-16"><a href="#cb8-16"></a>  <span class="cf">return</span> jsp.linalg.solve_triangular(Ax_theta, b, lower <span class="op">=</span> <span class="va">True</span>, trans <span class="op">=</span> <span class="st">"T"</span>)</span>
<span id="cb8-17"><a href="#cb8-17"></a></span>
<span id="cb8-18"><a href="#cb8-18"></a><span class="kw">def</span> g(theta):</span>
<span id="cb8-19"><a href="#cb8-19"></a>  Ax_theta <span class="op">=</span> jnp.array(A_x)</span>
<span id="cb8-20"><a href="#cb8-20"></a>  b <span class="op">=</span> jnp.ones(<span class="dv">100</span>)</span>
<span id="cb8-21"><a href="#cb8-21"></a>  b <span class="op">=</span> b.at[<span class="dv">0</span>].<span class="bu">set</span>(theta[<span class="dv">0</span>])</span>
<span id="cb8-22"><a href="#cb8-22"></a>  b <span class="op">=</span> b.at[<span class="dv">51</span>].<span class="bu">set</span>(theta[<span class="dv">1</span>])</span>
<span id="cb8-23"><a href="#cb8-23"></a>  <span class="cf">return</span> sparse_triangular_solve(A_indices, A_indptr, Ax_theta, b, transpose <span class="op">=</span> <span class="va">True</span>)</span>
<span id="cb8-24"><a href="#cb8-24"></a></span>
<span id="cb8-25"><a href="#cb8-25"></a><span class="kw">def</span> g_jax(theta):</span>
<span id="cb8-26"><a href="#cb8-26"></a>  Ax_theta <span class="op">=</span> jnp.array(sparse.tril(A).todense())</span>
<span id="cb8-27"><a href="#cb8-27"></a>  b <span class="op">=</span> jnp.ones(<span class="dv">100</span>)</span>
<span id="cb8-28"><a href="#cb8-28"></a>  b <span class="op">=</span> b.at[<span class="dv">0</span>].<span class="bu">set</span>(theta[<span class="dv">0</span>])</span>
<span id="cb8-29"><a href="#cb8-29"></a>  b <span class="op">=</span> b.at[<span class="dv">51</span>].<span class="bu">set</span>(theta[<span class="dv">1</span>])</span>
<span id="cb8-30"><a href="#cb8-30"></a>  <span class="cf">return</span> jsp.linalg.solve_triangular(Ax_theta, b, lower <span class="op">=</span> <span class="va">True</span>, trans <span class="op">=</span> <span class="st">"T"</span>)</span>
<span id="cb8-31"><a href="#cb8-31"></a></span>
<span id="cb8-32"><a href="#cb8-32"></a><span class="kw">def</span> h(theta):</span>
<span id="cb8-33"><a href="#cb8-33"></a>  Ax_theta <span class="op">=</span> jnp.array(A_x)</span>
<span id="cb8-34"><a href="#cb8-34"></a>  Ax_theta <span class="op">=</span> Ax_theta.at[A_indptr[<span class="dv">20</span>]].add(theta[<span class="dv">0</span>]) </span>
<span id="cb8-35"><a href="#cb8-35"></a>  b <span class="op">=</span> jnp.ones(<span class="dv">100</span>)</span>
<span id="cb8-36"><a href="#cb8-36"></a>  b <span class="op">=</span> b.at[<span class="dv">51</span>].<span class="bu">set</span>(theta[<span class="dv">1</span>])</span>
<span id="cb8-37"><a href="#cb8-37"></a>  <span class="cf">return</span> sparse_triangular_solve(A_indices, A_indptr, Ax_theta, b, transpose <span class="op">=</span> <span class="va">False</span>)</span>
<span id="cb8-38"><a href="#cb8-38"></a></span>
<span id="cb8-39"><a href="#cb8-39"></a><span class="kw">def</span> h_jax(theta):</span>
<span id="cb8-40"><a href="#cb8-40"></a>  Ax_theta <span class="op">=</span> jnp.array(sparse.tril(A).todense())</span>
<span id="cb8-41"><a href="#cb8-41"></a>  Ax_theta <span class="op">=</span> Ax_theta.at[<span class="dv">20</span>,<span class="dv">20</span>].add(theta[<span class="dv">0</span>])</span>
<span id="cb8-42"><a href="#cb8-42"></a>  b <span class="op">=</span> jnp.ones(<span class="dv">100</span>)</span>
<span id="cb8-43"><a href="#cb8-43"></a>  b <span class="op">=</span> b.at[<span class="dv">51</span>].<span class="bu">set</span>(theta[<span class="dv">1</span>])</span>
<span id="cb8-44"><a href="#cb8-44"></a>  <span class="cf">return</span> jsp.linalg.solve_triangular(Ax_theta, b, lower <span class="op">=</span> <span class="va">True</span>, trans <span class="op">=</span> <span class="st">"N"</span>)</span>
<span id="cb8-45"><a href="#cb8-45"></a></span>
<span id="cb8-46"><a href="#cb8-46"></a><span class="kw">def</span> no_diff(theta):</span>
<span id="cb8-47"><a href="#cb8-47"></a>  <span class="cf">return</span> sparse_triangular_solve(A_indices, A_indptr, A_x, jnp.ones(<span class="dv">100</span>), transpose <span class="op">=</span> <span class="va">False</span>)</span>
<span id="cb8-48"><a href="#cb8-48"></a></span>
<span id="cb8-49"><a href="#cb8-49"></a><span class="kw">def</span> no_diff_jax(theta):</span>
<span id="cb8-50"><a href="#cb8-50"></a>  <span class="cf">return</span> jsp.linalg.solve_triangular(jnp.array(sparse.tril(A).todense()), jnp.ones(<span class="dv">100</span>), lower <span class="op">=</span> <span class="va">True</span>, trans <span class="op">=</span> <span class="st">"N"</span>)</span>
<span id="cb8-51"><a href="#cb8-51"></a></span>
<span id="cb8-52"><a href="#cb8-52"></a>A_indices, A_indptr, A_x, A <span class="op">=</span> make_matrix(<span class="dv">10</span>)</span>
<span id="cb8-53"><a href="#cb8-53"></a>primal1, jvp1 <span class="op">=</span> jvp(f, (jnp.array([<span class="op">-</span><span class="fl">142.</span>, <span class="fl">342.</span>]),), (jnp.array([<span class="fl">1.</span>, <span class="fl">2.</span>]),))</span>
<span id="cb8-54"><a href="#cb8-54"></a>primal2, jvp2 <span class="op">=</span> jvp(f_jax, (jnp.array([<span class="op">-</span><span class="fl">142.</span>, <span class="fl">342.</span>]),), (jnp.array([<span class="fl">1.</span>, <span class="fl">2.</span>]),))</span>
<span id="cb8-55"><a href="#cb8-55"></a>grad1 <span class="op">=</span> grad(<span class="kw">lambda</span> x: jnp.mean(f(x)))(jnp.array([<span class="op">-</span><span class="fl">142.</span>, <span class="fl">342.</span>]))</span>
<span id="cb8-56"><a href="#cb8-56"></a>grad2 <span class="op">=</span> grad(<span class="kw">lambda</span> x: jnp.mean(f_jax(x)))(jnp.array([<span class="op">-</span><span class="fl">142.</span>, <span class="fl">342.</span>]))</span>
<span id="cb8-57"><a href="#cb8-57"></a></span>
<span id="cb8-58"><a href="#cb8-58"></a>primal3, jvp3 <span class="op">=</span> jvp(g, (jnp.array([<span class="op">-</span><span class="fl">142.</span>, <span class="fl">342.</span>]),), (jnp.array([<span class="fl">1.</span>, <span class="fl">2.</span>]),))</span>
<span id="cb8-59"><a href="#cb8-59"></a>primal4, jvp4 <span class="op">=</span> jvp(g_jax, (jnp.array([<span class="op">-</span><span class="fl">142.</span>, <span class="fl">342.</span>]),), (jnp.array([<span class="fl">1.</span>, <span class="fl">2.</span>]),))</span>
<span id="cb8-60"><a href="#cb8-60"></a>grad3 <span class="op">=</span> grad(<span class="kw">lambda</span> x: jnp.mean(g(x)))(jnp.array([<span class="op">-</span><span class="fl">142.</span>, <span class="fl">342.</span>]))</span>
<span id="cb8-61"><a href="#cb8-61"></a>grad4 <span class="op">=</span> grad(<span class="kw">lambda</span> x: jnp.mean(g_jax(x)))(jnp.array([<span class="op">-</span><span class="fl">142.</span>, <span class="fl">342.</span>]))  </span>
<span id="cb8-62"><a href="#cb8-62"></a></span>
<span id="cb8-63"><a href="#cb8-63"></a>primal5, jvp5 <span class="op">=</span> jvp(h, (jnp.array([<span class="op">-</span><span class="fl">142.</span>, <span class="fl">342.</span>]),), (jnp.array([<span class="fl">1.</span>, <span class="fl">2.</span>]),))</span>
<span id="cb8-64"><a href="#cb8-64"></a>primal6, jvp6 <span class="op">=</span> jvp(h_jax, (jnp.array([<span class="op">-</span><span class="fl">142.</span>, <span class="fl">342.</span>]),), (jnp.array([<span class="fl">1.</span>, <span class="fl">2.</span>]),))</span>
<span id="cb8-65"><a href="#cb8-65"></a>grad5 <span class="op">=</span> grad(<span class="kw">lambda</span> x: jnp.mean(h(x)))(jnp.array([<span class="op">-</span><span class="fl">142.</span>, <span class="fl">342.</span>]))</span>
<span id="cb8-66"><a href="#cb8-66"></a>grad6 <span class="op">=</span> grad(<span class="kw">lambda</span> x: jnp.mean(h_jax(x)))(jnp.array([<span class="op">-</span><span class="fl">142.</span>, <span class="fl">342.</span>]))</span>
<span id="cb8-67"><a href="#cb8-67"></a></span>
<span id="cb8-68"><a href="#cb8-68"></a>primal7, jvp7 <span class="op">=</span> jvp(no_diff, (jnp.array([<span class="op">-</span><span class="fl">142.</span>, <span class="fl">342.</span>]),), (jnp.array([<span class="fl">1.</span>, <span class="fl">2.</span>]),))</span>
<span id="cb8-69"><a href="#cb8-69"></a>primal8, jvp8 <span class="op">=</span> jvp(no_diff_jax, (jnp.array([<span class="op">-</span><span class="fl">142.</span>, <span class="fl">342.</span>]),), (jnp.array([<span class="fl">1.</span>, <span class="fl">2.</span>]),))</span>
<span id="cb8-70"><a href="#cb8-70"></a>grad7 <span class="op">=</span> grad(<span class="kw">lambda</span> x: jnp.mean(no_diff(x)))(jnp.array([<span class="op">-</span><span class="fl">142.</span>, <span class="fl">342.</span>]))</span>
<span id="cb8-71"><a href="#cb8-71"></a>grad8 <span class="op">=</span> grad(<span class="kw">lambda</span> x: jnp.mean(no_diff_jax(x)))(jnp.array([<span class="op">-</span><span class="fl">142.</span>, <span class="fl">342.</span>]))</span>
<span id="cb8-72"><a href="#cb8-72"></a></span>
<span id="cb8-73"><a href="#cb8-73"></a><span class="bu">print</span>(<span class="ss">f"""</span></span>
<span id="cb8-74"><a href="#cb8-74"></a><span class="ss">Variable L:</span></span>
<span id="cb8-75"><a href="#cb8-75"></a><span class="ss">  Primal difference: </span><span class="sc">{</span>np<span class="sc">.</span>linalg<span class="sc">.</span>norm(primal1 <span class="op">-</span> primal2)<span class="sc">: .2e}</span></span>
<span id="cb8-76"><a href="#cb8-76"></a><span class="ss">  JVP difference: </span><span class="sc">{</span>np<span class="sc">.</span>linalg<span class="sc">.</span>norm(jvp1 <span class="op">-</span> jvp2)<span class="sc">: .2e}</span></span>
<span id="cb8-77"><a href="#cb8-77"></a><span class="ss">  Gradient difference: </span><span class="sc">{</span>np<span class="sc">.</span>linalg<span class="sc">.</span>norm(grad1 <span class="op">-</span> grad2)<span class="sc">: .2e}</span></span>
<span id="cb8-78"><a href="#cb8-78"></a></span>
<span id="cb8-79"><a href="#cb8-79"></a><span class="ss">Variable b:</span></span>
<span id="cb8-80"><a href="#cb8-80"></a><span class="ss">  Primal difference: </span><span class="sc">{</span>np<span class="sc">.</span>linalg<span class="sc">.</span>norm(primal3 <span class="op">-</span> primal4)<span class="sc">: .2e}</span></span>
<span id="cb8-81"><a href="#cb8-81"></a><span class="ss">  JVP difference: </span><span class="sc">{</span>np<span class="sc">.</span>linalg<span class="sc">.</span>norm(jvp3 <span class="op">-</span> jvp4)<span class="sc">: .2e}</span></span>
<span id="cb8-82"><a href="#cb8-82"></a><span class="ss">  Gradient difference: </span><span class="sc">{</span>np<span class="sc">.</span>linalg<span class="sc">.</span>norm(grad3 <span class="op">-</span> grad4)<span class="sc">: .2e}</span><span class="ss"> </span></span>
<span id="cb8-83"><a href="#cb8-83"></a></span>
<span id="cb8-84"><a href="#cb8-84"></a><span class="ss">Variable L and b:</span></span>
<span id="cb8-85"><a href="#cb8-85"></a><span class="ss">  Primal difference: </span><span class="sc">{</span>np<span class="sc">.</span>linalg<span class="sc">.</span>norm(primal5 <span class="op">-</span> primal6)<span class="sc">: .2e}</span></span>
<span id="cb8-86"><a href="#cb8-86"></a><span class="ss">  JVP difference: </span><span class="sc">{</span>np<span class="sc">.</span>linalg<span class="sc">.</span>norm(jvp5 <span class="op">-</span> jvp6)<span class="sc">: .2e}</span></span>
<span id="cb8-87"><a href="#cb8-87"></a><span class="ss">  Gradient difference: </span><span class="sc">{</span>np<span class="sc">.</span>linalg<span class="sc">.</span>norm(grad5 <span class="op">-</span> grad6)<span class="sc">: .2e}</span></span>
<span id="cb8-88"><a href="#cb8-88"></a></span>
<span id="cb8-89"><a href="#cb8-89"></a><span class="ss">No diff:</span></span>
<span id="cb8-90"><a href="#cb8-90"></a><span class="ss">  Primal difference: </span><span class="sc">{</span>np<span class="sc">.</span>linalg<span class="sc">.</span>norm(primal7 <span class="op">-</span> primal8)<span class="sc">}</span></span>
<span id="cb8-91"><a href="#cb8-91"></a><span class="ss">  JVP difference: </span><span class="sc">{</span>np<span class="sc">.</span>linalg<span class="sc">.</span>norm(jvp7 <span class="op">-</span> jvp8)<span class="sc">}</span></span>
<span id="cb8-92"><a href="#cb8-92"></a><span class="ss">  Gradient difference: </span><span class="sc">{</span>np<span class="sc">.</span>linalg<span class="sc">.</span>norm(grad7 <span class="op">-</span> grad8)<span class="sc">}</span></span>
<span id="cb8-93"><a href="#cb8-93"></a><span class="ss">"""</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>
Variable L:
  Primal difference:  1.98e-07
  JVP difference:  2.58e-12
  Gradient difference:  0.00e+00

Variable b:
  Primal difference:  7.94e-06
  JVP difference:  1.83e-08
  Gradient difference:  3.29e-10 

Variable L and b:
  Primal difference:  2.08e-06
  JVP difference:  1.08e-08
  Gradient difference:  2.33e-10

No diff:
  Primal difference: 2.2101993124579167e-07
  JVP difference: 0.0
  Gradient difference: 0.0
</code></pre>
</div>
</div>
<p>Stunning!</p>
</section>
</section>
<section id="primitive-one-the-general-a-1b" class="level2">
<h2 class="anchored" data-anchor-id="primitive-one-the-general-a-1b">Primitive one: The general <span class="math inline">\(A^{-1}b\)</span></h2>
<p>Ok. So this is a very similar problem to the one that we just solved. But, as fate would have it, the solution is going to look quite different. Why? Because we need to compute a Cholesky factorisation.</p>
<p>First things first, though, we are going to need a JAX-traceable way to compute a Cholesky factor. This means that we need<a href="#fn25" class="footnote-ref" id="fnref25" role="doc-noteref"><sup>25</sup></a> to tell our <code>sparse_solve</code> function the how many non-zeros the sparse Cholesky will have. Why? Well. It has to do with how the function is used.</p>
<p>When <code>sparse_cholesky()</code> is called with concrete inputs<a href="#fn26" class="footnote-ref" id="fnref26" role="doc-noteref"><sup>26</sup></a>, then it can quite happily work out the sparsity structure of <span class="math inline">\(L\)</span>. But when JAX is preparing to transform the code, eg when it’s building a gradient, it calls <code>sparse_cholesky()</code> using abstract arguments that only share the shape information from the inputs. This is <em>not</em> enough to compute the sparsity structure. We <em>need</em> the <code>indices</code> and <code>indptr</code> arrays.</p>
<p>This means that we need <code>sparse_cholesky()</code> to throw an error if <code>L_nse</code> isn’t passed. This wasn’t implemented well last time, so here it is done properly.</p>
<p>(If you’re wondering about that <code>None</code> argument, it is the identity transform. So if <code>A_indices</code> is a concrete value, <code>ind = A_indices</code>. Otherwise an error is called.)</p>
<div class="cell" data-execution_count="8">
<div class="sourceCode cell-code" id="cb10"><pre class="sourceCode numberSource python number-lines code-with-copy"><code class="sourceCode python"><span id="cb10-1"><a href="#cb10-1"></a>sparse_cholesky_p <span class="op">=</span> core.Primitive(<span class="st">"sparse_cholesky"</span>)</span>
<span id="cb10-2"><a href="#cb10-2"></a></span>
<span id="cb10-3"><a href="#cb10-3"></a><span class="kw">def</span> sparse_cholesky(A_indices, A_indptr, A_x, <span class="op">*</span>, L_nse: <span class="bu">int</span> <span class="op">=</span> <span class="va">None</span>):</span>
<span id="cb10-4"><a href="#cb10-4"></a>  <span class="co">"""A JAX traceable sparse cholesky decomposition"""</span></span>
<span id="cb10-5"><a href="#cb10-5"></a>  <span class="cf">if</span> L_nse <span class="kw">is</span> <span class="va">None</span>:</span>
<span id="cb10-6"><a href="#cb10-6"></a>    err_string <span class="op">=</span> <span class="st">"You need to pass a value to L_nse when doing fancy sparse_cholesky."</span></span>
<span id="cb10-7"><a href="#cb10-7"></a>    ind <span class="op">=</span> core.concrete_or_error(<span class="va">None</span>, A_indices, err_string)</span>
<span id="cb10-8"><a href="#cb10-8"></a>    ptr <span class="op">=</span> core.concrete_or_error(<span class="va">None</span>, A_indptr, err_string)</span>
<span id="cb10-9"><a href="#cb10-9"></a>    L_ind, _ <span class="op">=</span> _symbolic_factor(ind, ptr)</span>
<span id="cb10-10"><a href="#cb10-10"></a>    L_nse <span class="op">=</span> <span class="bu">len</span>(L_ind)</span>
<span id="cb10-11"><a href="#cb10-11"></a>  </span>
<span id="cb10-12"><a href="#cb10-12"></a>  <span class="cf">return</span> sparse_cholesky_p.bind(A_indices, A_indptr, A_x, L_nse <span class="op">=</span> L_nse)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<details>
<summary>
The rest of the Choleksy code
</summary>
<div class="cell" data-execution_count="9">
<div class="sourceCode cell-code" id="cb11"><pre class="sourceCode numberSource python number-lines code-with-copy"><code class="sourceCode python"><span id="cb11-1"><a href="#cb11-1"></a><span class="at">@sparse_cholesky_p.def_impl</span></span>
<span id="cb11-2"><a href="#cb11-2"></a><span class="kw">def</span> sparse_cholesky_impl(A_indices, A_indptr, A_x, <span class="op">*</span>, L_nse):</span>
<span id="cb11-3"><a href="#cb11-3"></a>  <span class="co">"""The implementation of the sparse cholesky This is not JAX traceable."""</span></span>
<span id="cb11-4"><a href="#cb11-4"></a>  </span>
<span id="cb11-5"><a href="#cb11-5"></a>  L_indices, L_indptr<span class="op">=</span> _symbolic_factor(A_indices, A_indptr)</span>
<span id="cb11-6"><a href="#cb11-6"></a>  <span class="cf">if</span> L_nse <span class="kw">is</span> <span class="kw">not</span> <span class="va">None</span>:</span>
<span id="cb11-7"><a href="#cb11-7"></a>    <span class="cf">assert</span> <span class="bu">len</span>(L_indices) <span class="op">==</span> L_nse</span>
<span id="cb11-8"><a href="#cb11-8"></a>    </span>
<span id="cb11-9"><a href="#cb11-9"></a>  L_x <span class="op">=</span> _structured_copy(A_indices, A_indptr, A_x, L_indices, L_indptr)</span>
<span id="cb11-10"><a href="#cb11-10"></a>  L_x <span class="op">=</span> _sparse_cholesky_impl(L_indices, L_indptr, L_x)</span>
<span id="cb11-11"><a href="#cb11-11"></a>  <span class="cf">return</span> L_indices, L_indptr, L_x</span>
<span id="cb11-12"><a href="#cb11-12"></a></span>
<span id="cb11-13"><a href="#cb11-13"></a><span class="kw">def</span> _symbolic_factor(A_indices, A_indptr):</span>
<span id="cb11-14"><a href="#cb11-14"></a>  <span class="co"># Assumes A_indices and A_indptr index the lower triangle of $A$ ONLY.</span></span>
<span id="cb11-15"><a href="#cb11-15"></a>  n <span class="op">=</span> <span class="bu">len</span>(A_indptr) <span class="op">-</span> <span class="dv">1</span></span>
<span id="cb11-16"><a href="#cb11-16"></a>  L_sym <span class="op">=</span> [np.array([], dtype<span class="op">=</span><span class="bu">int</span>) <span class="cf">for</span> j <span class="kw">in</span> <span class="bu">range</span>(n)]</span>
<span id="cb11-17"><a href="#cb11-17"></a>  children <span class="op">=</span> [np.array([], dtype<span class="op">=</span><span class="bu">int</span>) <span class="cf">for</span> j <span class="kw">in</span> <span class="bu">range</span>(n)]</span>
<span id="cb11-18"><a href="#cb11-18"></a>  </span>
<span id="cb11-19"><a href="#cb11-19"></a>  <span class="cf">for</span> j <span class="kw">in</span> <span class="bu">range</span>(n):</span>
<span id="cb11-20"><a href="#cb11-20"></a>    L_sym[j] <span class="op">=</span> A_indices[A_indptr[j]:A_indptr[j <span class="op">+</span> <span class="dv">1</span>]]</span>
<span id="cb11-21"><a href="#cb11-21"></a>    <span class="cf">for</span> child <span class="kw">in</span> children[j]:</span>
<span id="cb11-22"><a href="#cb11-22"></a>      tmp <span class="op">=</span> L_sym[child][L_sym[child] <span class="op">&gt;</span> j]</span>
<span id="cb11-23"><a href="#cb11-23"></a>      L_sym[j] <span class="op">=</span> np.unique(np.append(L_sym[j], tmp))</span>
<span id="cb11-24"><a href="#cb11-24"></a>    <span class="cf">if</span> <span class="bu">len</span>(L_sym[j]) <span class="op">&gt;</span> <span class="dv">1</span>:</span>
<span id="cb11-25"><a href="#cb11-25"></a>      p <span class="op">=</span> L_sym[j][<span class="dv">1</span>]</span>
<span id="cb11-26"><a href="#cb11-26"></a>      children[p] <span class="op">=</span> np.append(children[p], j)</span>
<span id="cb11-27"><a href="#cb11-27"></a>        </span>
<span id="cb11-28"><a href="#cb11-28"></a>  L_indptr <span class="op">=</span> np.zeros(n<span class="op">+</span><span class="dv">1</span>, dtype<span class="op">=</span><span class="bu">int</span>)</span>
<span id="cb11-29"><a href="#cb11-29"></a>  L_indptr[<span class="dv">1</span>:] <span class="op">=</span> np.cumsum([<span class="bu">len</span>(x) <span class="cf">for</span> x <span class="kw">in</span> L_sym])</span>
<span id="cb11-30"><a href="#cb11-30"></a>  L_indices <span class="op">=</span> np.concatenate(L_sym)</span>
<span id="cb11-31"><a href="#cb11-31"></a>  </span>
<span id="cb11-32"><a href="#cb11-32"></a>  <span class="cf">return</span> L_indices, L_indptr</span>
<span id="cb11-33"><a href="#cb11-33"></a></span>
<span id="cb11-34"><a href="#cb11-34"></a></span>
<span id="cb11-35"><a href="#cb11-35"></a></span>
<span id="cb11-36"><a href="#cb11-36"></a><span class="kw">def</span> _structured_copy(A_indices, A_indptr, A_x, L_indices, L_indptr):</span>
<span id="cb11-37"><a href="#cb11-37"></a>  n <span class="op">=</span> <span class="bu">len</span>(A_indptr) <span class="op">-</span> <span class="dv">1</span></span>
<span id="cb11-38"><a href="#cb11-38"></a>  L_x <span class="op">=</span> np.zeros(<span class="bu">len</span>(L_indices))</span>
<span id="cb11-39"><a href="#cb11-39"></a>  </span>
<span id="cb11-40"><a href="#cb11-40"></a>  <span class="cf">for</span> j <span class="kw">in</span> <span class="bu">range</span>(<span class="dv">0</span>, n):</span>
<span id="cb11-41"><a href="#cb11-41"></a>    copy_idx <span class="op">=</span> np.nonzero(np.in1d(L_indices[L_indptr[j]:L_indptr[j <span class="op">+</span> <span class="dv">1</span>]],</span>
<span id="cb11-42"><a href="#cb11-42"></a>                                  A_indices[A_indptr[j]:A_indptr[j<span class="op">+</span><span class="dv">1</span>]]))[<span class="dv">0</span>]</span>
<span id="cb11-43"><a href="#cb11-43"></a>    L_x[L_indptr[j] <span class="op">+</span> copy_idx] <span class="op">=</span> A_x[A_indptr[j]:A_indptr[j<span class="op">+</span><span class="dv">1</span>]]</span>
<span id="cb11-44"><a href="#cb11-44"></a>  <span class="cf">return</span> L_x</span>
<span id="cb11-45"><a href="#cb11-45"></a></span>
<span id="cb11-46"><a href="#cb11-46"></a><span class="kw">def</span> _sparse_cholesky_impl(L_indices, L_indptr, L_x):</span>
<span id="cb11-47"><a href="#cb11-47"></a>  n <span class="op">=</span> <span class="bu">len</span>(L_indptr) <span class="op">-</span> <span class="dv">1</span></span>
<span id="cb11-48"><a href="#cb11-48"></a>  descendant <span class="op">=</span> [[] <span class="cf">for</span> j <span class="kw">in</span> <span class="bu">range</span>(<span class="dv">0</span>, n)]</span>
<span id="cb11-49"><a href="#cb11-49"></a>  <span class="cf">for</span> j <span class="kw">in</span> <span class="bu">range</span>(<span class="dv">0</span>, n):</span>
<span id="cb11-50"><a href="#cb11-50"></a>    tmp <span class="op">=</span> L_x[L_indptr[j]:L_indptr[j <span class="op">+</span> <span class="dv">1</span>]]</span>
<span id="cb11-51"><a href="#cb11-51"></a>    <span class="cf">for</span> bebe <span class="kw">in</span> descendant[j]:</span>
<span id="cb11-52"><a href="#cb11-52"></a>      k <span class="op">=</span> bebe[<span class="dv">0</span>]</span>
<span id="cb11-53"><a href="#cb11-53"></a>      Ljk<span class="op">=</span> L_x[bebe[<span class="dv">1</span>]]</span>
<span id="cb11-54"><a href="#cb11-54"></a>      pad <span class="op">=</span> np.nonzero(                                                       <span class="op">\</span></span>
<span id="cb11-55"><a href="#cb11-55"></a>          L_indices[L_indptr[k]:L_indptr[k<span class="op">+</span><span class="dv">1</span>]] <span class="op">==</span> L_indices[L_indptr[j]])[<span class="dv">0</span>][<span class="dv">0</span>]</span>
<span id="cb11-56"><a href="#cb11-56"></a>      update_idx <span class="op">=</span> np.nonzero(np.in1d(                                        <span class="op">\</span></span>
<span id="cb11-57"><a href="#cb11-57"></a>                    L_indices[L_indptr[j]:L_indptr[j<span class="op">+</span><span class="dv">1</span>]],                     <span class="op">\</span></span>
<span id="cb11-58"><a href="#cb11-58"></a>                    L_indices[(L_indptr[k] <span class="op">+</span> pad):L_indptr[k<span class="op">+</span><span class="dv">1</span>]]))[<span class="dv">0</span>]</span>
<span id="cb11-59"><a href="#cb11-59"></a>      tmp[update_idx] <span class="op">=</span> tmp[update_idx] <span class="op">-</span>                                     <span class="op">\</span></span>
<span id="cb11-60"><a href="#cb11-60"></a>                        Ljk <span class="op">*</span> L_x[(L_indptr[k] <span class="op">+</span> pad):L_indptr[k <span class="op">+</span> <span class="dv">1</span>]]</span>
<span id="cb11-61"><a href="#cb11-61"></a>            </span>
<span id="cb11-62"><a href="#cb11-62"></a>    diag <span class="op">=</span> np.sqrt(tmp[<span class="dv">0</span>])</span>
<span id="cb11-63"><a href="#cb11-63"></a>    L_x[L_indptr[j]] <span class="op">=</span> diag</span>
<span id="cb11-64"><a href="#cb11-64"></a>    L_x[(L_indptr[j] <span class="op">+</span> <span class="dv">1</span>):L_indptr[j <span class="op">+</span> <span class="dv">1</span>]] <span class="op">=</span> tmp[<span class="dv">1</span>:] <span class="op">/</span> diag</span>
<span id="cb11-65"><a href="#cb11-65"></a>    <span class="cf">for</span> idx <span class="kw">in</span> <span class="bu">range</span>(L_indptr[j] <span class="op">+</span> <span class="dv">1</span>, L_indptr[j <span class="op">+</span> <span class="dv">1</span>]):</span>
<span id="cb11-66"><a href="#cb11-66"></a>      descendant[L_indices[idx]].append((j, idx))</span>
<span id="cb11-67"><a href="#cb11-67"></a>  <span class="cf">return</span> L_x</span>
<span id="cb11-68"><a href="#cb11-68"></a></span>
<span id="cb11-69"><a href="#cb11-69"></a><span class="at">@sparse_cholesky_p.def_abstract_eval</span></span>
<span id="cb11-70"><a href="#cb11-70"></a><span class="kw">def</span> sparse_cholesky_abstract_eval(A_indices, A_indptr, A_x, <span class="op">*</span>, L_nse):</span>
<span id="cb11-71"><a href="#cb11-71"></a>  <span class="cf">return</span> core.ShapedArray((L_nse,), A_indices.dtype),                   <span class="op">\</span></span>
<span id="cb11-72"><a href="#cb11-72"></a>         core.ShapedArray(A_indptr.shape, A_indptr.dtype),             <span class="op">\</span></span>
<span id="cb11-73"><a href="#cb11-73"></a>         core.ShapedArray((L_nse,), A_x.dtype)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
</details>
<section id="why-do-we-need-a-new-pattern-for-this-very-very-similar-problem" class="level3">
<h3 class="anchored" data-anchor-id="why-do-we-need-a-new-pattern-for-this-very-very-similar-problem">Why do we need a new pattern for this very very similar problem?</h3>
<p>Ok. So now on to the details. If we try to repeat our previous pattern it would look like this.</p>
<div class="cell" data-execution_count="10">
<div class="sourceCode cell-code" id="cb12"><pre class="sourceCode numberSource python number-lines code-with-copy"><code class="sourceCode python"><span id="cb12-1"><a href="#cb12-1"></a><span class="kw">def</span> sparse_solve_value_and_jvp(arg_values, arg_tangents, <span class="op">*</span>, L_nse):</span>
<span id="cb12-2"><a href="#cb12-2"></a>  <span class="co">""" </span></span>
<span id="cb12-3"><a href="#cb12-3"></a><span class="co">  Jax-traceable jacobian-vector product implmentation for sparse_solve.</span></span>
<span id="cb12-4"><a href="#cb12-4"></a><span class="co">  """</span></span>
<span id="cb12-5"><a href="#cb12-5"></a>  </span>
<span id="cb12-6"><a href="#cb12-6"></a>  A_indices, A_indptr, A_x, b <span class="op">=</span> arg_values</span>
<span id="cb12-7"><a href="#cb12-7"></a>  _, _, A_xt, bt <span class="op">=</span> arg_tangents</span>
<span id="cb12-8"><a href="#cb12-8"></a></span>
<span id="cb12-9"><a href="#cb12-9"></a>  <span class="co"># Needed for shared computation</span></span>
<span id="cb12-10"><a href="#cb12-10"></a>  L_indices, L_indptr, L_x <span class="op">=</span> sparse_cholesky(A_indices, A_indptr, A_x)</span>
<span id="cb12-11"><a href="#cb12-11"></a></span>
<span id="cb12-12"><a href="#cb12-12"></a>  <span class="co"># Make the primal</span></span>
<span id="cb12-13"><a href="#cb12-13"></a>  primal_out <span class="op">=</span> sparse_triangular_solve(L_indices, L_indptr, L_x, b, transpose <span class="op">=</span> <span class="va">False</span>)</span>
<span id="cb12-14"><a href="#cb12-14"></a>  primal_out <span class="op">=</span> sparse_triangular_solve(L_indices, L_indptr, L_x, primal_out, transpose <span class="op">=</span> <span class="va">True</span>)</span>
<span id="cb12-15"><a href="#cb12-15"></a></span>
<span id="cb12-16"><a href="#cb12-16"></a>  <span class="cf">if</span> <span class="bu">type</span>(A_xt) <span class="kw">is</span> <span class="kw">not</span> ad.Zero:</span>
<span id="cb12-17"><a href="#cb12-17"></a>    Delta_lower <span class="op">=</span> jsparse.CSC((A_xt, A_indices, A_indptr), shape <span class="op">=</span> (b.shape[<span class="dv">0</span>], b.shape[<span class="dv">0</span>]))</span>
<span id="cb12-18"><a href="#cb12-18"></a>    <span class="co"># We need to do Delta @ primal_out, but we only have the lower triangle</span></span>
<span id="cb12-19"><a href="#cb12-19"></a>    rhs <span class="op">=</span> Delta_lower <span class="op">@</span> primal_out <span class="op">+</span> Delta_lower.transpose() <span class="op">@</span> primal_out <span class="op">-</span> A_xt[A_indptr[:<span class="op">-</span><span class="dv">1</span>]] <span class="op">*</span> primal_out</span>
<span id="cb12-20"><a href="#cb12-20"></a>    jvp_Ax <span class="op">=</span> sparse_triangular_solve(L_indices, L_indptr, L_x, rhs)</span>
<span id="cb12-21"><a href="#cb12-21"></a>    jvp_Ax <span class="op">=</span> sparse_triangular_solve(L_indices, L_indptr, L_x, jvp_Ax, transpose <span class="op">=</span> <span class="va">True</span>)</span>
<span id="cb12-22"><a href="#cb12-22"></a>  <span class="cf">else</span>:</span>
<span id="cb12-23"><a href="#cb12-23"></a>    jvp_Ax <span class="op">=</span> lax.zeros_like_array(primal_out)</span>
<span id="cb12-24"><a href="#cb12-24"></a></span>
<span id="cb12-25"><a href="#cb12-25"></a>  <span class="cf">if</span> <span class="bu">type</span>(bt) <span class="kw">is</span> <span class="kw">not</span> ad.Zero:</span>
<span id="cb12-26"><a href="#cb12-26"></a>    jvp_b <span class="op">=</span> sparse_triangular_solve(L_indices, L_indptr, L_x, bt)</span>
<span id="cb12-27"><a href="#cb12-27"></a>    jvp_b <span class="op">=</span> sparse_triangular_solve(L_indices, L_indptr, L_x, jvp_b, transpose <span class="op">=</span> <span class="va">True</span>)</span>
<span id="cb12-28"><a href="#cb12-28"></a>  <span class="cf">else</span>:</span>
<span id="cb12-29"><a href="#cb12-29"></a>    jvp_b <span class="op">=</span> lax.zeros_like_array(primal_out)</span>
<span id="cb12-30"><a href="#cb12-30"></a></span>
<span id="cb12-31"><a href="#cb12-31"></a>  <span class="cf">return</span> primal_out, jvp_b <span class="op">-</span> jvp_Ax</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>That’s all well and good. Nothing weird there.</p>
<p>The problem comes when you need to implement the transposition rule. Remembering that <span class="math inline">\(\bar b = A^{-T}\bar c = A^{-1}\bar c\)</span>, you might see the issue: we are going to need the Cholesky factorisation. <em>But we have no way to pass</em> <span class="math inline">\(L\)</span> <em>to the transpose function</em>.</p>
<p>This means that we would need to compute <em>two</em> Cholesky factorisations per gradient instead of one. As the Cholesky factorisation is our slowest operation, we do not want to do extra ones! We want to compute the Cholesky triangle once and pass it around like a party bottom<a href="#fn27" class="footnote-ref" id="fnref27" role="doc-noteref"><sup>27</sup></a>. We do not want each of our functions to have to make a deep and meaningful connection with the damn matrix<a href="#fn28" class="footnote-ref" id="fnref28" role="doc-noteref"><sup>28</sup></a>.</p>
</section>
<section id="a-different-solution" class="level3">
<h3 class="anchored" data-anchor-id="a-different-solution">A different solution</h3>
<p>So how do we pass around our Cholesky triangle? Well, I do love a good class so my first thought was “fuck it. I’ll make a class and I’ll pass it that way”. But the developers of JAX had a <em>much</em> better idea.</p>
<p>Their idea was to abstract the idea of a linear solve and its gradients. They do this through <code>lax.custom_linear_solve</code>. This is a function that takes all of the bits that you would need to compute <span class="math inline">\(A^{-1}b\)</span> and all of its derivatives. In particular it takes<a href="#fn29" class="footnote-ref" id="fnref29" role="doc-noteref"><sup>29</sup></a>:</p>
<ul>
<li><code>matvec</code>: A function that <code>matvec(x)</code> that computes <span class="math inline">\(Ax\)</span>. This might seem a bit weird, but it’s the most common atrocity committed by mathematicians is abstracting<a href="#fn30" class="footnote-ref" id="fnref30" role="doc-noteref"><sup>30</sup></a> a matrix to a linear mapping. So we might as well just suck it up.</li>
<li><code>b</code>: The right hand side vector<a href="#fn31" class="footnote-ref" id="fnref31" role="doc-noteref"><sup>31</sup></a></li>
<li><code>solve</code>: A function that takes takes the <code>matvec</code> and a vector so that<a href="#fn32" class="footnote-ref" id="fnref32" role="doc-noteref"><sup>32</sup></a> <code>solve(matvec, matvec(x)) == x</code></li>
<li><code>symmetric</code>: A boolean indicating if <span class="math inline">\(A\)</span> is symmetric.</li>
</ul>
<p>The idea (happily copped from the implementation of <code>jax.scipy.linalg.solve</code>) is to wrap our Cholesky decomposition in the solve function. Through the never ending miracle of partial evaluation.</p>
<div class="cell" data-execution_count="11">
<div class="sourceCode cell-code" id="cb13"><pre class="sourceCode numberSource python number-lines code-with-copy"><code class="sourceCode python"><span id="cb13-1"><a href="#cb13-1"></a><span class="im">from</span> functools <span class="im">import</span> partial</span>
<span id="cb13-2"><a href="#cb13-2"></a></span>
<span id="cb13-3"><a href="#cb13-3"></a><span class="kw">def</span> sparse_solve(A_indices, A_indptr, A_x, b, <span class="op">*</span>, L_nse <span class="op">=</span> <span class="va">None</span>):</span>
<span id="cb13-4"><a href="#cb13-4"></a>  <span class="co">"""</span></span>
<span id="cb13-5"><a href="#cb13-5"></a><span class="co">  A JAX-traceable sparse solve. For this moment, only for vector b</span></span>
<span id="cb13-6"><a href="#cb13-6"></a><span class="co">  """</span></span>
<span id="cb13-7"><a href="#cb13-7"></a>  <span class="cf">assert</span> b.shape[<span class="dv">0</span>] <span class="op">==</span> A_indptr.shape[<span class="dv">0</span>] <span class="op">-</span> <span class="dv">1</span></span>
<span id="cb13-8"><a href="#cb13-8"></a>  <span class="cf">assert</span> b.ndim <span class="op">==</span> <span class="dv">1</span></span>
<span id="cb13-9"><a href="#cb13-9"></a>  </span>
<span id="cb13-10"><a href="#cb13-10"></a>  L_indices, L_indptr, L_x <span class="op">=</span> sparse_cholesky(</span>
<span id="cb13-11"><a href="#cb13-11"></a>    lax.stop_gradient(A_indices), </span>
<span id="cb13-12"><a href="#cb13-12"></a>    lax.stop_gradient(A_indptr), </span>
<span id="cb13-13"><a href="#cb13-13"></a>    lax.stop_gradient(A_x), L_nse <span class="op">=</span> L_nse)</span>
<span id="cb13-14"><a href="#cb13-14"></a>  </span>
<span id="cb13-15"><a href="#cb13-15"></a>  <span class="kw">def</span> chol_solve(L_indices, L_indptr, L_x, b):</span>
<span id="cb13-16"><a href="#cb13-16"></a>    out <span class="op">=</span> sparse_triangular_solve(L_indices, L_indptr, L_x, b, transpose <span class="op">=</span> <span class="va">False</span>)</span>
<span id="cb13-17"><a href="#cb13-17"></a>    <span class="cf">return</span> sparse_triangular_solve(L_indices, L_indptr, L_x, out, transpose <span class="op">=</span> <span class="va">True</span>)</span>
<span id="cb13-18"><a href="#cb13-18"></a>  </span>
<span id="cb13-19"><a href="#cb13-19"></a>  <span class="kw">def</span> matmult(A_indices, A_indptr, A_x, b):</span>
<span id="cb13-20"><a href="#cb13-20"></a>    A_lower <span class="op">=</span> jsparse.CSC((A_x, A_indices, A_indptr), shape <span class="op">=</span> (b.shape[<span class="dv">0</span>], b.shape[<span class="dv">0</span>]))</span>
<span id="cb13-21"><a href="#cb13-21"></a>    <span class="cf">return</span> A_lower <span class="op">@</span> b <span class="op">+</span> A_lower.transpose() <span class="op">@</span> b <span class="op">-</span> A_x[A_indptr[:<span class="op">-</span><span class="dv">1</span>]] <span class="op">*</span> b</span>
<span id="cb13-22"><a href="#cb13-22"></a></span>
<span id="cb13-23"><a href="#cb13-23"></a>  solver <span class="op">=</span> partial(</span>
<span id="cb13-24"><a href="#cb13-24"></a>    lax.custom_linear_solve,</span>
<span id="cb13-25"><a href="#cb13-25"></a>    <span class="kw">lambda</span> x: matmult(A_indices, A_indptr, A_x, x),</span>
<span id="cb13-26"><a href="#cb13-26"></a>    solve <span class="op">=</span> <span class="kw">lambda</span> _, x: chol_solve(L_indices, L_indptr, L_x, x),</span>
<span id="cb13-27"><a href="#cb13-27"></a>    symmetric <span class="op">=</span> <span class="va">True</span>)</span>
<span id="cb13-28"><a href="#cb13-28"></a></span>
<span id="cb13-29"><a href="#cb13-29"></a>  <span class="cf">return</span> solver(b)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>There are three things of note in that implementation.</p>
<ol type="1">
<li><p>The calls to <code>lax.stop_gradient()</code>: These tell JAX to not bother computing the gradient of these terms. The relevant parts of the derivatives are computed explicitly by <code>lax.custom_linear_solve</code> in terms of <code>matmult</code> and <code>solve</code>, neither of which need the explicit derivative of the cholesky factorisation.!</p></li>
<li><p>That definition of <code>matmult()</code><a href="#fn33" class="footnote-ref" id="fnref33" role="doc-noteref"><sup>33</sup></a>: Look. I don’t know what to tell you. Neither addition nor indexing is implemented for <code>jsparse.CSC</code> objects. So we did it the semi-manual way. (I am thankful that matrix-vector multiplication is available)</p></li>
<li><p>The definition of <code>solver()</code>: Partial evaluation is a wonderful wonderful thing. <code>functools.partial()</code> transforms <code>lax.custom_linear_solve()</code> from a function that takes 3 arguments (and some keywords), into a function <code>solver()</code> that takes one<a href="#fn34" class="footnote-ref" id="fnref34" role="doc-noteref"><sup>34</sup></a> argument<a href="#fn35" class="footnote-ref" id="fnref35" role="doc-noteref"><sup>35</sup></a> (<code>b</code>, the only positional argument of <code>lax.custom_linear_solve()</code> that isn’t specified).</p></li>
</ol>
</section>
<section id="does-it-work" class="level3">
<h3 class="anchored" data-anchor-id="does-it-work">Does it work?</h3>
<div class="cell" data-execution_count="12">
<div class="sourceCode cell-code" id="cb14"><pre class="sourceCode numberSource python number-lines code-with-copy"><code class="sourceCode python"><span id="cb14-1"><a href="#cb14-1"></a><span class="kw">def</span> f(theta):</span>
<span id="cb14-2"><a href="#cb14-2"></a>  Ax_theta <span class="op">=</span> jnp.array(theta[<span class="dv">0</span>] <span class="op">*</span> A_x)</span>
<span id="cb14-3"><a href="#cb14-3"></a>  Ax_theta <span class="op">=</span> Ax_theta.at[A_indptr[:<span class="op">-</span><span class="dv">1</span>]].add(theta[<span class="dv">1</span>])</span>
<span id="cb14-4"><a href="#cb14-4"></a>  b <span class="op">=</span> jnp.ones(<span class="dv">100</span>)</span>
<span id="cb14-5"><a href="#cb14-5"></a>  <span class="cf">return</span> sparse_solve(A_indices, A_indptr, Ax_theta, b)</span>
<span id="cb14-6"><a href="#cb14-6"></a></span>
<span id="cb14-7"><a href="#cb14-7"></a><span class="kw">def</span> f_jax(theta):</span>
<span id="cb14-8"><a href="#cb14-8"></a>  Ax_theta <span class="op">=</span> jnp.array(theta[<span class="dv">0</span>] <span class="op">*</span> A.todense())</span>
<span id="cb14-9"><a href="#cb14-9"></a>  Ax_theta <span class="op">=</span> Ax_theta.at[np.arange(<span class="dv">100</span>),np.arange(<span class="dv">100</span>)].add(theta[<span class="dv">1</span>])</span>
<span id="cb14-10"><a href="#cb14-10"></a>  b <span class="op">=</span> jnp.ones(<span class="dv">100</span>)</span>
<span id="cb14-11"><a href="#cb14-11"></a>  <span class="cf">return</span> jsp.linalg.solve(Ax_theta, b)</span>
<span id="cb14-12"><a href="#cb14-12"></a></span>
<span id="cb14-13"><a href="#cb14-13"></a><span class="kw">def</span> g(theta):</span>
<span id="cb14-14"><a href="#cb14-14"></a>  Ax_theta <span class="op">=</span> jnp.array(A_x)</span>
<span id="cb14-15"><a href="#cb14-15"></a>  b <span class="op">=</span> jnp.ones(<span class="dv">100</span>)</span>
<span id="cb14-16"><a href="#cb14-16"></a>  b <span class="op">=</span> b.at[<span class="dv">0</span>].<span class="bu">set</span>(theta[<span class="dv">0</span>])</span>
<span id="cb14-17"><a href="#cb14-17"></a>  b <span class="op">=</span> b.at[<span class="dv">51</span>].<span class="bu">set</span>(theta[<span class="dv">1</span>])</span>
<span id="cb14-18"><a href="#cb14-18"></a>  <span class="cf">return</span> sparse_solve(A_indices, A_indptr, Ax_theta, b)</span>
<span id="cb14-19"><a href="#cb14-19"></a></span>
<span id="cb14-20"><a href="#cb14-20"></a><span class="kw">def</span> g_jax(theta):</span>
<span id="cb14-21"><a href="#cb14-21"></a>  Ax_theta <span class="op">=</span> jnp.array(A.todense())</span>
<span id="cb14-22"><a href="#cb14-22"></a>  b <span class="op">=</span> jnp.ones(<span class="dv">100</span>)</span>
<span id="cb14-23"><a href="#cb14-23"></a>  b <span class="op">=</span> b.at[<span class="dv">0</span>].<span class="bu">set</span>(theta[<span class="dv">0</span>])</span>
<span id="cb14-24"><a href="#cb14-24"></a>  b <span class="op">=</span> b.at[<span class="dv">51</span>].<span class="bu">set</span>(theta[<span class="dv">1</span>])</span>
<span id="cb14-25"><a href="#cb14-25"></a>  <span class="cf">return</span> jsp.linalg.solve(Ax_theta, b)</span>
<span id="cb14-26"><a href="#cb14-26"></a></span>
<span id="cb14-27"><a href="#cb14-27"></a><span class="kw">def</span> h(theta):</span>
<span id="cb14-28"><a href="#cb14-28"></a>  Ax_theta <span class="op">=</span> jnp.array(A_x)</span>
<span id="cb14-29"><a href="#cb14-29"></a>  Ax_theta <span class="op">=</span> Ax_theta.at[A_indptr[:<span class="op">-</span><span class="dv">1</span>]].add(theta[<span class="dv">0</span>])</span>
<span id="cb14-30"><a href="#cb14-30"></a>  b <span class="op">=</span> jnp.ones(<span class="dv">100</span>)</span>
<span id="cb14-31"><a href="#cb14-31"></a>  b <span class="op">=</span> b.at[<span class="dv">51</span>].<span class="bu">set</span>(theta[<span class="dv">1</span>])</span>
<span id="cb14-32"><a href="#cb14-32"></a>  <span class="cf">return</span> sparse_solve(A_indices, A_indptr, Ax_theta, b)</span>
<span id="cb14-33"><a href="#cb14-33"></a></span>
<span id="cb14-34"><a href="#cb14-34"></a><span class="kw">def</span> h_jax(theta):</span>
<span id="cb14-35"><a href="#cb14-35"></a>  Ax_theta <span class="op">=</span> jnp.array(A.todense())</span>
<span id="cb14-36"><a href="#cb14-36"></a>  Ax_theta <span class="op">=</span> Ax_theta.at[np.arange(<span class="dv">100</span>),np.arange(<span class="dv">100</span>)].add(theta[<span class="dv">0</span>])</span>
<span id="cb14-37"><a href="#cb14-37"></a>  b <span class="op">=</span> jnp.ones(<span class="dv">100</span>)</span>
<span id="cb14-38"><a href="#cb14-38"></a>  b <span class="op">=</span> b.at[<span class="dv">51</span>].<span class="bu">set</span>(theta[<span class="dv">1</span>])</span>
<span id="cb14-39"><a href="#cb14-39"></a>  <span class="cf">return</span> jsp.linalg.solve(Ax_theta, b)</span>
<span id="cb14-40"><a href="#cb14-40"></a></span>
<span id="cb14-41"><a href="#cb14-41"></a>primal1, jvp1 <span class="op">=</span> jvp(f, (jnp.array([<span class="fl">2.</span>, <span class="fl">3.</span>]),), (jnp.array([<span class="fl">1.</span>, <span class="fl">2.</span>]),))</span>
<span id="cb14-42"><a href="#cb14-42"></a>primal2, jvp2 <span class="op">=</span> jvp(f_jax, (jnp.array([<span class="fl">2.</span>, <span class="fl">3.</span>]),), (jnp.array([<span class="fl">1.</span>, <span class="fl">2.</span>]),))</span>
<span id="cb14-43"><a href="#cb14-43"></a>grad1 <span class="op">=</span> grad(<span class="kw">lambda</span> x: jnp.mean(f(x)))(jnp.array([<span class="fl">2.</span>, <span class="fl">3.</span>]))</span>
<span id="cb14-44"><a href="#cb14-44"></a>grad2 <span class="op">=</span> grad(<span class="kw">lambda</span> x: jnp.mean(f_jax(x)))(jnp.array([<span class="fl">2.</span>, <span class="fl">3.</span>]))</span>
<span id="cb14-45"><a href="#cb14-45"></a></span>
<span id="cb14-46"><a href="#cb14-46"></a></span>
<span id="cb14-47"><a href="#cb14-47"></a>primal3, jvp3 <span class="op">=</span> jvp(g, (jnp.array([<span class="op">-</span><span class="fl">142.</span>, <span class="fl">342.</span>]),), (jnp.array([<span class="fl">1.</span>, <span class="fl">2.</span>]),))</span>
<span id="cb14-48"><a href="#cb14-48"></a>primal4, jvp4 <span class="op">=</span> jvp(g_jax, (jnp.array([<span class="op">-</span><span class="fl">142.</span>, <span class="fl">342.</span>]),), (jnp.array([<span class="fl">1.</span>, <span class="fl">2.</span>]),))</span>
<span id="cb14-49"><a href="#cb14-49"></a>grad3 <span class="op">=</span> grad(<span class="kw">lambda</span> x: jnp.mean(g(x)))(jnp.array([<span class="op">-</span><span class="fl">142.</span>, <span class="fl">342.</span>]))</span>
<span id="cb14-50"><a href="#cb14-50"></a>grad4 <span class="op">=</span> grad(<span class="kw">lambda</span> x: jnp.mean(g_jax(x)))(jnp.array([<span class="op">-</span><span class="fl">142.</span>, <span class="fl">342.</span>]))</span>
<span id="cb14-51"><a href="#cb14-51"></a></span>
<span id="cb14-52"><a href="#cb14-52"></a>primal5, jvp5 <span class="op">=</span> jvp(h, (jnp.array([<span class="fl">2.</span>, <span class="fl">342.</span>]),), (jnp.array([<span class="fl">1.</span>, <span class="fl">2.</span>]),))</span>
<span id="cb14-53"><a href="#cb14-53"></a>primal6, jvp6 <span class="op">=</span> jvp(h_jax, (jnp.array([<span class="fl">2.</span>, <span class="fl">342.</span>]),), (jnp.array([<span class="fl">1.</span>, <span class="fl">2.</span>]),))</span>
<span id="cb14-54"><a href="#cb14-54"></a>grad5 <span class="op">=</span> grad(<span class="kw">lambda</span> x: jnp.mean(f(x)))(jnp.array([<span class="fl">2.</span>, <span class="fl">342.</span>]))</span>
<span id="cb14-55"><a href="#cb14-55"></a>grad6 <span class="op">=</span> grad(<span class="kw">lambda</span> x: jnp.mean(f_jax(x)))(jnp.array([<span class="fl">2.</span>, <span class="fl">342.</span>]))</span>
<span id="cb14-56"><a href="#cb14-56"></a></span>
<span id="cb14-57"><a href="#cb14-57"></a><span class="bu">print</span>(<span class="ss">f"""</span></span>
<span id="cb14-58"><a href="#cb14-58"></a><span class="ss">Check the plumbing!</span></span>
<span id="cb14-59"><a href="#cb14-59"></a><span class="ss">Variable A:</span></span>
<span id="cb14-60"><a href="#cb14-60"></a><span class="ss">  Primal difference: </span><span class="sc">{</span>np<span class="sc">.</span>linalg<span class="sc">.</span>norm(primal1 <span class="op">-</span> primal2)<span class="sc">: .2e}</span></span>
<span id="cb14-61"><a href="#cb14-61"></a><span class="ss">  JVP difference: </span><span class="sc">{</span>np<span class="sc">.</span>linalg<span class="sc">.</span>norm(jvp1 <span class="op">-</span> jvp2)<span class="sc">: .2e}</span></span>
<span id="cb14-62"><a href="#cb14-62"></a><span class="ss">  Gradient difference: </span><span class="sc">{</span>np<span class="sc">.</span>linalg<span class="sc">.</span>norm(grad1 <span class="op">-</span> grad2)<span class="sc">: .2e}</span></span>
<span id="cb14-63"><a href="#cb14-63"></a><span class="ss">  </span></span>
<span id="cb14-64"><a href="#cb14-64"></a><span class="ss">Variable b:</span></span>
<span id="cb14-65"><a href="#cb14-65"></a><span class="ss">  Primal difference: </span><span class="sc">{</span>np<span class="sc">.</span>linalg<span class="sc">.</span>norm(primal3 <span class="op">-</span> primal4)<span class="sc">: .2e}</span></span>
<span id="cb14-66"><a href="#cb14-66"></a><span class="ss">  JVP difference: </span><span class="sc">{</span>np<span class="sc">.</span>linalg<span class="sc">.</span>norm(jvp3 <span class="op">-</span> jvp4)<span class="sc">: .2e}</span></span>
<span id="cb14-67"><a href="#cb14-67"></a><span class="ss">  Gradient difference: </span><span class="sc">{</span>np<span class="sc">.</span>linalg<span class="sc">.</span>norm(grad3 <span class="op">-</span> grad4)<span class="sc">: .2e}</span><span class="ss"> </span></span>
<span id="cb14-68"><a href="#cb14-68"></a><span class="ss">    </span></span>
<span id="cb14-69"><a href="#cb14-69"></a><span class="ss">Variable A and b:</span></span>
<span id="cb14-70"><a href="#cb14-70"></a><span class="ss">  Primal difference: </span><span class="sc">{</span>np<span class="sc">.</span>linalg<span class="sc">.</span>norm(primal5 <span class="op">-</span> primal6)<span class="sc">: .2e}</span></span>
<span id="cb14-71"><a href="#cb14-71"></a><span class="ss">  JVP difference: </span><span class="sc">{</span>np<span class="sc">.</span>linalg<span class="sc">.</span>norm(jvp5 <span class="op">-</span> jvp6)<span class="sc">: .2e}</span></span>
<span id="cb14-72"><a href="#cb14-72"></a><span class="ss">  Gradient difference: </span><span class="sc">{</span>np<span class="sc">.</span>linalg<span class="sc">.</span>norm(grad5 <span class="op">-</span> grad6)<span class="sc">: .2e}</span></span>
<span id="cb14-73"><a href="#cb14-73"></a><span class="ss">  """</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>
Check the plumbing!
Variable A:
  Primal difference:  1.98e-07
  JVP difference:  1.43e-07
  Gradient difference:  0.00e+00
  
Variable b:
  Primal difference:  4.56e-06
  JVP difference:  6.52e-08
  Gradient difference:  9.31e-10 
    
Variable A and b:
  Primal difference:  8.10e-06
  JVP difference:  1.83e-06
  Gradient difference:  1.82e-12
  </code></pre>
</div>
</div>
<p>Yes.</p>
</section>
<section id="why-is-this-better-than-just-differentiating-through-the-cholesky-factorisation" class="level3">
<h3 class="anchored" data-anchor-id="why-is-this-better-than-just-differentiating-through-the-cholesky-factorisation">Why is this better than just differentiating through the Cholesky factorisation?</h3>
<p>The other option for making this work would’ve been to implement the Cholesky factorisation as a primitive (~which we are about to do!~ which we will do another day) and then write the sparse solver directly as a pure JAX function.</p>
<div class="cell" data-execution_count="13">
<div class="sourceCode cell-code" id="cb16"><pre class="sourceCode numberSource python number-lines code-with-copy"><code class="sourceCode python"><span id="cb16-1"><a href="#cb16-1"></a><span class="kw">def</span> sparse_solve_direct(A_indices, A_indptr, A_x, b, <span class="op">*</span>, L_nse <span class="op">=</span> <span class="va">None</span>):</span>
<span id="cb16-2"><a href="#cb16-2"></a>  L_indices, L_indptr, L_x <span class="op">=</span> sparse_cholesky(A_indices, A_indptr, A_x)</span>
<span id="cb16-3"><a href="#cb16-3"></a>  out <span class="op">=</span> sparse_triangular_solve(L_indices, L_indptr, L_x, b)</span>
<span id="cb16-4"><a href="#cb16-4"></a>  <span class="cf">return</span> sparse_triangular_solve(L_indices, L_indptr, L_x, out, transpose <span class="op">=</span> <span class="va">True</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>This function is JAX-traceable<a href="#fn36" class="footnote-ref" id="fnref36" role="doc-noteref"><sup>36</sup></a> and, therefore, we could compute the gradient of it directly. It turns out that this is going to be a bad idea.</p>
<p>Why? Because the derivative of <code>sparse_cholesky</code>, which we would have to chain together with the derivatives from the solver, is pretty complicated. Basically, this means that we’d have to do a lot more work<a href="#fn37" class="footnote-ref" id="fnref37" role="doc-noteref"><sup>37</sup></a> than we do if we just implement the symbolic formula for the derivatives.</p>
</section>
</section>
<section id="primitive-three-the-dreaded-log-determinant" class="level2">
<h2 class="anchored" data-anchor-id="primitive-three-the-dreaded-log-determinant">Primitive three: The dreaded log determinant</h2>
<p>Ok, so now we get to the good one. The log-determinant of <span class="math inline">\(A\)</span>. The first thing that we need to do is wrench out a derivative. This is not as easy as it was for the linear solve. So what follows is a modification for sparse matrices from Appendix A of <a href="https://web.stanford.edu/~boyd/cvxbook/bv_cvxbook.pdf">Boyd’s convex optimisation book</a>.</p>
<p>It’s pretty easy to convince yourself that <span class="math display">\[\begin{align*}
\log(|A + \Delta|) &amp;= \log\left( \left|A^{1/2}(I + A^{-1/2}\Delta A^{-1/2})A^{1/2}\right|\right) \\
&amp;= \log(|A|) + \log\left( \left|I + A^{-1/2}\Delta A^{-1/2}\right|\right).
\end{align*}\]</span></p>
<p>It is harder to convince yourself how this could possibly be a useful fact.</p>
<p>If we write <span class="math inline">\(\lambda_i\)</span>, <span class="math inline">\(i = 1, \ldots, n\)</span> as the eigenvalues of <span class="math inline">\(A^{-1/2}\Delta A^{-1/2}\)</span>, then we have <span class="math display">\[
\log(|A + \Delta |) = \log(|A|) + \sum_{i=1}^n \log( 1 + \lambda_i).
\]</span> Remembering that <span class="math inline">\(\Delta\)</span> is very small, it follows that <span class="math inline">\(A^{-1/2}\Delta A^{-1/2}\)</span> will <em>also</em> be small. That translates to the eigenvalues of <span class="math inline">\(A^{-1/2}\Delta A^{-1/2}\)</span> all being small. Therefore, we can use the approximation <span class="math inline">\(\log(1 + \lambda_i) = \lambda_i + \mathcal{O}(\lambda_i^2)\)</span>.</p>
<p>This means that<a href="#fn38" class="footnote-ref" id="fnref38" role="doc-noteref"><sup>38</sup></a> <span class="math display">\[\begin{align*}
\log(|A + \Delta |) &amp;= \log(|A|) + \sum_{i=1}^n  \lambda_i + \mathcal{O}\left(\|\Delta\|^2\right) \\
&amp;=\log(|A|) + \operatorname{tr}\left(A^{-1/2} \Delta A^{-1} \right) + \mathcal{O}\left(\|\Delta\|^2\right) \\
&amp;= \log(|A|) + \operatorname{tr}\left(A^{-1} \Delta \right) + \mathcal{O}\left(\|\Delta\|^2\right),
\end{align*}\]</span> which follows from the cyclic property of the trace.</p>
<p>If we recall the formula from the last section defining the Jacobian-vector product, in our context <span class="math inline">\(m = 1\)</span>, <span class="math inline">\(x\)</span> is the vector of non-zero entries of the lower triangle of <span class="math inline">\(A\)</span> stacked by column, and <span class="math inline">\(\delta\)</span> is the vector of non-zero entries of the lower triangle of <span class="math inline">\(\Delta\)</span>. That means the Jacobian-vector product is <span class="math display">\[
J(x)\delta = \operatorname{tr}\left(A^{-1} \Delta \right) = \sum_{i=1}^n\sum_{j=1}^n[A^{-1}]_{ij} \Delta_{ij}.
\]</span></p>
<p>Remembering that <span class="math inline">\(\Delta\)</span> is sparse with the same sparsity pattern as <span class="math inline">\(A\)</span>, we see that the Jacobian-vector product requires us to know the values of <span class="math inline">\(A^{-1}\)</span> that correspond to non-zero elements of <span class="math inline">\(A\)</span>. That’s good news because we will see that these entries are relatively cheap and easy to compute. Whereas the full inverse is dense and very expensive to compute.</p>
<p>But before we get to that, I need to point out a trap for young players<a href="#fn39" class="footnote-ref" id="fnref39" role="doc-noteref"><sup>39</sup></a>. Lest your implementations go down faster than me when someone asks politely.</p>
<p>The problem comes from how we store our matrix. A mathematician would suggest that it’s our representation. A physicist<a href="#fn40" class="footnote-ref" id="fnref40" role="doc-noteref"><sup>40</sup></a> would shit on about being coordinate free with such passion that he<a href="#fn41" class="footnote-ref" id="fnref41" role="doc-noteref"><sup>41</sup></a> will keep going even after you quietly leave the room.</p>
<p>The problem is that we only store the non-zero entries of the lower-triangular part of <span class="math inline">\(A\)</span>. This means that <em>we need to be careful</em> that when we compute the Jacobian-vector product that we properly compute the Matrix-vector product.</p>
<p>Let <code>A_indices</code> and <code>A_indptr</code> define the sparsity structure of <span class="math inline">\(A\)</span> (and <span class="math inline">\(\Delta\)</span>). Then if <span class="math inline">\(A_x\)</span> is our input and <span class="math inline">\(v\)</span> is our vector, then we need to do the follow steps to compute the Jacobian-vector product:</p>
<ol type="1">
<li>Compute <code>Ainv_x</code> (aka the non-zero elements of <span class="math inline">\(A^{-1}\)</span> that correspond to the sparsity pattern of <span class="math inline">\(A\)</span>)</li>
<li>Compute the matrix vector product as</li>
</ol>
<div class="cell" data-execution_count="14">
<div class="sourceCode cell-code" id="cb17"><pre class="sourceCode numberSource python number-lines code-with-copy"><code class="sourceCode python"><span id="cb17-1"><a href="#cb17-1"></a>jvp <span class="op">=</span> <span class="dv">2</span> <span class="op">*</span> <span class="bu">sum</span>(Ainv_x <span class="op">*</span> v) <span class="op">-</span> <span class="bu">sum</span>(Ainv_x[A_indptr[:<span class="op">-</span><span class="dv">1</span>]] <span class="op">*</span> v[A_indptr[:<span class="op">-</span><span class="dv">1</span>]])</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>Why does it look like that? Well we need to add the contribution from the upper triangle as well as the lower triangle. And one way to do that is to just double the sum and then subtract off the diagonal terms that we’ve counted twice.</p>
<p>(I’m making a pretty big assumption here, which is fine in our context, that <span class="math inline">\(A\)</span> has a non-zero diagonal. If that doesn’t hold, it’s just a change of the indexing in the second term to just pull out the diagonal terms.)</p>
<p>Using similar reasoning, we can compute the Jacobian as <span class="math display">\[
[J_f(x)]_{i1} = \begin{cases}
\operatorname{partial-inverse}(x)_i, \qquad &amp; x_i  \text{ is a diagonal element of }A \\
2\operatorname{partial-inverse}(x)_i, \qquad &amp; \text{otherwise},
\end{cases}
\]</span> where <span class="math inline">\(\operatorname{partial-inverse}(x)\)</span> is the vector that stacks the columns of the elements of <span class="math inline">\(A^{-1}\)</span> that correspond to the non-zero elements of <span class="math inline">\(A\)</span>. (Yikes!)</p>
<section id="computing-the-partial-inverse" class="level3">
<h3 class="anchored" data-anchor-id="computing-the-partial-inverse">Computing the partial inverse</h3>
<p>So now we need to actually work out how to compute this <em>partial inverse</em> of a symmetric positive definite matrix <span class="math inline">\(A\)</span>. To do this, we are going to steal a technique that goes back to Takahashi, Fagan, and Chen<a href="#fn42" class="footnote-ref" id="fnref42" role="doc-noteref"><sup>42</sup></a> in 1973. (For this presentation, I’m basically pillaging <a href="https://www.sciencedirect.com/science/article/pii/S0378375807000845">Håvard Rue and Sara Martino’s 2007 paper.</a>)</p>
<p>Their idea was that if we write <span class="math inline">\(A = VDV^T\)</span>, where <span class="math inline">\(V\)</span> is a lower-triangular matrix with ones on the diagonal and <span class="math inline">\(D\)</span> is diagonal. This links up with our usual Cholesky factorisation through the identity <span class="math inline">\(L = VD^{1/2}\)</span>. It follows that if <span class="math inline">\(S = A^{-1}\)</span>, then <span class="math inline">\(VDV^TS = I\)</span>. Then, we make some magic manipulations<a href="#fn43" class="footnote-ref" id="fnref43" role="doc-noteref"><sup>43</sup></a>. <span class="math display">\[\begin{align*}
V^TS &amp;= D^{-1}V^{-1} \\
S + V^TS &amp;= S + D^{-1}V^{-1} \\
S &amp;= D^{-1}V^{-1} + (I - V^T)S.
\end{align*}\]</span></p>
<p>Once again, this does not look super-useful. The trick is to notice 2 things.</p>
<ol type="1">
<li><p>Because <span class="math inline">\(V\)</span> is lower triangular, <span class="math inline">\(V^{-1}\)</span> is also lower triangular and the elements of <span class="math inline">\(V^{-1}\)</span> are the inverse of the diagonal elements of <span class="math inline">\(V\)</span> (aka they are all 1). Therefore, <span class="math inline">\(D^{-1}V^{-1}\)</span> is a lower triangular matrix with a diagonal given by the diagonal of <span class="math inline">\(D^{-1}\)</span>.</p></li>
<li><p><span class="math inline">\(I - V^T\)</span> is an upper triangular matrix and <span class="math inline">\([I - V^T]_{nn} = 0\)</span>.</p></li>
</ol>
<p>These two things together lead to the somewhat unexpected situation where the upper triangle of <span class="math inline">\(S = D^{-1}V^{-1} + (I- V^T)S\)</span> defines a set of recursions for the upper triangle of <span class="math inline">\(S\)</span>. (And, therefore, all of <span class="math inline">\(S\)</span> because <span class="math inline">\(S\)</span> is symmetric!) These are sometimes referred to as the Takahashi recursions.</p>
<p>But we don’t want the whole upper triangle of <span class="math inline">\(S\)</span>, we just want the ones that correspond to the non-zero elements of <span class="math inline">\(A\)</span>. Unfortunately, the set of recursions are not, in general, solveable using only that subset of <span class="math inline">\(S\)</span>. But we are in luck: they are solveable using the elements of <span class="math inline">\(S\)</span> that correspond to the non-zeros of <span class="math inline">\(L + L^T\)</span>, which, as we know from a few posts ago, is a superset of the non-zero elements of <span class="math inline">\(A\)</span>!</p>
<p>From this, we get the recursions running from <span class="math inline">\(i = n, \ldots, 1\)</span>, <span class="math inline">\(j = n, \ldots, i\)</span> (the order is important!) such that <span class="math inline">\(L_{ji} \neq 0\)</span> <span class="math display">\[
S_{ji} =   \begin{cases}
\frac{1}{L_{ii}^2} - \frac{1}{L_{ii}}\sum_{k=i+1}^{n} L_{ki} S_{kj} \qquad&amp;  \text{if } i=j, \\         
- \frac{1}{L_{ii}}\sum_{k=i+1}^{n} L_{ki} S_{kj}  &amp; \text{otherwise}.
\end{cases}
\]</span></p>
<p>If you recall our discussion way back when about the way the non-zero structure of the <span class="math inline">\(j\)</span> the column of <span class="math inline">\(L\)</span> relates to the non-zero structure of the <span class="math inline">\(i\)</span> th column for <span class="math inline">\(j \geq i\)</span>, it’s clear that we have computed enough<a href="#fn44" class="footnote-ref" id="fnref44" role="doc-noteref"><sup>44</sup></a> of <span class="math inline">\(S\)</span> at every step to complete the recursions.</p>
<p>Now we just need to Python it. (And thanks to Finn Lindgren who helped me understand how to implement this, which he may or may not remember because it happened about five years ago.)</p>
<p>Actually, we need this to be JAX-traceable, so we are going to implement a very basic primitive. In particular, we don’t need to implement a derivative or anything like that, just an abstract evaluation and an implementation.</p>
<div class="cell" data-execution_count="15">
<div class="sourceCode cell-code" id="cb18"><pre class="sourceCode numberSource python number-lines code-with-copy"><code class="sourceCode python"><span id="cb18-1"><a href="#cb18-1"></a>sparse_partial_inverse_p <span class="op">=</span> core.Primitive(<span class="st">"sparse_partial_inverse"</span>)</span>
<span id="cb18-2"><a href="#cb18-2"></a></span>
<span id="cb18-3"><a href="#cb18-3"></a><span class="kw">def</span> sparse_partial_inverse(L_indices, L_indptr, L_x, out_indices, out_indptr):</span>
<span id="cb18-4"><a href="#cb18-4"></a>  <span class="co">"""</span></span>
<span id="cb18-5"><a href="#cb18-5"></a><span class="co">  Computes the elements (out_indices, out_indptr) of the inverse of a sparse matrix (A_indices, A_indptr, A_x)</span></span>
<span id="cb18-6"><a href="#cb18-6"></a><span class="co">   with Choleksy factor (L_indices, L_indptr, L_x). (out_indices, out_indptr) is assumed to be either</span></span>
<span id="cb18-7"><a href="#cb18-7"></a><span class="co">   the sparsity pattern of A or a subset of it in lower triangular form. </span></span>
<span id="cb18-8"><a href="#cb18-8"></a><span class="co">  """</span></span>
<span id="cb18-9"><a href="#cb18-9"></a>  <span class="cf">return</span> sparse_partial_inverse_p.bind(L_indices, L_indptr, L_x, out_indices, out_indptr)</span>
<span id="cb18-10"><a href="#cb18-10"></a></span>
<span id="cb18-11"><a href="#cb18-11"></a><span class="at">@sparse_partial_inverse_p.def_abstract_eval</span></span>
<span id="cb18-12"><a href="#cb18-12"></a><span class="kw">def</span> sparse_partial_inverse_abstract_eval(L_indices, L_indptr, L_x, out_indices, out_indptr):</span>
<span id="cb18-13"><a href="#cb18-13"></a>  <span class="cf">return</span> abstract_arrays.ShapedArray(out_indices.shape, L_x.dtype)</span>
<span id="cb18-14"><a href="#cb18-14"></a></span>
<span id="cb18-15"><a href="#cb18-15"></a><span class="at">@sparse_partial_inverse_p.def_impl</span></span>
<span id="cb18-16"><a href="#cb18-16"></a><span class="kw">def</span> sparse_partial_inverse_impl(L_indices, L_indptr, L_x, out_indices, out_indptr):</span>
<span id="cb18-17"><a href="#cb18-17"></a>  n <span class="op">=</span> <span class="bu">len</span>(L_indptr) <span class="op">-</span> <span class="dv">1</span></span>
<span id="cb18-18"><a href="#cb18-18"></a>  Linv <span class="op">=</span> sparse.dok_array((n,n), dtype <span class="op">=</span> L_x.dtype)</span>
<span id="cb18-19"><a href="#cb18-19"></a>  counter <span class="op">=</span> <span class="bu">len</span>(L_x) <span class="op">-</span> <span class="dv">1</span></span>
<span id="cb18-20"><a href="#cb18-20"></a>  <span class="cf">for</span> col <span class="kw">in</span> <span class="bu">range</span>(n<span class="op">-</span><span class="dv">1</span>, <span class="op">-</span><span class="dv">1</span>, <span class="op">-</span><span class="dv">1</span>):</span>
<span id="cb18-21"><a href="#cb18-21"></a>    <span class="cf">for</span> row <span class="kw">in</span> L_indices[L_indptr[col]:L_indptr[col<span class="op">+</span><span class="dv">1</span>]][::<span class="op">-</span><span class="dv">1</span>]:</span>
<span id="cb18-22"><a href="#cb18-22"></a>      <span class="cf">if</span> row <span class="op">!=</span> col:</span>
<span id="cb18-23"><a href="#cb18-23"></a>        Linv[row, col] <span class="op">=</span> Linv[col, row] <span class="op">=</span> <span class="fl">0.0</span></span>
<span id="cb18-24"><a href="#cb18-24"></a>      <span class="cf">else</span>:</span>
<span id="cb18-25"><a href="#cb18-25"></a>        Linv[row, col] <span class="op">=</span> <span class="dv">1</span> <span class="op">/</span> L_x[L_indptr[col]]<span class="op">**</span><span class="dv">2</span></span>
<span id="cb18-26"><a href="#cb18-26"></a>      L_col  <span class="op">=</span> L_x[L_indptr[col]<span class="op">+</span><span class="dv">1</span>:L_indptr[col<span class="op">+</span><span class="dv">1</span>]] <span class="op">/</span> L_x[L_indptr[col]]</span>
<span id="cb18-27"><a href="#cb18-27"></a> </span>
<span id="cb18-28"><a href="#cb18-28"></a>      <span class="cf">for</span> k, L_kcol <span class="kw">in</span> <span class="bu">zip</span>(L_indices[L_indptr[col]<span class="op">+</span><span class="dv">1</span>:L_indptr[col<span class="op">+</span><span class="dv">1</span>]], L_col):</span>
<span id="cb18-29"><a href="#cb18-29"></a>         Linv[col,row] <span class="op">=</span> Linv[row,col] <span class="op">=</span>  Linv[row, col] <span class="op">-</span>  L_kcol <span class="op">*</span> Linv[k, row]</span>
<span id="cb18-30"><a href="#cb18-30"></a>        </span>
<span id="cb18-31"><a href="#cb18-31"></a>  Linv_x <span class="op">=</span> sparse.tril(Linv, <span class="bu">format</span> <span class="op">=</span> <span class="st">"csc"</span>).data</span>
<span id="cb18-32"><a href="#cb18-32"></a>  <span class="cf">if</span> <span class="bu">len</span>(out_indices) <span class="op">==</span> <span class="bu">len</span>(L_indices):</span>
<span id="cb18-33"><a href="#cb18-33"></a>    <span class="cf">return</span> Linv_x</span>
<span id="cb18-34"><a href="#cb18-34"></a></span>
<span id="cb18-35"><a href="#cb18-35"></a>  out_x <span class="op">=</span> np.zeros(<span class="bu">len</span>(out_indices))</span>
<span id="cb18-36"><a href="#cb18-36"></a>  <span class="cf">for</span> col <span class="kw">in</span> <span class="bu">range</span>(n):</span>
<span id="cb18-37"><a href="#cb18-37"></a>    ind <span class="op">=</span> np.nonzero(np.in1d(L_indices[L_indptr[col]:L_indptr[col<span class="op">+</span><span class="dv">1</span>]],</span>
<span id="cb18-38"><a href="#cb18-38"></a>      out_indices[out_indptr[col]:out_indptr[col<span class="op">+</span><span class="dv">1</span>]]))[<span class="dv">0</span>]</span>
<span id="cb18-39"><a href="#cb18-39"></a>    out_x[out_indptr[col]:out_indptr[col<span class="op">+</span><span class="dv">1</span>]] <span class="op">=</span> Linv_x[L_indptr[col] <span class="op">+</span> ind]</span>
<span id="cb18-40"><a href="#cb18-40"></a>  <span class="cf">return</span> out_x</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>The implementation makes use of the<a href="#fn45" class="footnote-ref" id="fnref45" role="doc-noteref"><sup>45</sup></a> <em>dictionary of keys</em> representation of a sparse matrix from <code>scipy.sparse</code>. This is an efficient storage scheme when you need to modify the sparsity structure (as we are doing here) or do a lot of indexing. It would definitely be possible to implement this directly on the CSC data structure, but it gets a little bit tricky to access the elements of <code>L_inv</code> that are above the diagonal. The resulting code is honestly a mess and there’s lots of non-local memory access anyway, so I implemented it this way.</p>
<p>But let’s be honest: this thing is crying out for a proper symmetric matrix class with sensible reverse iterators. But hey. Python.</p>
<p>The second chunk of the code is just the opposite of our <code>_structured_copy()</code> function. It takes a matrix with the sparsity pattern of <span class="math inline">\(L\)</span> and returns one with the sparsity pattern of <code>out</code> (which is assumed to be a subset, and is usually the sparsity pattern of <span class="math inline">\(A\)</span> or a diagonal matrix).</p>
<p>Let’s check that it works.</p>
<div class="cell" data-execution_count="16">
<div class="sourceCode cell-code" id="cb19"><pre class="sourceCode numberSource python number-lines code-with-copy"><code class="sourceCode python"><span id="cb19-1"><a href="#cb19-1"></a>A_indices, A_indptr, A_x, A <span class="op">=</span> make_matrix(<span class="dv">15</span>)</span>
<span id="cb19-2"><a href="#cb19-2"></a>n <span class="op">=</span> <span class="bu">len</span>(A_indptr) <span class="op">-</span> <span class="dv">1</span></span>
<span id="cb19-3"><a href="#cb19-3"></a></span>
<span id="cb19-4"><a href="#cb19-4"></a></span>
<span id="cb19-5"><a href="#cb19-5"></a>L_indices, L_indptr, L_x <span class="op">=</span> sparse_cholesky(A_indices, A_indptr, A_x)</span>
<span id="cb19-6"><a href="#cb19-6"></a></span>
<span id="cb19-7"><a href="#cb19-7"></a>a_inv_L <span class="op">=</span> sparse_partial_inverse(L_indices, L_indptr, L_x, L_indices, L_indptr)</span>
<span id="cb19-8"><a href="#cb19-8"></a></span>
<span id="cb19-9"><a href="#cb19-9"></a>col_counts_L <span class="op">=</span> [L_indptr[i<span class="op">+</span><span class="dv">1</span>] <span class="op">-</span> L_indptr[i] <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(n)]</span>
<span id="cb19-10"><a href="#cb19-10"></a>cols_L <span class="op">=</span> np.repeat(<span class="bu">range</span>(n), col_counts_L)</span>
<span id="cb19-11"><a href="#cb19-11"></a></span>
<span id="cb19-12"><a href="#cb19-12"></a>true_inv <span class="op">=</span> np.linalg.inv(A.todense())</span>
<span id="cb19-13"><a href="#cb19-13"></a>truth_L <span class="op">=</span> true_inv[L_indices, cols_L]</span>
<span id="cb19-14"><a href="#cb19-14"></a></span>
<span id="cb19-15"><a href="#cb19-15"></a>a_inv_A <span class="op">=</span> sparse_partial_inverse(L_indices, L_indptr, L_x, A_indices, A_indptr)</span>
<span id="cb19-16"><a href="#cb19-16"></a>col_counts_A <span class="op">=</span> [A_indptr[i<span class="op">+</span><span class="dv">1</span>] <span class="op">-</span> A_indptr[i] <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(n)]</span>
<span id="cb19-17"><a href="#cb19-17"></a>cols_A <span class="op">=</span> np.repeat(<span class="bu">range</span>(n), col_counts_A)</span>
<span id="cb19-18"><a href="#cb19-18"></a>truth_A <span class="op">=</span> true_inv[A_indices, cols_A]</span>
<span id="cb19-19"><a href="#cb19-19"></a></span>
<span id="cb19-20"><a href="#cb19-20"></a><span class="bu">print</span>(<span class="ss">f"""</span></span>
<span id="cb19-21"><a href="#cb19-21"></a><span class="ss">Error in partial inverse (all of L): </span><span class="sc">{</span>np<span class="sc">.</span>linalg<span class="sc">.</span>norm(a_inv_L <span class="op">-</span> truth_L)<span class="sc">: .2e}</span></span>
<span id="cb19-22"><a href="#cb19-22"></a><span class="ss">Error in partial inverse (all of A): </span><span class="sc">{</span>np<span class="sc">.</span>linalg<span class="sc">.</span>norm(a_inv_A <span class="op">-</span> truth_A)<span class="sc">: .2e}</span></span>
<span id="cb19-23"><a href="#cb19-23"></a><span class="ss">"""</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>
Error in partial inverse (all of L):  1.57e-15
Error in partial inverse (all of A):  1.53e-15
</code></pre>
</div>
</div>
</section>
<section id="putting-the-log-determinant-together" class="level3">
<h3 class="anchored" data-anchor-id="putting-the-log-determinant-together">Putting the log-determinant together</h3>
<p>All of our bits are in place, so now all we need is to implement the primitive for the log-determinant. One nice thing here is that we don’t need to implement a transposition rule as the function is not structurally linear in any of its arguments. At this point we take our small wins where we can get them.</p>
<p>There isn’t anything particularly interesting in the implementation. But do note that the trace has been implemented in a way that’s aware that we’re only storing the bottom triangle of <span class="math inline">\(A\)</span>.</p>
<div class="cell" data-execution_count="17">
<div class="sourceCode cell-code" id="cb21"><pre class="sourceCode numberSource python number-lines code-with-copy"><code class="sourceCode python"><span id="cb21-1"><a href="#cb21-1"></a>sparse_log_det_p <span class="op">=</span> core.Primitive(<span class="st">"sparse_log_det"</span>)</span>
<span id="cb21-2"><a href="#cb21-2"></a></span>
<span id="cb21-3"><a href="#cb21-3"></a><span class="kw">def</span> sparse_log_det(A_indices, A_indptr, A_x):</span>
<span id="cb21-4"><a href="#cb21-4"></a>  <span class="cf">return</span> sparse_log_det_p.bind(A_indices, A_indptr, A_x)</span>
<span id="cb21-5"><a href="#cb21-5"></a></span>
<span id="cb21-6"><a href="#cb21-6"></a><span class="at">@sparse_log_det_p.def_impl</span></span>
<span id="cb21-7"><a href="#cb21-7"></a><span class="kw">def</span> sparse_log_det_impl(A_indices, A_indptr, A_x):</span>
<span id="cb21-8"><a href="#cb21-8"></a>  L_indices, L_indptr, L_x <span class="op">=</span> sparse_cholesky(A_indices, A_indptr, A_x)</span>
<span id="cb21-9"><a href="#cb21-9"></a>  <span class="cf">return</span> <span class="fl">2.0</span> <span class="op">*</span> jnp.<span class="bu">sum</span>(jnp.log(L_x[L_indptr[:<span class="op">-</span><span class="dv">1</span>]]))</span>
<span id="cb21-10"><a href="#cb21-10"></a></span>
<span id="cb21-11"><a href="#cb21-11"></a><span class="at">@sparse_log_det_p.def_abstract_eval</span></span>
<span id="cb21-12"><a href="#cb21-12"></a><span class="kw">def</span> sparse_log_det_abstract_eval(A_indices, A_indptr, A_x):</span>
<span id="cb21-13"><a href="#cb21-13"></a>  <span class="cf">return</span> abstract_arrays.ShapedArray((<span class="dv">1</span>,), A_x.dtype)</span>
<span id="cb21-14"><a href="#cb21-14"></a></span>
<span id="cb21-15"><a href="#cb21-15"></a><span class="kw">def</span> sparse_log_det_value_and_jvp(arg_values, arg_tangent):</span>
<span id="cb21-16"><a href="#cb21-16"></a>  A_indices, A_indptr, A_x <span class="op">=</span> arg_values</span>
<span id="cb21-17"><a href="#cb21-17"></a>  _, _, A_xt <span class="op">=</span> arg_tangent</span>
<span id="cb21-18"><a href="#cb21-18"></a>  L_indices, L_indptr, L_x <span class="op">=</span> sparse_cholesky(A_indices, A_indptr, A_x)</span>
<span id="cb21-19"><a href="#cb21-19"></a>  value <span class="op">=</span> <span class="fl">2.0</span> <span class="op">*</span> jnp.<span class="bu">sum</span>(jnp.log(L_x[L_indptr[:<span class="op">-</span><span class="dv">1</span>]]))</span>
<span id="cb21-20"><a href="#cb21-20"></a>  Ainv_x <span class="op">=</span> sparse_partial_inverse(L_indices, L_indptr, L_x, A_indices, A_indptr)</span>
<span id="cb21-21"><a href="#cb21-21"></a>  jvp <span class="op">=</span> <span class="fl">2.0</span> <span class="op">*</span> <span class="bu">sum</span>(Ainv_x <span class="op">*</span> A_xt) <span class="op">-</span> <span class="bu">sum</span>(Ainv_x[A_indptr[:<span class="op">-</span><span class="dv">1</span>]] <span class="op">*</span> A_xt[A_indptr[:<span class="op">-</span><span class="dv">1</span>]])</span>
<span id="cb21-22"><a href="#cb21-22"></a>  <span class="cf">return</span> value, jvp</span>
<span id="cb21-23"><a href="#cb21-23"></a></span>
<span id="cb21-24"><a href="#cb21-24"></a>ad.primitive_jvps[sparse_log_det_p] <span class="op">=</span> sparse_log_det_value_and_jvp</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>Finally, we can test it out.</p>
<div class="cell" data-execution_count="18">
<div class="sourceCode cell-code" id="cb22"><pre class="sourceCode numberSource python number-lines code-with-copy"><code class="sourceCode python"><span id="cb22-1"><a href="#cb22-1"></a>ld_true <span class="op">=</span> np.log(np.linalg.det(A.todense())) <span class="co">#np.sum(np.log(lu.U.diagonal()))</span></span>
<span id="cb22-2"><a href="#cb22-2"></a><span class="bu">print</span>(<span class="ss">f"Error in log-determinant = </span><span class="sc">{</span>ld_true <span class="op">-</span> sparse_log_det(A_indices, A_indptr, A_x)<span class="sc">: .2e}</span><span class="ss">"</span>)</span>
<span id="cb22-3"><a href="#cb22-3"></a></span>
<span id="cb22-4"><a href="#cb22-4"></a><span class="kw">def</span> f(theta):</span>
<span id="cb22-5"><a href="#cb22-5"></a>  Ax_theta <span class="op">=</span> jnp.array(theta[<span class="dv">0</span>] <span class="op">*</span> A_x) <span class="op">/</span> n</span>
<span id="cb22-6"><a href="#cb22-6"></a>  Ax_theta <span class="op">=</span> Ax_theta.at[A_indptr[:<span class="op">-</span><span class="dv">1</span>]].add(theta[<span class="dv">1</span>])</span>
<span id="cb22-7"><a href="#cb22-7"></a>  <span class="cf">return</span> sparse_log_det(A_indices, A_indptr, Ax_theta)</span>
<span id="cb22-8"><a href="#cb22-8"></a></span>
<span id="cb22-9"><a href="#cb22-9"></a><span class="kw">def</span> f_jax(theta):</span>
<span id="cb22-10"><a href="#cb22-10"></a>  Ax_theta <span class="op">=</span> jnp.array(theta[<span class="dv">0</span>] <span class="op">*</span> A.todense()) <span class="op">/</span> n </span>
<span id="cb22-11"><a href="#cb22-11"></a>  Ax_theta <span class="op">=</span> Ax_theta.at[np.arange(n),np.arange(n)].add(theta[<span class="dv">1</span>])</span>
<span id="cb22-12"><a href="#cb22-12"></a>  L <span class="op">=</span> jnp.linalg.cholesky(Ax_theta)</span>
<span id="cb22-13"><a href="#cb22-13"></a>  <span class="cf">return</span> <span class="fl">2.0</span><span class="op">*</span>jnp.<span class="bu">sum</span>(jnp.log(jnp.diag(L)))</span>
<span id="cb22-14"><a href="#cb22-14"></a></span>
<span id="cb22-15"><a href="#cb22-15"></a>primal1, jvp1 <span class="op">=</span> jvp(f, (jnp.array([<span class="fl">2.</span>, <span class="fl">3.</span>]),), (jnp.array([<span class="fl">1.</span>, <span class="fl">2.</span>]),))</span>
<span id="cb22-16"><a href="#cb22-16"></a>primal2, jvp2 <span class="op">=</span> jvp(f_jax, (jnp.array([<span class="fl">2.</span>, <span class="fl">3.</span>]),), (jnp.array([<span class="fl">1.</span>, <span class="fl">2.</span>]),))</span>
<span id="cb22-17"><a href="#cb22-17"></a></span>
<span id="cb22-18"><a href="#cb22-18"></a>eps <span class="op">=</span> <span class="fl">1e-4</span></span>
<span id="cb22-19"><a href="#cb22-19"></a>jvp_fd <span class="op">=</span> (f(jnp.array([<span class="fl">2.</span>,<span class="fl">3.</span>]) <span class="op">+</span> eps <span class="op">*</span> jnp.array([<span class="fl">1.</span>, <span class="fl">2.</span>]) ) <span class="op">-</span> f(jnp.array([<span class="fl">2.</span>,<span class="fl">3.</span>]))) <span class="op">/</span> eps</span>
<span id="cb22-20"><a href="#cb22-20"></a></span>
<span id="cb22-21"><a href="#cb22-21"></a>grad1 <span class="op">=</span> grad(f)(jnp.array([<span class="fl">2.</span>, <span class="fl">3.</span>]))</span>
<span id="cb22-22"><a href="#cb22-22"></a>grad2 <span class="op">=</span> grad(f_jax)(jnp.array([<span class="fl">2.</span>, <span class="fl">3.</span>]))</span>
<span id="cb22-23"><a href="#cb22-23"></a></span>
<span id="cb22-24"><a href="#cb22-24"></a><span class="bu">print</span>(<span class="ss">f"""</span></span>
<span id="cb22-25"><a href="#cb22-25"></a><span class="ss">Check the Derivatives!</span></span>
<span id="cb22-26"><a href="#cb22-26"></a><span class="ss">Variable A:</span></span>
<span id="cb22-27"><a href="#cb22-27"></a><span class="ss">  Primal difference: </span><span class="sc">{</span>np<span class="sc">.</span>linalg<span class="sc">.</span>norm(primal1 <span class="op">-</span> primal2)<span class="sc">}</span></span>
<span id="cb22-28"><a href="#cb22-28"></a><span class="ss">  JVP difference: </span><span class="sc">{</span>np<span class="sc">.</span>linalg<span class="sc">.</span>norm(jvp1 <span class="op">-</span> jvp2)<span class="sc">}</span></span>
<span id="cb22-29"><a href="#cb22-29"></a><span class="ss">  JVP difference (FD): </span><span class="sc">{</span>np<span class="sc">.</span>linalg<span class="sc">.</span>norm(jvp1 <span class="op">-</span> jvp_fd)<span class="sc">}</span></span>
<span id="cb22-30"><a href="#cb22-30"></a><span class="ss">  Gradient difference: </span><span class="sc">{</span>np<span class="sc">.</span>linalg<span class="sc">.</span>norm(grad1 <span class="op">-</span> grad2)<span class="sc">}</span></span>
<span id="cb22-31"><a href="#cb22-31"></a><span class="ss">"""</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>Error in log-determinant =  0.00e+00</code></pre>
</div>
<div class="cell-output cell-output-stdout">
<pre><code>
Check the Derivatives!
Variable A:
  Primal difference: 0.0
  JVP difference: 0.000885009765625
  JVP difference (FD): 0.221893310546875
  Gradient difference: 1.526623782410752e-05
</code></pre>
</div>
</div>
<p>I’m not going to lie, I am <em>not happy</em> with that JVP difference. I was somewhat concerned that there was a bug somewhere in my code. I did a little bit of exploring and the error got larger as the problem got larger. It also depended a little bit more than I was comfortable on how I had implemented<a href="#fn46" class="footnote-ref" id="fnref46" role="doc-noteref"><sup>46</sup></a> the baseline dense version.</p>
<p>That second fact suggested to me that it might be a floating point problem. By default, JAX uses single precision (32-bit) floating point. Most modern systems that don’t try and run on GPUs use double precision (64-bit) floating point. So I tried it with double precision and lo and behold, the problem disappears.</p>
<p>Matrix factorisations are bloody hard in single precision.</p>
<div class="cell" data-execution_count="19">
<div class="sourceCode cell-code" id="cb25"><pre class="sourceCode numberSource python number-lines code-with-copy"><code class="sourceCode python"><span id="cb25-1"><a href="#cb25-1"></a><span class="im">from</span> jax.config <span class="im">import</span> config</span>
<span id="cb25-2"><a href="#cb25-2"></a>config.update(<span class="st">"jax_enable_x64"</span>, <span class="va">True</span>)</span>
<span id="cb25-3"><a href="#cb25-3"></a></span>
<span id="cb25-4"><a href="#cb25-4"></a>ld_true <span class="op">=</span> np.log(np.linalg.det(A.todense())) <span class="co">#np.sum(np.log(lu.U.diagonal()))</span></span>
<span id="cb25-5"><a href="#cb25-5"></a><span class="bu">print</span>(<span class="ss">f"Error in log-determinant = </span><span class="sc">{</span>ld_true <span class="op">-</span> sparse_log_det(A_indices, A_indptr, A_x)<span class="sc">: .2e}</span><span class="ss">"</span>)</span>
<span id="cb25-6"><a href="#cb25-6"></a></span>
<span id="cb25-7"><a href="#cb25-7"></a><span class="kw">def</span> f(theta):</span>
<span id="cb25-8"><a href="#cb25-8"></a>  Ax_theta <span class="op">=</span> jnp.array(theta[<span class="dv">0</span>] <span class="op">*</span> A_x, dtype <span class="op">=</span> jnp.float64) <span class="op">/</span> n</span>
<span id="cb25-9"><a href="#cb25-9"></a>  Ax_theta <span class="op">=</span> Ax_theta.at[A_indptr[:<span class="op">-</span><span class="dv">1</span>]].add(theta[<span class="dv">1</span>])</span>
<span id="cb25-10"><a href="#cb25-10"></a>  <span class="cf">return</span> sparse_log_det(A_indices, A_indptr, Ax_theta)</span>
<span id="cb25-11"><a href="#cb25-11"></a></span>
<span id="cb25-12"><a href="#cb25-12"></a><span class="kw">def</span> f_jax(theta):</span>
<span id="cb25-13"><a href="#cb25-13"></a>  Ax_theta <span class="op">=</span> jnp.array(theta[<span class="dv">0</span>] <span class="op">*</span> A.todense(), dtype <span class="op">=</span> jnp.float64) <span class="op">/</span> n </span>
<span id="cb25-14"><a href="#cb25-14"></a>  Ax_theta <span class="op">=</span> Ax_theta.at[np.arange(n),np.arange(n)].add(theta[<span class="dv">1</span>])</span>
<span id="cb25-15"><a href="#cb25-15"></a>  L <span class="op">=</span> jnp.linalg.cholesky(Ax_theta)</span>
<span id="cb25-16"><a href="#cb25-16"></a>  <span class="cf">return</span> <span class="fl">2.0</span><span class="op">*</span>jnp.<span class="bu">sum</span>(jnp.log(jnp.diag(L)))</span>
<span id="cb25-17"><a href="#cb25-17"></a></span>
<span id="cb25-18"><a href="#cb25-18"></a>primal1, jvp1 <span class="op">=</span> jvp(f, (jnp.array([<span class="fl">2.</span>, <span class="fl">3.</span>], dtype <span class="op">=</span> jnp.float64),), (jnp.array([<span class="fl">1.</span>, <span class="fl">2.</span>], dtype <span class="op">=</span> jnp.float64),))</span>
<span id="cb25-19"><a href="#cb25-19"></a>primal2, jvp2 <span class="op">=</span> jvp(f_jax, (jnp.array([<span class="fl">2.</span>, <span class="fl">3.</span>], dtype <span class="op">=</span> jnp.float64),), (jnp.array([<span class="fl">1.</span>, <span class="fl">2.</span>], dtype <span class="op">=</span> jnp.float64),))</span>
<span id="cb25-20"><a href="#cb25-20"></a></span>
<span id="cb25-21"><a href="#cb25-21"></a>eps <span class="op">=</span> <span class="fl">1e-7</span></span>
<span id="cb25-22"><a href="#cb25-22"></a>jvp_fd <span class="op">=</span> (f(jnp.array([<span class="fl">2.</span>,<span class="fl">3.</span>], dtype <span class="op">=</span> jnp.float64) <span class="op">+</span> eps <span class="op">*</span> jnp.array([<span class="fl">1.</span>, <span class="fl">2.</span>], dtype <span class="op">=</span> jnp.float64) ) <span class="op">-</span> f(jnp.array([<span class="fl">2.</span>,<span class="fl">3.</span>], dtype <span class="op">=</span> jnp.float64))) <span class="op">/</span> eps</span>
<span id="cb25-23"><a href="#cb25-23"></a></span>
<span id="cb25-24"><a href="#cb25-24"></a>grad1 <span class="op">=</span> grad(f)(jnp.array([<span class="fl">2.</span>, <span class="fl">3.</span>], dtype <span class="op">=</span> jnp.float64))</span>
<span id="cb25-25"><a href="#cb25-25"></a>grad2 <span class="op">=</span> grad(f_jax)(jnp.array([<span class="fl">2.</span>, <span class="fl">3.</span>], dtype <span class="op">=</span> jnp.float64))</span>
<span id="cb25-26"><a href="#cb25-26"></a></span>
<span id="cb25-27"><a href="#cb25-27"></a><span class="bu">print</span>(<span class="ss">f"""</span></span>
<span id="cb25-28"><a href="#cb25-28"></a><span class="ss">Check the Derivatives!</span></span>
<span id="cb25-29"><a href="#cb25-29"></a><span class="ss">Variable A:</span></span>
<span id="cb25-30"><a href="#cb25-30"></a><span class="ss">  Primal difference: </span><span class="sc">{</span>np<span class="sc">.</span>linalg<span class="sc">.</span>norm(primal1 <span class="op">-</span> primal2)<span class="sc">}</span></span>
<span id="cb25-31"><a href="#cb25-31"></a><span class="ss">  JVP difference: </span><span class="sc">{</span>np<span class="sc">.</span>linalg<span class="sc">.</span>norm(jvp1 <span class="op">-</span> jvp2)<span class="sc">}</span></span>
<span id="cb25-32"><a href="#cb25-32"></a><span class="ss">  JVP difference (FD): </span><span class="sc">{</span>np<span class="sc">.</span>linalg<span class="sc">.</span>norm(jvp1 <span class="op">-</span> jvp_fd)<span class="sc">}</span></span>
<span id="cb25-33"><a href="#cb25-33"></a><span class="ss">  Gradient difference: </span><span class="sc">{</span>np<span class="sc">.</span>linalg<span class="sc">.</span>norm(grad1 <span class="op">-</span> grad2)<span class="sc">}</span></span>
<span id="cb25-34"><a href="#cb25-34"></a><span class="ss">"""</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>Error in log-determinant =  0.00e+00</code></pre>
</div>
<div class="cell-output cell-output-stdout">
<pre><code>
Check the Derivatives!
Variable A:
  Primal difference: 0.0
  JVP difference: 8.526512829121202e-13
  JVP difference (FD): 4.171707900013644e-06
  Gradient difference: 8.881784197001252e-16
</code></pre>
</div>
</div>
<p>Much better!</p>
</section>
</section>
<section id="wrapping-up" class="level2">
<h2 class="anchored" data-anchor-id="wrapping-up">Wrapping up</h2>
<p>And that is where we will leave it for today. Next up, I’m probably going to need to do the autodiff for the Cholesky factorisation. It’s not <em>hard</em>, but it is tedious<a href="#fn47" class="footnote-ref" id="fnref47" role="doc-noteref"><sup>47</sup></a> and this post is already very long.</p>
<p>After that we need a few more things:</p>
<ol type="1">
<li><p>Compilation rules for all of these things. For the most part, we can just wrap the relevant parts of <a href="https://github.com/libigl/eigen">Eigen</a>. The only non-trivial code would be the partial inverse. That will allow us to JIT shit.</p></li>
<li><p>We need to beef up the sparse matrix class a little. In particular, we are going to need addition and scalar multiplication at the very minimum to make this useful.</p></li>
<li><p>Work out how <a href="https://aesara.readthedocs.io/en/latest/">Aesara</a> works so we can try to prototype a PyMC model.</p></li>
</ol>
<p>That will be <em>a lot</em> more blog posts. But I’m having fun. So why the hell not.</p>


</section>


<div id="quarto-appendix" class="default"><section id="footnotes" class="footnotes footnotes-end-of-document" role="doc-endnotes"><h2 class="anchored quarto-appendix-heading">Footnotes</h2>

<ol>
<li id="fn1"><p>I am sorry Cholesky factorisation, this blog is already too long and there is simply too much code I need to make nicer to even start on that journey. So it will happen in a later blog.<a href="#fnref1" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn2"><p>Which I have spent <em>zero</em> effort making pretty or taking to any level above scratch code<a href="#fnref2" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn3"><p>Like making it clear how this works for a <em>sparse</em> matrix compared to a general one<a href="#fnref3" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn4"><p>To the best of my knowledge, for example, we don’t know how to differentiate with respect to the order parameter <span class="math inline">\(\nu\)</span> in the modified Bessel function of the second kind <span class="math inline">\(K_\nu(x)\)</span>. This is important in spatial statistics (and general GP stuff).<a href="#fnref4" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn5"><p><em>You</em> may need to convince yourself that this is possible. But it is. The cone of SPD matrices is very nice.<a href="#fnref5" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn6"><p>Don’t despair if you don’t recognise the third line, it’s the Neumann series, which gives an approximation to <span class="math inline">\((I + B)^{-1}\)</span> whenever <span class="math inline">\(\|B\| \ll 1\)</span>.<a href="#fnref6" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn7"><p>I recognise that I’ve not explained why everything needs to be JAX-traceable. Basically it’s because JAX does clever transformations to the Jacobian-vector product code to produce things like gradients. And the only way that can happen is if the JVP code can take abstract JAX types. So we need to make it traceable because we <em>really</em> want to have gradients!<a href="#fnref7" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn8"><p>Why not now, Daniel? Why not now? Well mostly because I might need to do some tweaking down the line, so I am not messing around until I am done.<a href="#fnref8" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn9"><p>This is the primary difference between implementing forward mode and reverse mode: there is only one output here. When we move onto reverse mode, we will output a tuple Jacobian-transpose-vector products, one for each input. You can see the structure of that reflected in the transposition rule we are going to write later.<a href="#fnref9" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn10"><p>Some things: Firstly your function needs to have the correct signature for this to work. Secondly, you could also use <code>ad.defjvp()</code> if you didn’t need to use the primal value to define the tangent (recall one of our tangents is <span class="math inline">\(A^{-1}\Delta c\)</span>, where <span class="math inline">\(c = A^{-1}b\)</span> is the primal value).<a href="#fnref10" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn11"><p>This is because it is the efficient way of computing a gradient. Forward-mode autodiff chains together Jacobian-vector products in such a way that a single sweep of the entire function computes a single directional derivative. Reverse-mode autodiff chains together Jacobian-transpose-vector products (aka vector-Jacobian products) in such a way that a single sweep produces an entire gradient. (This happens at the cost of quite a bit of storage.) Depending on what you are trying to do, you usually want one or the other (or sometimes a clever combination of both).<a href="#fnref11" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn12"><p>or gradients or some sort of thing.<a href="#fnref12" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn13"><p>to be honest, in Stan we sometimes just don’t dick around with the forward-mode autodiff, because gradients are our bread and butter.<a href="#fnref13" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn14"><p>I mean, love you programming language people. But fuck me this paper could’ve been written in Babylonic cuneiform for all I understood it.<a href="#fnref14" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn15"><p>That is, if you fix a value of <span class="math inline">\(y\)</span>, <span class="math inline">\(f_y(x) = f(x, y)\)</span> is not an affine function.<a href="#fnref15" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn16"><p>Details bore me.<a href="#fnref16" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn17"><p>In general, there might need to be a little bit of reshaping, but it’s equivalent.<a href="#fnref17" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn18"><p>Have you noticed this is like the third name I’ve used for this equivalent concept. Or the fourth? The code calls it a cotangent because that’s another damn synonym. I’m so very sorry.<a href="#fnref18" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn19"><p>not difficult, I’m just lazy and Mike does it better that I can. Read his paper.<a href="#fnref19" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn20"><p>For sparse matrices it’s just the non-zero mask of that.<a href="#fnref20" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn21"><p>Yes. I know. Central differences. I am what I am.<a href="#fnref21" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn22"><p>Some of the stuff I’ve done like normalising all of the inputs would help make these tests more stable. You should also just pick up Nick Higham’s backwards error analysis book to get some ideas of what your guarantees actually are in floating point, but I truly cannot be bothered. This is scratch code.<a href="#fnref22" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn23"><p>It should be slightly bigger, it isn’t.<a href="#fnref23" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn24"><p>The largest number <span class="math inline">\(\epsilon\)</span> such that <code>float(1.0) == float(1.0 + machine_eps)</code> in single precision floating point.<a href="#fnref24" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn25"><p>Fun fact: I implemented this and the error never spawned, so I guess JAX is keeping the index arrays concrete, which is very nice of it!<a href="#fnref25" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn26"><p>actual damn numbers<a href="#fnref26" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn27"><p>We want that <a href="https://youtu.be/wrnUJoj14ag?t=288">auld triangle to go jingle bloody jangle</a><a href="#fnref27" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn28"><p>We definitely do not want someone to write an eight hour, two part play that really seems to have the point of view that our Cholesky triangle deserved his downfall. Espoused while periodically reading deadshit tumblr posts. I mean, it would win a Tony. But we still do not want that.<a href="#fnref28" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn29"><p>There are more arguments. Read the help. This is what we need<a href="#fnref29" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn30"><p>What if I told you that this would work perfectly well if <span class="math inline">\(A\)</span> was a linear partial differential operator or an integral operator? Probably not much because why would you give a shit?<a href="#fnref30" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn31"><p>It can be more general, but it isn’t<a href="#fnref31" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn32"><p>I think there is a typo in the docs<a href="#fnref32" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn33"><p>Full disclosure: I screwed this up multiple times today and my tests caught it. What does that look like? The derivatives for <span class="math inline">\(A\)</span> being off, but everything else being good.<a href="#fnref33" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn34"><p>And some optional keyword arguments, but we don’t need to worry about those<a href="#fnref34" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn35"><p>This is not quite the same but similar to something that functional programming people call <em>currying</em>, which was named after famous Australian Olympic swimmer Lisa Curry.<a href="#fnref35" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn36"><p>and a shitload simpler!<a href="#fnref36" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn37"><p>And we have to store a bunch more. This is less of a big deal when <span class="math inline">\(L\)</span> is sparse, but for an ordinary linear solve, we’d be hauling around an extra <span class="math inline">\(\mathcal{O}(n^2)\)</span> floats containing tangents for no good reason.<a href="#fnref37" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn38"><p>If you are worrying about the suppressed constant, remember that <span class="math inline">\(A\)</span> (and therefore <span class="math inline">\(n\)</span> and <span class="math inline">\(\|A\|\)</span>) is fixed.<a href="#fnref38" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn39"><p>I think I’ve made this mistake about four times already while writing this blog. So I am going to write it <em>out</em>.<a href="#fnref39" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn40"><p>Not to “some of my best friends are physicists”, but I do love them. I just wished a man would talk about me the way they talk about being coordinate free. Rather than with the same ambivalence physicist use when speaking about a specific atlas. I’ve been listening to lesbian folk music all evening. I’m having feelings.<a href="#fnref40" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn41"><p>pronoun on purpose<a href="#fnref41" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn42"><p>Takahashi, K., Fagan, J., Chen, M.S., 1973. Formation of a sparse bus impedance matrix and its application to short circuit study. In: Eighth PICA Conference Proceedings.IEEE Power Engineering Society, pp.&nbsp;63–69 (Papers Presented at the 1973 Power Industry Computer Application Conference in Minneapolis, MN).<a href="#fnref42" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn43"><p>Thanks to Jerzy Baranowski for finding a very very bad LaTeX error that made these questions quite wrong!<a href="#fnref43" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn44"><p>Indeed, in the notation of post two <span class="math inline">\(\mathcal{L}_i \cap \{i+1, \dots, n\} \subseteq \mathcal{L}_j\)</span> for all <span class="math inline">\(i \leq j\)</span>, where <span class="math inline">\(\mathcal{L}_i\)</span> is the set of non-zeros in the <span class="math inline">\(i\)</span>th column of <span class="math inline">\(L\)</span>.<a href="#fnref44" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn45"><p>The sparse matrix is stored as a dictionary <code>{(i,j): value}</code>, which is a very natural way to build a sparse matrix, even if its quite inefficient to do anything with it in that form.<a href="#fnref45" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn46"><p>You can’t just use <code>jnp.linalg.det()</code> because there’s a tendency towards <code>nan</code>s. (The true value is something like <code>r exp(250.49306761204593)</code>!)<a href="#fnref46" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn47"><p>Would it be less tedious if my implementation of the Cholesky was less shit? Yes. But hey. It was the first non-trivial piece of python code I’d written in more than a decade (or maybe ever?) so it is what it is. Anyway. I’m gonna run into the same problem I had in <a href="https://dansblog.netlify.app/posts/2022-05-14-jax-ing-a-sparse-cholesky-factorisation-part-3-in-an-ongoing-journey/">Part 3</a><a href="#fnref47" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
</ol>
</section><section class="quarto-appendix-contents"><h2 class="anchored quarto-appendix-heading">Reuse</h2><div quarto-reuse="quarto-reuse" class="quarto-appendix-contents"><a rel="license" href="https://creativecommons.org/licenses/by-nc/4.0/">https://creativecommons.org/licenses/by-nc/4.0/</a></div></section><section class="quarto-appendix-contents"><h2 class="anchored quarto-appendix-heading">Citation</h2><div><div class="quarto-appendix-secondary-label">BibTeX citation:</div><pre class="sourceCode code-with-copy quarto-appendix-bibtex"><code class="sourceCode bibtex">@online{simpson2022,
  author = {Dan Simpson},
  editor = {},
  title = {Sparse Matrices 6: {To} Catch a Derivative, First You’ve Got
    to Think Like a Derivative},
  date = {2022-05-30},
  url = {https://dansblog.netlify.app/to-catch-a-derivative-first-youve-got-to-think-like-a-derivative},
  langid = {en}
}
</code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre><div class="quarto-appendix-secondary-label">For attribution, please cite this work as:</div><div id="ref-simpson2022" class="csl-entry quarto-appendix-citeas" role="doc-biblioentry">
Dan Simpson. 2022. <span>“Sparse Matrices 6: To Catch a Derivative,
First You’ve Got to Think Like a Derivative.”</span> May 30, 2022. <a href="https://dansblog.netlify.app/to-catch-a-derivative-first-youve-got-to-think-like-a-derivative">https://dansblog.netlify.app/to-catch-a-derivative-first-youve-got-to-think-like-a-derivative</a>.
</div></div></section></div></main> <!-- /main -->
<script id="quarto-html-after-body" type="application/javascript">
window.document.addEventListener("DOMContentLoaded", function (event) {
  const toggleBodyColorMode = (bsSheetEl) => {
    const mode = bsSheetEl.getAttribute("data-mode");
    const bodyEl = window.document.querySelector("body");
    if (mode === "dark") {
      bodyEl.classList.add("quarto-dark");
      bodyEl.classList.remove("quarto-light");
    } else {
      bodyEl.classList.add("quarto-light");
      bodyEl.classList.remove("quarto-dark");
    }
  }
  const toggleBodyColorPrimary = () => {
    const bsSheetEl = window.document.querySelector("link#quarto-bootstrap");
    if (bsSheetEl) {
      toggleBodyColorMode(bsSheetEl);
    }
  }
  toggleBodyColorPrimary();  
  const icon = "";
  const anchorJS = new window.AnchorJS();
  anchorJS.options = {
    placement: 'right',
    icon: icon
  };
  anchorJS.add('.anchored');
  const clipboard = new window.ClipboardJS('.code-copy-button', {
    target: function(trigger) {
      return trigger.previousElementSibling;
    }
  });
  clipboard.on('success', function(e) {
    // button target
    const button = e.trigger;
    // don't keep focus
    button.blur();
    // flash "checked"
    button.classList.add('code-copy-button-checked');
    var currentTitle = button.getAttribute("title");
    button.setAttribute("title", "Copied!");
    setTimeout(function() {
      button.setAttribute("title", currentTitle);
      button.classList.remove('code-copy-button-checked');
    }, 1000);
    // clear code selection
    e.clearSelection();
  });
  function tippyHover(el, contentFn) {
    const config = {
      allowHTML: true,
      content: contentFn,
      maxWidth: 500,
      delay: 100,
      arrow: false,
      appendTo: function(el) {
          return el.parentElement;
      },
      interactive: true,
      interactiveBorder: 10,
      theme: 'quarto',
      placement: 'bottom-start'
    };
    window.tippy(el, config); 
  }
  const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
  for (var i=0; i<noterefs.length; i++) {
    const ref = noterefs[i];
    tippyHover(ref, function() {
      // use id or data attribute instead here
      let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
      try { href = new URL(href).hash; } catch {}
      const id = href.replace(/^#\/?/, "");
      const note = window.document.getElementById(id);
      return note.innerHTML;
    });
  }
  var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
  for (var i=0; i<bibliorefs.length; i++) {
    const ref = bibliorefs[i];
    const cites = ref.parentNode.getAttribute('data-cites').split(' ');
    tippyHover(ref, function() {
      var popup = window.document.createElement('div');
      cites.forEach(function(cite) {
        var citeDiv = window.document.createElement('div');
        citeDiv.classList.add('hanging-indent');
        citeDiv.classList.add('csl-entry');
        var biblioDiv = window.document.getElementById('ref-' + cite);
        if (biblioDiv) {
          citeDiv.innerHTML = biblioDiv.innerHTML;
        }
        popup.appendChild(citeDiv);
      });
      return popup.innerHTML;
    });
  }
});
</script>
</div> <!-- /content -->



</body></html>