[
  {
    "objectID": "posts/2022-06-03-that-psis-proof/that-psis-proof.html",
    "href": "posts/2022-06-03-that-psis-proof/that-psis-proof.html",
    "title": "Tail stabilization of importance sampling etimators: A bit of theory",
    "section": "",
    "text": "Imagine you have a target probability distribution \\(p(\\theta)\\) and you want to estimate the expectation \\(I_h = \\int h(\\theta) p(\\theta)\\,d(\\theta)\\). That’s lovely and everything, but if it was easy none of us would have jobs. High-dimensional quadrature is a pain in the arse.\nA very simple way to get an decent estimate of \\(I_h\\) is to use importance sampling, that is taking draws \\(\\theta_s\\), \\(s = 1,\\ldots, S\\) from some proposal distribution \\(\\theta_s \\sim g(\\theta)\\). Then, noting that \\[\nI_h = \\int h(\\theta) p (\\theta)\\,d\\theta = \\int h(\\theta) \\underbrace{\\frac{p(\\theta)}{g(\\theta)}}_{r(\\theta)}g(\\theta)\\,d\\theta,\n\\] we can use Monte Carlo to estimate the second integral. This leads to the importance sampling estimator \\[\nI_h^S = \\sum_{s=1}^S h(\\theta_s) r(\\theta_s).\n\\]\nThis all seems marvellous, but there is a problem. Even though \\(h\\) is probably a very pleasant function and \\(g\\) is a nice friendly distribution, \\(r(\\theta)\\) can be an absolute beast. Why? Well it’s1 the ratio of two densities and there is no guarantee that the ratio of two nice functions is itself a nice function. In particular, if the bulk of the distributions \\(p\\) and \\(g\\) are in different places, you’ll end up with the situation where for most draws \\(r(\\theta_s)\\) is very small2 and a few will be HUGE3.\nThis will lead to an extremely unstable estimator.\nIt is pretty well known that the raw importance sampler \\(I_h^S\\) will behave nicely (that is will be unbiased with finite variance) precisely when the distribution of \\(r_s = r(\\theta_s)\\) has finite variance.\nElementary treatments stop there, but they miss two very big problems. The most obvious one is that it’s basically impossible to check if the variance of \\(r_s\\) is finite. A second, much larger but much more subtle problem, is that the variance can be finite but massive. This is probably the most common case in high dimensions. McKay has an excellent example where the importance ratios are bounded, but that bound is so large that it is infinite for all intents and purposes.\nAll of which is to say that importance sampling doesn’t work unless you work on it."
  },
  {
    "objectID": "posts/2022-06-03-that-psis-proof/that-psis-proof.html#truncated-importance-sampling",
    "href": "posts/2022-06-03-that-psis-proof/that-psis-proof.html#truncated-importance-sampling",
    "title": "Tail stabilization of importance sampling etimators: A bit of theory",
    "section": "Truncated importance sampling",
    "text": "Truncated importance sampling\nIf the problem is the fucking ratios then by gum we will fix the fucking ratios. Or so the saying goes.\nThe trick turns out to be modifying the largest ratios enough that we stabilise the variance, but not so much as to overly bias the estimate.\nThe first version of this was truncated importance sampling (TIS), which selects a threshold \\(T\\) and estimates the expectation as \\[\nI_\\text{TIS}^S = \\frac{1}{S}\\sum_{s= 1}^S h(\\theta_s) \\max\\{r(\\theta_s), T\\}.\n\\] It’s pretty obvious that \\(I^S_\\text{TIS}\\) has finite variance for any fixed \\(T\\), but we should be pretty worried about the bias. Unsurprisingly, there is going to be a trade-off between the variance and the bias. So let’s explore that.\n\nThe bias of TIS\nTo get an expression for the bias, first let us write \\(r_s = r(\\theta_s)\\) and \\(h_s = h(\\theta_s)\\) for \\(\\theta_s \\sim g\\). Occasionally we will talk about the joint distribution or \\((r_s,h_s) \\sim (R,H)\\). Sometimes we will also need to use the indicator variables \\(z_i = 1_{r_i < T}\\).\nThen, we can write4 \\[\nI = \\mathbb{E}(HR \\mid R \\leq T) \\Pr(R \\leq T) + \\mathbb{E}(HR \\mid R > T) \\Pr(R > T).\n\\]\nHow does this related to TIS? Well. Let \\(M = \\sum_{s=1}^S z_i\\) be the random variable denoting the number of times \\(r_i > T\\). Then, \\[\\begin{align*}\n\\mathbb{E}(I_\\text{TIC}^S) &= \\mathbb{E}\\left( \\frac{1}{S}\\sum_{s=1}^Sz_ih_ir_i\\right)  + \\mathbb{E}\\left( \\frac{T}{S}\\sum_{s=1}^S(1-z_i)h_i\\right) \\\\\n&=\\mathbb{E}_M\\left[\\frac{S-M}{S}\\mathbb{E}(HR \\mid R < T) + \\frac{MT}{S}\\mathbb{E}(H \\mid R > T)\\right] \\\\\n&=\\mathbb{E}(HR \\mid R \\leq T) \\Pr(R \\leq T) + T\\mathbb{E}(H \\mid R > T) \\Pr(R > T).\n\\end{align*}\\]\nHence the bias in TIS is \\[\nI - \\mathbb{E}(I_\\text{TIS}^S) = \\mathbb{E}(H(R-T) \\mid R > T) \\Pr(R > T).\n\\]\nTo be honest, this doesn’t look phenomenally interesting for fixed \\(T\\), however if we let \\(T = T_S\\) depend on the sample size then as long as \\(T_S \\rightarrow \\infty\\) we get vanishing bias.\nWe can get more specific if we make the assumption about the tail of the importance ratios. In particular, we will assume that5 \\(1-R(r) = \\Pr(R > r) = cr^{-1/k}(1+o(1))\\) for some6 \\(k<1\\).\nWhile it seems like this will only be useful for estimating \\(\\Pr(R>T)\\), it turns out that under some mild7 technical conditions, the conditional excess distribution function8 \\[\nR_T(y) = \\Pr(R - T \\leq y \\mid R > T) = \\frac{R(T + y) - R(T)}{1-R(T)},\n\\] is well approximated by a Generalised Pareto Distribution as \\(T\\rightarrow \\infty\\). Or, in maths, as \\(T\\rightarrow \\infty\\), \\[\nR_T(y) \\rightarrow \\begin{cases} 1- \\left(1 + \\frac{ky}{\\sigma}\\right)^{-1/k}, \\quad & k \\neq 0 \\\\\n1- \\mathrm{e}^{-y/\\sigma}, \\quad &k = 0,\n\\end{cases}\n\\] for some \\(\\sigma > 0\\) and \\(k \\in \\mathbb{R}\\). The shape9 parameter \\(k\\) is very important for us, as it tells us how many moments the distribution has. In particular, if a distribution \\(X\\) has shape parameter \\(k\\), then \\[\n\\mathbb{E}|X|^\\alpha < \\infty, \\quad \\forall \\alpha < \\frac{1}{k}.\n\\] We will focus exclusively on the case where \\(k < 1\\). When \\(k < 1/2\\), the distribution has finite variance.\nIf \\(1- R(r) = cr^{-1/k}(1+ o(1))\\), then the conditional exceedence function is \\[\\begin{align*}\nR_T(y) &=  \\frac{cT^{-1/k}(1+  o(1)) - c(T+y)^{-1/k}(1+  o(1))}{cT^{-1/k}(1+  o(1)))} \\\\\n&= \\left[1 - \\left(1 + \\frac{y}{T}\\right)^{-1/k}\\right](1 + o(1)),\n\\end{align*}\\] which suggests that as \\(T\\rightarrow \\infty\\), \\(R_T\\) converges to a generalised Pareto distribution with shape parameter \\(k\\) and scale parameter \\(\\mathcal{O}(T)\\).\nAll of this work lets us approximate the distribution of \\((R-T \\mid R>T )\\) and use the formula for the mean of a generalised Pareto distribution. This gives us the estimate \\[\n\\mathbb{E}(R- T \\mid R>T) \\approx \\frac{T}{1-k},\n\\] which estimates the bias when \\(h(\\theta)\\) is constant10 as \\[\nI - \\mathbb{E}(I_\\text{TIS}^S) \\approx \\mathcal{O}\\left(T^{1-1/k}\\right).\n\\]\nFor what it’s worth, Ionides got the same result more directly in the TIS paper, but he wasn’t trying to do what I’m trying to do.\n\n\nThe variance in TIS\nThe variance is a little bit more annoying. We want it to go to zero.\nAs before, we condition on \\(z_s\\) (or, equivalently, \\(M\\)) and then use the law of total variance. We know from the bias calculation that \\[\n\\mathbb{E}(I_\\text{TIS}^S \\mid M) =\\frac{S-M}{S}\\mathbb{E}(HR \\mid R>T) + \\frac{TM}{S}\\mathbb{E}(H \\mid R>T).\n\\]\nA similarly quick calculation tells us that \\[\n\\mathbb{V}(I_\\text{TIS}^S \\mid M) = \\frac{S-M}{S^2}\\mathbb{V}(HR \\mid R \\leq T) +\\frac{MT^2}{S^2}\\mathbb{V}(H \\mid R>T).\n\\] To close it out, we recall that \\(M\\) is the sum of Bernoulli random variables so \\[\nM \\sim \\text{Binomial}(S, \\Pr(R > T)).\n\\]\nWith this, we can get an expression for the unconditional variance. To simplify the expression, let’s write \\(p_T = \\Pr(R > T)\\). Then, \\[\\begin{align*}\n\\mathbb{V}(I_\\text{TIS}^S) &=\\mathbb{E}_M\\mathbb{V}(I_\\text{TIS}^S \\mid M) + \\mathbb{V}_M\\mathbb{E}(I_\\text{TIS}^S \\mid M) \\\\\n&= S^{-1}(1-p_T)\\mathbb{V}(HR \\mid R \\leq T) +S^{-1}T^2p_T\\mathbb{V}(H \\mid R>T)\\\\\n&\\quad + S^{-1}p_T(1-p_T)\\mathbb{E}(HR \\mid R>T)^2 + S^{-1}Tp_T(1-p_T)\\mathbb{E}(H \\mid R>T)^2.\n\\end{align*}\\]\nThere are four terms in the variance. The first and third terms are clearly harmless: they go to zero no matter how we choose \\(T_S\\). Our problem terms are the second and fourth. We can tame the fourth term if we choose \\(T_S = o(S)\\). But that doesn’t seem to help with the second term. But it turns out it is enough. To see this, we note that \\[\\begin{align*}\nTp_T\\mathbb{V}(H\\mid R>T) &=\\leq Tp_T\\mathbb{E}(H^2 \\mid R>T)\\\\\n&\\leq p_T\\mathbb{E}(H^2 R\\mid R>T) \\\\\n&\\leq \\mathbb{E}(H^2 R)\\\\\n&= \\int h(\\theta)^2 p(\\theta)\\,d\\theta < \\infty.\n\\end{align*}\\] where the second inequality uses the fact that \\(R>T\\) and the third comes from the law of total probability.\nSo the TIS estimator has vanishing bias and variance as long as the truncation \\(T_S \\rightarrow \\infty\\) and \\(T_S = o(S)\\). Once again, this is in the TIS paper, where it is proved in a much more compact way.\n\n\nAsymptotic properties\nIt can also be useful to have an understanding of how wild the fluctuations \\(I - I_\\text{TIS}^S\\) are. For traditional importance sampling, we know that if \\(\\mathbb{E}(R^2)\\) is finite, then then the fluctuations are, asymptotically, normally distributed with mean zero. Non-asymptotic results were given by Chatterjee and Diaconis that also hold even when the estimator has infinite variance.\nFor TIS, it’s pretty obvious that for fixed \\(T\\) and \\(h \\geq 0\\), \\(I_\\text{TIS}^S\\) will be asymptotically normal (it is, after all, the sum of bounded random variables). For growing sequences \\(T_S\\) it’s a tiny bit more involved: it is now a triangular array11 rather than a sequence of random variables. But in the end very classical results tell us that for bounded12 \\(h\\), the fluctuations of the TIS estimator are asymptotically normal.\nIt’s worth saying that when \\(h(\\theta)\\) is unbounded, it might be necessary to truncate the product \\(h_ir_i\\) rather than just \\(r_i\\). This is especially relevant if \\(\\mathbb{E}(H \\mid R=r)\\) grows rapidly with \\(r\\). Personally, I can’t think of a case where this happens: \\(r(\\theta)\\) usually grows (super-)exponentially in \\(\\theta\\) while \\(h(\\theta)\\) usually grows polynomially, which implies \\(\\mathbb{E}(H \\mid R=r)\\) grows (poly-)logarithmically.\nThe other important edge case is that when \\(h(\\theta)\\) can be both positive and negative, it might be necessary to truncate \\(h_ir_i\\) both above and below."
  },
  {
    "objectID": "posts/2022-06-03-that-psis-proof/that-psis-proof.html#winsorised-importance-sampling",
    "href": "posts/2022-06-03-that-psis-proof/that-psis-proof.html#winsorised-importance-sampling",
    "title": "Tail stabilization of importance sampling etimators: A bit of theory",
    "section": "Winsorised importance sampling",
    "text": "Winsorised importance sampling\nTIS has lovely theoretical properties, but it’s a bit challenging to use in practice. The problem is, there’s really no practical guidance on how to choose the truncation sequence.\nSo let’s do this differently. What if instead of specifying a threshold directly, we instead decided that the largest \\(M\\) values are potentially problematic and should be modified? Recall that for TIS, the number of samples that exceeded the threshold, \\(M\\), was random while the threshold was fixed. This is the opposite situation: the number of exceedences is fixed but the threshold is random.\nThe threshold is now the \\(M\\)th largest value of \\(r_s\\). We denote this using order statistics notation: we re-order the sample so that \\[\nr_{1:S} \\leq r_{2:S}\\leq \\ldots r_{S:S}.\n\\] With this notation, the threshold is \\(T = r_{S-M+1:S}\\) and the Winsorized importance sampler (WIS) is \\[\nI^S_\\text{WIS} = \\frac{1}{S}\\sum_{s = 1}^{S-M} h_{s:S}r_{s:S} + \\frac{r_{S-M+1:S}}{S}\\sum_{s=S-M+1}^S h_{s:S},\n\\] where \\((r_{s:S}, h_{s:S})\\) are the \\((r_s, h_s)\\) pairs ordered so that \\(r_{1:S} \\leq r_{2:S}\\leq \\cdots \\leq r_{S:S}\\). Note that \\(h_{s:S}\\) are not necessarily in increasing order: they are known as concomitants of \\(r_{s:S}\\), which is just a fancy way to say that they’re along for the ride. It’s very important that we reorder the \\(h_s\\) when we reorder the \\(r_s\\), otherwise we won’t preserve the joint distribution and we’ll end up with absolute rubbish.\nWe can already see that this is both much nicer and much wilder than the TIS distribution. It is convenient that \\(M\\) is no longer random! But what the hell are we going to do about those order statistics? Well, the answer is very much the same thing as before: condition on them and hope for the best.\nConditioned on the event13 \\(\\{r_{S-M+1:S} = T\\}\\), we get \\[\n\\mathbb{E}\\left(I_\\text{WIS}^S \\mid r_{S-M+1:S} = T\\right) = \\left(1 - \\frac{M}{S}\\right)\\mathbb{E}(RH \\mid R < T) + \\frac{MT}{S} \\mathbb{E}(H \\mid R \\geq T).\n\\] From this, we get that the bias, conditional on \\(r_{S-M+1:S} = T\\) is \\[\\begin{multline*}\n\\left|I - \\mathbb{E}\\left(I_\\text{WIS}^S \\mid r_{S-M+1:S} = T\\right)\\right| =\\left|\\left[\\Pr(R < T) - \\left(1 - \\frac{M}{S}\\right)\\right]\\mathbb{E}(RH \\mid R < T) \\right.\\\\\n\\left.+ \\left[\\Pr(R \\geq T) - \\frac{M}{S}\\right] \\mathbb{E}(H(R - T) \\mid R \\geq T)\\right|.\n\\end{multline*}\\]\nYou should immediately notice that we are in quite a different situation from TIS, where only the tail contributed to the bias. By fixing \\(M\\) and randomising the threshold, we have bias contributions from both the bulk (due, essentially, to a weighting error) and from the tail (due to both the weighting error and the truncation). This is going to require us to be a bit creative.\nWe could probably do something more subtle and clever here, but that is not my way. Instead, let’s use the triangle inequality to say \\[\n\\left|\\mathbb{E}(RH \\mid R > T)\\right| \\leq \\frac{\\mathbb{E}(R |H| 1(R<T))}{\\Pr(R <T)} \\leq \\frac{\\|h\\|_{L^1(p)}}{\\Pr(R  <T)}\n\\] and so the first term in the bias can be bounded if we can bound the relative error \\[\n\\mathbb{E}\\left|1 - \\frac{1- M/S}{\\Pr(R < r_{S-M+1:S})}\\right|.\n\\]\nNow the more sensible among you will say Daniel, No! That’s a ratio! That’s going to be hard to bound. And, of course, you are right. But here’s the thing: if \\(M\\) is small relative to \\(S\\), it is tremendously unlikely that \\(r_{S-M+1:S}\\) is anywhere near zero. This is intuitively true, but also mathematically true.\nTo attack this expectation, we are going to look at a slightly different quantity that has the good grace of being non-negative.\n\nLemma 1 Let \\(X_s\\), \\(s= 1, \\ldots S\\) be an iid sample from \\(F_X\\), let \\(0\\leq k\\leq S\\) be an integer. Then \\[\n\\frac{p}{F_X(x_{k:S})} -p \\stackrel{d}{=} \\frac{p(S-k+1)}{k} \\mathcal{F},\n\\] and \\[\n\\frac{1-p}{1- F_x/(x_{k:S})} - (1-p) \\stackrel{d}{=} \\frac{k(1-p)}{S-k+1}\\mathcal{F}^{-1}\n\\] where \\(\\mathcal{F}\\) is an F-distributed random variable with parameters \\((2(S-k+1), 2k)\\).\n\n\nProof. For any \\(t\\geq 0\\), \\[\\begin{align*}\n\\Pr\\left(\\frac{p}{F_X(x_{k:S})} - p \\leq t\\right) &=\\Pr\\left(p - pF_X(x_{k:S}) \\leq tF_X(x_{k:S})\\right) \\\\\n&= \\Pr\\left(p  \\leq (t+p)F_X(x_{k:S})\\right) \\\\\n&=\\Pr\\left(F_X(x_{k:S}) \\geq \\frac{p}{p+t}\\right)\\\\\n&= \\Pr\\left(x_{k:S} \\geq F_X^{-1}\\left(\\frac{p}{p+t}\\right)\\right)\\\\\n&= 1- I_{\\frac{p}{p+t}}(k, S-k+1) \\\\\n&= I_{\\frac{t}{p+t}}(S-k+1, k),\n\\end{align*}\\] where \\(I_p(a,b)\\) is the incomplete Beta function.\nYou could, quite reasonably, ask where the hell that incomplete Beta function came from. And if I had thought to look this up, I would say that it came from Equation 2.1.5 in David and Nagaraja’s book on order statistics. Unfortunately, I did not look this up. I derived it, which is honestly not very difficult. The trick is to basically note that the event \\(\\{x_{k:S} \\leq \\tau\\}\\) is the same as the event that at least \\(k\\) of the samples \\(x_s\\) are less than or equal to \\(\\tau\\). Because the \\(x_s\\) are independent, this is the probability of observing at least \\(k\\) heads from a coin with the probability of a head \\(\\Pr(x \\leq \\tau) = F_X(\\tau)\\). If you look this up on Wikipedia14 you see15 that it is \\(I_{1-F_X(\\tau)}(k,S-k+1)\\). The rest just come from noting that \\(\\tau = F_X^{-1}(t/(p+t))\\) and using the symmetry \\(1-I_p(a,b) = I_{1-p}(b,a)\\).\nTo finish this off, we note that \\[\n\\Pr(\\mathcal{F} \\leq x) = I_{\\frac{S-k+1}{(S-k+1)x+ k}}(S-k+1,k).\n\\] From which, we see that \\[\\begin{align*}\n\\Pr\\left(\\frac{p}{F_X(x_{k:S})} - p \\leq t\\right) &=\\Pr\\left(\\mathcal{F} \\leq \\frac{k}{p(S-k+1)}t\\right) \\\\\n&= \\Pr\\left(\\frac{p(S-k+1)}{k}\\mathcal{F} \\leq t\\right).\n\\end{align*}\\]\nThe second result follows the same way and by noting that \\(\\mathcal{F}^{-1}\\) is also F-distributed with parameters \\((k, S-k+1)\\).\nThe proof has ended\n\nNow, obviously, in this house we do not trust mathematics. Which is to say that I made a stupid mistake the first time I did this and forgot that when \\(Z\\) is binomial, \\(\\Pr(Z \\geq k) = 1 - \\Pr(Z \\leq k-1)\\) and had a persistent off-by-one error in my derivation. But we test out our results so we don’t end up doing the dumb thing.\nSo let’s do that. For this example, we will use generalised Pareto-distributed \\(X\\).\n\nlibrary(tidyverse)\nxi <- 0.7\ns <- 2\nu <- 4\n\nsamp <- function(S, k, p, \n                 Q = \\(x) u + s*((1-x)^(-xi)-1)/xi, \n                 F = \\(x) 1 - (1 + xi*(x - u)/s)^(-1/xi)) {\n  # Use theory to draw x_{k:S}\n  xk <- Q(rbeta(1, k, S - k + 1))\n  c(1 - p / F(xk), 1-(1-p)/(1-F(xk)))\n}\n\nS <- 1000\nM <- 50\nk <- S - M + 1\np <- 1-M/S\nN <- 100000\n\nfs <- rf(N, 2 * (S - k + 1), 2 * k )\ntibble(theoretical = 1-p - p * fs * (S - k + 1)/k,\n       xks = map_dbl(1:N, \\(x) samp(S, k, p)[1])) %>%\n  ggplot() + stat_ecdf(aes(x = xks), colour = \"black\") + \n  stat_ecdf(aes(x = theoretical), colour = \"red\", linetype = \"dashed\") +\n  ggtitle(expression(1 - frac(1-M/S , R(r[S-M+1:S]))))\n\n\n\ntibble(theoretical = p - (1-p) * k/(fs * (S - k + 1)),\n       xks = map_dbl(1:N, \\(x) samp(S, k, p)[2])) %>%\n  ggplot() + stat_ecdf(aes(x = xks), colour = \"black\") + \n  stat_ecdf(aes(x = theoretical), colour = \"red\", linetype = \"dashed\") +\n  ggtitle(expression(1 - frac(M/S , 1-R(r[S-M+1:S]))))\n\n\n\n\nFabulous. It follow then that \\[\n\\left|1 - \\frac{1-M/S}{R(r_{S-M+1})} \\right| \\stackrel{d}= \\left|\\frac{M}{S} -  \\frac{M(S-M)}{S(S-M-1)}\\mathcal{F}\\right| \\leq \\frac{M}{S} +  \\frac{M(S-M)}{S(S-M-1)} \\mathcal{F},\n\\] where \\(\\mathcal{F}\\) has an F-distribution with \\((M, S-M+1)\\) degrees of freedom. As \\(\\mathbb{E}(\\mathcal{F}) = 1 + 1/(S-M-1)\\), it follows that this term goes to zero as long as \\(M = o(S)\\). This shows that the first term in the bias goes to zero.\nIt’s worth noting here that we’ve also calculated that the bias is at most \\(\\mathcal{O}(M/S)\\), however, this rate is extremely sloppy. That upper bound we just computed is unlikely to be tight. A better person than me would probably check, but honestly I just don’t give a shit16\nThe second term in the bias is \\[\n\\left[\\Pr(R \\geq T) - \\frac{M}{S}\\right] \\mathbb{E}(H(R - T) \\mid R \\geq T).\n\\] As before, we can write this as \\[\n\\left(1 - \\frac{M/S}{1-R(T)}\\right)|\\mathbb{E}(H(R - T) 1_{R \\geq T})| \\leq \\left|1 - \\frac{M/S}{1-R(T)}\\right|\\|h\\|_{L^1(p)}.\n\\] By our lemma, we know that the distribution of the term in the absolute value when \\(T = r_{S-M+1}\\) is the same as \\[\n1-\\frac{M}{S} -\\left(1 - \\frac{M}{S} + \\frac{1}{S}\\right)\\mathcal{F} = (\\mu_F-\\mathcal{F})  +\\frac{M}{S}(\\mathcal{F}-\\mu_F) - \\frac{1}{S}\\mathcal{F} +  \\frac{1}{M-1}\\left(\\frac{M}{S} - 1\\right),\n\\] where \\(\\mathcal{F} \\sim \\text{F}_{2(S-M+1), 2M}\\), which has mean \\(\\mu_F = 1+(M-1)^{-1}\\) and variance \\[\n\\sigma^2_F = \\frac{M^2S}{(S-M+1)(M-1)^2(M-2)} = \\frac{1}{M}(1 + \\mathcal{O}(M^{-1} + MS^{-1}).\n\\] From Jensen’s inequality, we get \\[\n\\mathbb{E}(|\\mathcal{F} - \\mu_F|) \\leq \\sigma_F = M^{-1/2}(1 + o(1)).\n\\] If follows that \\[\n\\mathbb{E}\\left|1 - \\frac{M/S}{1-R(r_{S-M+1:S})}\\right| \\leq M^{-1/2}(1+o(1))M^{1/2}S^{-1}(1 + o(1)) + S^{-1}(1+ o(1)) + (M-1)^{-1}(1+o(1)),\n\\] and so we get vanishing bias as long as \\(M\\rightarrow \\infty\\) and \\(M/S \\rightarrow 0\\).\nOnce again, I make no claims of tightness17. Just because it’s a bit sloppy at this point doesn’t mean the job isn’t done.\n\nTheorem 1 Let \\(\\theta_s\\), \\(s = 1,\\ldots, S\\) be an iid sample from \\(G\\) and let \\(r_s = r(\\theta_s) \\sim R\\). Assume that\n\n\\(R\\) is absolutely continuous\n\\(M \\rightarrow \\infty\\) and \\(S^{-1}M \\rightarrow 0\\)\n\\(h \\in L^1(p)\\)\n\nThen Winsorized importance sampling converges in \\(L^1\\) and is asymptotically unbiased.\n\nOk so that’s nice. But you’ll notice that I did not mention our piss-poor rate. That’s because there is absolutely no way in hell that the bias is \\(\\mathcal{O}(M^{-1/2})\\)! That rate is an artefact of a very sloppy bound on \\(\\mathbb{E}|1-\\mathcal{F}|\\).\nUnfortunately, Mathematica couldn’t help me out. Its asymptotic abilities shit the bed at the sight of \\({}_2F_1(a,b;c;z))\\), which is everywhere in the exact expression (which I’ve put below in the fold.\n\n\nMathematica expression for \\(\\mathbb{E}|1-\\mathcal{F}|\\).\n\n-(((M/(1 + S))^(-(1/2) - S/2)*Gamma[(1 + S)/2]*\n     (6*(M/(1 + S))^(1/2 + M/2 + S/2)*((1 + S)/(1 - M + S))^(M/2 + S/2) - \n        5*M*(M/(1 + S))^(1/2 + M/2 + S/2)*((1 + S)/(1 - M + S))^(M/2 + S/2) + \n        M^2*(M/(1 + S))^(1/2 + M/2 + S/2)*((1 + S)/(1 - M + S))^(M/2 + S/2) + \n        8*S*(M/(1 + S))^(1/2 + M/2 + S/2)*((1 + S)/(1 - M + S))^(M/2 + S/2) - \n        6*M*S*(M/(1 + S))^(1/2 + M/2 + S/2)*((1 + S)/(1 - M + S))^(M/2 + S/2) + \n        M^2*S*(M/(1 + S))^(1/2 + M/2 + S/2)*((1 + S)/(1 - M + S))^(M/2 + S/2) + \n        2*S^2*(M/(1 + S))^(1/2 + M/2 + S/2)*((1 + S)/(1 - M + S))^(M/2 + S/2) - \n        M*S^2*(M/(1 + S))^(1/2 + M/2 + S/2)*((1 + S)/(1 - M + S))^(M/2 + S/2) - \n         6*Sqrt[-(M/(-1 + M - S))]*Sqrt[(-1 - S)/(-1 + M - S)]*\n        (M/(1 - M + S))^(M/2 + S/2)*Hypergeometric2F1[1, (1/2)*(-1 + M - S), \n                                                      M/2, M/(-1 + M - S)] + 8*M*Sqrt[-(M/(-1 + M - S))]*\n        Sqrt[(-1 - S)/(-1 + M - S)]*(M/(1 - M + S))^(M/2 + S/2)*\n        Hypergeometric2F1[1, (1/2)*(-1 + M - S), M/2, M/(-1 + M - S)] - \n        2*M^2*Sqrt[-(M/(-1 + M - S))]*Sqrt[(-1 - S)/(-1 + M - S)]*\n        (M/(1 - M + S))^(M/2 + S/2)*Hypergeometric2F1[1, (1/2)*(-1 + M - S), \n                                                      M/2, M/(-1 + M - S)] - 8*Sqrt[-(M/(-1 + M - S))]*\n        Sqrt[(-1 - S)/(-1 + M - S)]*S*(M/(1 - M + S))^(M/2 + S/2)*\n        Hypergeometric2F1[1, (1/2)*(-1 + M - S), M/2, M/(-1 + M - S)] + \n        4*M*Sqrt[-(M/(-1 + M - S))]*Sqrt[(-1 - S)/(-1 + M - S)]*S*\n        (M/(1 - M + S))^(M/2 + S/2)*Hypergeometric2F1[1, (1/2)*(-1 + M - S), \n                                                      M/2, M/(-1 + M - S)] - 2*Sqrt[-(M/(-1 + M - S))]*\n        Sqrt[(-1 - S)/(-1 + M - S)]*S^2*(M/(1 - M + S))^(M/2 + S/2)*\n        Hypergeometric2F1[1, (1/2)*(-1 + M - S), M/2, M/(-1 + M - S)] + \n        6*M*(M/(1 + S))^(M/2)*((1 + S)/(1 - M + S))^(M/2 + S/2)*\n        Hypergeometric2F1[(1 + S)/2, (1/2)*(1 - M + S), (1/2)*(3 - M + S), \n                          (-1 + M - S)/M] - 5*M^2*(M/(1 + S))^(M/2)*((1 + S)/(1 - M + S))^\n        (M/2 + S/2)*Hypergeometric2F1[(1 + S)/2, (1/2)*(1 - M + S), \n                                      (1/2)*(3 - M + S), (-1 + M - S)/M] + M^3*(M/(1 + S))^(M/2)*\n        ((1 + S)/(1 - M + S))^(M/2 + S/2)*Hypergeometric2F1[(1 + S)/2, \n                                                            (1/2)*(1 - M + S), (1/2)*(3 - M + S), (-1 + M - S)/M] + \n        2*M*S*(M/(1 + S))^(M/2)*((1 + S)/(1 - M + S))^(M/2 + S/2)*\n        Hypergeometric2F1[(1 + S)/2, (1/2)*(1 - M + S), (1/2)*(3 - M + S), \n                          (-1 + M - S)/M] - M^2*S*(M/(1 + S))^(M/2)*((1 + S)/(1 - M + S))^\n        (M/2 + S/2)*Hypergeometric2F1[(1 + S)/2, (1/2)*(1 - M + S), \n                                      (1/2)*(3 - M + S), (-1 + M - S)/M] - 2*M*(M/(1 + S))^(M/2)*\n        ((1 + S)/(1 - M + S))^(M/2 + S/2)*Hypergeometric2F1[(1 + S)/2, \n                                                            (1/2)*(3 - M + S), (1/2)*(5 - M + S), (-1 + M - S)/M] + \n        3*M^2*(M/(1 + S))^(M/2)*((1 + S)/(1 - M + S))^(M/2 + S/2)*\n        Hypergeometric2F1[(1 + S)/2, (1/2)*(3 - M + S), (1/2)*(5 - M + S), \n                          (-1 + M - S)/M] - M^3*(M/(1 + S))^(M/2)*((1 + S)/(1 - M + S))^\n        (M/2 + S/2)*Hypergeometric2F1[(1 + S)/2, (1/2)*(3 - M + S), \n                                      (1/2)*(5 - M + S), (-1 + M - S)/M] - 2*M*S*(M/(1 + S))^(M/2)*\n        ((1 + S)/(1 - M + S))^(M/2 + S/2)*Hypergeometric2F1[(1 + S)/2, \n                                                            (1/2)*(3 - M + S), (1/2)*(5 - M + S), (-1 + M - S)/M] + \n        M^2*S*(M/(1 + S))^(M/2)*((1 + S)/(1 - M + S))^(M/2 + S/2)*\n        Hypergeometric2F1[(1 + S)/2, (1/2)*(3 - M + S), (1/2)*(5 - M + S), \n                          (-1 + M - S)/M]))/(((1 + S)/(1 - M + S))^S*\n                                               (2*(-2 + M)*M*Sqrt[(-1 - S)/(-1 + M - S)]*Gamma[M/2]*\n                                                  Gamma[(1/2)*(5 - M + S)])))\n\nBut do not fear: we can recover. At the cost of an assumption about the tails of \\(R\\). (We’re also going to assume that \\(h\\) is bounded because it makes things ever so slightly easier, although unbounded \\(h\\) is ok18 as long as it doesn’t grow too quickly relative to \\(r\\).)\nWe are going to make the assumption that \\(R - T \\mid R\\geq T\\) is in the domain of attraction of a generalized Pareto distribution with shape parameter \\(k\\). A sufficient condition, due to von Mises, is that \\[\n\\lim_{r\\rightarrow \\infty} \\frac{r R'(r)}{1-R(r)} = \\frac{1}{k}.\n\\]\nThis seems like a weird condition, but it’s basically just a regularity condition at infinity. For example if \\(1-R(r)\\) is regularly varying at infinity19 and \\(R'(r)\\) is, eventually, monotone20 decreasing, then this condition holds.\nThe von Mises condition is very natural for us as Falk and Marohn (1993) show that the relative error we get when approximating the tail of \\(R\\) by a generalised Pareto density is the same as the relative error in the von Mises condition. That is if \\[\n\\frac{rR'(r)}{1-R(r)} = \\frac{1}{k}(1 + \\mathcal{O}(r^{-\\alpha}))\n\\] then \\[\nR'(r) = c w(cr - d)(1 + \\mathcal{O}(r^{-\\alpha})),\n\\] where \\(c,d\\) are constants and \\(w\\) is the density of a generalised Pareto distribution.\nAnyway, under those two assumptions, we can swap out the density of \\((R-T)\\mid R>T\\) with its asymptotic approximation and get that, conditional on \\(T= r_{S-M+1:S}\\), \\[\n\\mathbb{E}(H(R-T) \\mid R>T) = (k-1)^{-1}T.\n\\]\nHence, the second term in the bias goes to zero if \\[\n\\mathbb{E}\\left(r_{S-M+1:S}\\left(1 - R(r_{s-M+1:S}) - \\frac{M}{S}\\right)\\right)\n\\] goes to zero.\nNow this is not particularly pleasant, but it helps to recognise that even if a distribution doesn’t have finite moments, away from the extremes, its order statistics always do. This means that we can use Cauchy-Schwartz to get \\[\n\\left|\\mathbb{E}\\left(r_{S-M+1:S}\\left(1 - R(r_{s-M+1:S}) - \\frac{M}{S}\\right)\\right)\\right| \\leq\\mathbb{E}\\left(r_{S-M+1:S}^2\\right)^{1/2}\\mathbb{E}\\left[\\left(1 - R(r_{s-M+1:S}) - \\frac{M}{S}\\right)^2\\right]^{1/2}.\n\\]\nArguably, the most alarming term is the first one, but that can21 be tamed. To do this, we lean into a result from Bickel (1967) who, if you examine the proof and translate some obscurely-stated conditions and fix a typo22, you get that \\[\n\\mathbb{E}(r_{k:M}^2) \\leq C k\\begin{pmatrix} S \\\\ k\\end{pmatrix} \\int_0^1 t^{k-2-1}(1-t)^{S-k-2}\\,dt.\n\\] You might worry that this is going to grow too quickly. But it doesn’t. Noting that \\(B(n,m) = \\Gamma(n)\\Gamma(m)/\\Gamma(n+m)\\), we can rewrite the upper bound in terms of the Beta function to get \\[\n\\mathbb{E}(r_{k:M}^2) \\leq C \\frac{\\Gamma(S+1)}{\\Gamma(S-3)} \\frac{\\Gamma(k-2)}{\\Gamma(k+1)}\\frac{\\Gamma(S-k-1)}{\\Gamma(S-k+1)}.\n\\]\nTo show that this doesn’t grow too quickly, we use the identity \\[\n\\frac{\\Gamma(x + a)}{\\Gamma(x + b)} \\propto x^{a-b}(1 + \\mathcal{O}(x^{-1})).\n\\] From this, it follows that \\[\n\\mathbb{E}(r_{k:M}^2) \\leq C S^4k^{-3}(S-k)^{-2}(1+ \\mathcal{O}(S^{-1}))(1+ \\mathcal{O}(k^{-1}))(1+ \\mathcal{O}((S+k)^{-1})).\n\\] In this case, we are interested in \\(k = S-M+1\\), so \\[\n\\mathbb{E}(r_{k:M}^2) \\leq C S^4S^{-3}M^{-2}(1 - M/S + 1/S)^{-3}(1 - 1/M)^{-2}(1+ \\mathcal{O}(S^{-1}))(1+ \\mathcal{O}(S^{-1}))(1+ \\mathcal{O}(M^{-1})).\n\\]\nHence the we get that \\(\\mathbb{E}(r_{k:M}^2) = \\mathcal{O}(SM^{-2})\\). This is increasing23 in \\(S\\), but we will see that it is not going up too fast.\nFor the second half of this shindig, we are going to attack \\[\n\\mathbb{E}\\left[\\left(1 - R(r_{s-M+1:S}) - \\frac{M}{S}\\right)^2\\right] = \\mathbb{E}\\left[\\left(1 - R(r_{s-M+1:S})\\right)^2 - 2\\left(1 - R(r_{s-M+1:S})\\right)\\frac{M}{S} +\\left(\\frac{M}{S}\\right)^2\\right].\n\\] A standard result24 from extreme value theory is that \\(R(r_{k:S})\\) has the same distribution as the \\(k\\)th order statistics from a sample of \\(S\\) iid \\(\\text{Uniform}([0,1])\\) random variables. Hence25, \\[\nR(r_{S-M+1:S}) \\sim \\text{Beta}(S-M+1, M).\n\\] If follows26 that \\[\n\\mathbb{E}(1- R(r_{S-M+1:S})) = \\frac{M}{S+1} = \\frac{M}{S}\\frac{1}{1+S^{-1}}\n\\] and \\[\n\\mathbb{E}((1- R(r_{S-M+1:S}))^2) = \\frac{M(M+1)}{(S+1)(S+2)} = \\frac{M^2}{S^2}\\left(\\frac{1 + M^{-1}}{1 + 3S^{-1} + 2S^{-2}}\\right).\n\\] Adding these together and doing some asymptotic expansions, we get \\[\n\\mathbb{E}\\left[\\left(1 - R(r_{s-M+1:S}) - \\frac{M}{S}\\right)^2\\right] = \\frac{M^2}{S^2} + \\mathcal{O}\\left(\\frac{M}{S^2}\\right),\n\\] which goes to zero27 like \\(\\mathcal{O}(S^{-1})\\) if \\(M = \\mathcal{O}(S^{1/2})\\).\nWe can multiply this rate together and get that the second term in the bias is bounded above by \\[\n\\left[\\left(\\frac{S}{M^2} (1 + \\mathcal{O}(M^{-1} + MS^{-1}))\\right)\\left(\\frac{M^2}{S^2} (1 + \\mathcal{O}(M^{-1} + MS^{-1})\\right)\\right]^{1/2} = S^{-1/2}(1 + o(1)).\n\\]\nPutting all of this together we have proved the following Corollary.\n\nCorollary 1 Let \\(\\theta_s\\), \\(s = 1,\\ldots, S\\) be an iid sample from \\(G\\) and let \\(r_s = r(\\theta_s) \\sim R\\). Assume that\n\n\\(R\\) is absolutely continuous and satisfies the von Mises condition28 \\[\n\\frac{rR'(r)}{1-R(r)} = \\frac{1}{k}(1 +\\mathcal{O}(r^{-1})).\n\\]\n\\(M = o(S)\\)\n\\(h\\) is bounded29\n\nWinsorized importance sampling converges in \\(L^1\\) with rate of, at most, \\(\\mathcal{O}(MS^{-1} + S^{-1/2})\\), which is balanced when \\(M = \\mathcal{O}(S^{1/2})\\). Hence, WIS is30 \\(\\sqrt{n}\\)-consistent.\n\n\nVariance of Winsorized Importance Sampling\nRight, that was a bit of a journey, but let’s keep going to the variance.\nIt turns out that following the route I thought I was going to follow does not end well. That lovely set of tricks breaking up the variance into two conditional terms turns out to be very very unnecessary. Which is good, because I thoroughly failed to make the argument work.\nIf you’re curious, the problem is that the random variable \\[\n\\frac{Mr_{S-M+1:S}}{S} \\mathbb{E}(H \\mid R \\geq r_{S-M+1:S}) = \\frac{Mr_{S-M+1:S}}{S(1-R(r_{S-M+1:S}))} \\mathbb{E}(H 1_{R \\geq r_{S-M+1:S}})\n\\] is an absolute bastard to bound. The problem is that \\(1- R({r_{S-M+1:S}}) \\approx M/S\\) and so the usual trick of bounding that truncated expectation by \\(\\|h\\|\\) or some such thing will prove that the variance is finite but not that it goes to zero. There is a solid chance that the Cauchy-Schwartz inequality \\[\n\\frac{Mr_{S-M+1:S}^{1/2}}{S(1-R(r_{S-M+1:S}))} \\mathbb{E}(r_{S-M+1:S}^{1/2}H 1_{R \\geq r_{S-M+1:S}}) \\leq\\frac{Mr_{S-M+1:S}^{1/2}}{S(1-R(r_{S-M+1:S}))}R(r_{S-M+1:S})\\|h\\|_{L^2(p)}\n\\] would work. But truly that is just bloody messy31.\nSo let’s do it the easy way, shall we. Fundamentally, we will use \\[\n\\mathbb{V}\\left(I_\\text{WIS}^S\\right) \\leq \\mathbb{E}\\left([I_\\text{WIS}^S]^2\\right).\n\\] Noting that we can write \\(I_\\text{WIS}^S\\) compactly as \\[\nI_\\text{WIS}^S = \\frac{1}{S}\\sum_{s=1}^S h(\\theta_s)\\min\\{r(\\theta_s), r_{S-M+1:S}\\}.\n\\] Hence, \\[\\begin{align*}\n\\mathbb{E}\\left([I_\\text{WIS}^S]^2\\right) &= \\mathbb{E}_{T\\sim r_{S-M+1:S}}\\left[\\mathbb{E}\\left([I_\\text{WIS}^S]^2 \\mid r_{S-M+1:S} = T\\right)\\right]\\\\\n&=\\frac{1}{S^2}\\mathbb{E}_{T\\sim r_{S-M+1:S}}\\left[\\mathbb{E}\\left(H^2 \\min\\{R^2,T^2\\} \\mid r_{S-M+1:S} = T\\right)\\right]\\\\\n&\\leq\\frac{1}{S^2}\\mathbb{E}_{T\\sim r_{S-M+1:S}}\\left[\\mathbb{E}\\left(RTH^2 \\mid r_{S-M+1:S} = T\\right)\\right] \\\\\n&\\leq\\frac{1}{S^2}\\mathbb{E}_{T\\sim r_{S-M+1:S}}\\left[T\\|h\\|_{L^2(p)}^2\\right]\n\\end{align*}\\]\nThis goes to zero as long as \\(\\mathbb{E}(r_{S-M+1:S}) = o(S^2)\\).\nBickel (1967) shows that, noting that \\(\\mathbb{E}(R) < \\infty\\), \\[\n\\mathbb{E}(r_{S-M+1:S}) \\leq C (S-M+1)\\frac{\\Gamma(S+1)\\Gamma(S-M+1-1)\\Gamma(M)}{\\Gamma(S-M+1+1)\\Gamma(M+1)\\Gamma(S-1)} = \\frac{S}{M}(1 + o(1)),\n\\] and so the variance is bounded.\nThe previous argument shows that the variance is \\(\\mathcal{O}(M^{-1}S^{-1})\\). We can refine that if we assume the von Mises condition hold. In that case we know that \\(R(r) = 1- cr^{-1/k} + o(1)\\) as \\(r\\rightarrow \\infty\\) and therefore \\[\\begin{align*}\nR\\left(R^{-1}\\left(1-\\frac{M}{S}\\right)\\right) &= 1-\\frac{M}{S+1}\\\\\n1 - cR^{-1}\\left(1-\\frac{M}{S+1}\\right)^{-1/k}(1+o(1)) &= 1- \\frac{M}{S+1} \\\\\nR^{-1}\\left(1-\\frac{M}{S+1}\\right) &= c^{-k}\\left(\\frac{M}{S+1}\\right)^{-k}(1 + o(1)).\n\\end{align*}\\] Bickel (1967) shows that \\(\\mathbb{E}(r_{k:S}) = R^{-1}(1-M/(S+1)) + o(1)\\) so combining this with the previous result gives a variance of \\(\\mathcal{O}((M/S)^{k-2})\\). If we take \\(M =\\mathcal{O}(S^{1/2})\\), this gives \\(\\mathcal{S}^{k/2-1}\\), which is smaller than the previous bound for \\(k<1\\). It’s worth noting that Hence the variance goes to zero.\nThe argument that we used here is a modification of the argument in the TIS paper. This lead to a great deal of panic: did I just make my life extremely difficult? Could I have modified the TIS proof to show the bias goes to zero? To be honest, someone might be able to, but I can’t.\nSo anyway, we’ve proved the following theorem.\n\nTheorem 2 Let \\(\\theta_s\\), \\(s = 1,\\ldots, S\\) be an iid sample from \\(G\\) and let \\(r_s = r(\\theta_s) \\sim R\\). Assume that\n\n\\(R\\) is absolutely continuous\n\\(M \\rightarrow \\infty\\) and \\(M^{-1}S \\rightarrow 0\\)\n\\(h \\in L^2(p)\\).\n\nThe variance in Winsorized importance sampling is at most \\(\\mathcal{O}(M^{-1}S)\\)."
  },
  {
    "objectID": "posts/2022-06-03-that-psis-proof/that-psis-proof.html#pareto-smoothed-importance-sampling",
    "href": "posts/2022-06-03-that-psis-proof/that-psis-proof.html#pareto-smoothed-importance-sampling",
    "title": "Tail stabilization of importance sampling etimators: A bit of theory",
    "section": "Pareto-smoothed importance sampling",
    "text": "Pareto-smoothed importance sampling\nPareto-smoothed importance sampling (or PSIS) takes the observation that the tails are approximately Pareto distributed to add some bias correction to the mix. Essentially, it works by noting that approximating \\[\n(1-R(r_{S-M+1:S}))\\mathbb{E}(HR \\mid R>r_{S-M+1:S}) \\approx \\frac{1}{S}\\sum_{m=1}^M w_m h_{S-M+m:S},\n\\] where \\(w_m\\) is the median32 \\(m\\)th order statistic in an iid sample of \\(M\\) Generalised Pareto random variables with tail parameters fitted to the distribution.\nThis is a … funky … quadrature rule. To see that, we can write \\[\n\\mathbb{E}(HR \\mid R>T) = \\mathbb{E}(R \\mathbb{E}(H \\mid R)).\n\\] If we approximate the distribution of \\(R > T\\) by \\[\n\\tilde{R}_\\text{PSIS}(r) = \\frac{1}{M}\\sum_{m=1}^M 1( w_m<r)\n\\] and approximate the conditional probability by \\[\n\\Pr(H < h\\mid R = w_m) \\approx 1(h_{S-M+m:S}< h).\n\\]\nEmpirically, this is a very good choice (with the mild caveat that you need to truncate the largest expected order statistic by the observed maximum in order to avoid some variability issues). I would love to have a good analysis of why that is so, but honest I do not.\nBut, to the issue of this blog post the convergence and vanishing variance still holds. To see this, we note that \\[\nw_m = r_{S-M+1}  + k^{-1}\\sigma\\left[\\left(1-\\frac{j-1/2}{M}\\right)^{-k} -1\\right].\n\\] So we are just re-weighting our tail \\(H\\) samples by \\[\n1 + \\frac{\\sigma}{kr_{S-M+1:S}}\\left[\\left(1-\\frac{j-1/2}{M}\\right)^{-k} -1\\right].\n\\]\nRecalling that when \\(R(r) = 1- cr^{-1/k}(1+ o(1))\\), we had \\(\\sigma = \\mathcal{O}(r_{S-M+1:S})\\), this term is at most \\(\\mathcal{O}(1 + M^{-k})\\). This will not trouble either of our convergence proofs.\nThis leads to the following modification of our previous results.\n\nTheorem 3 Let \\(\\theta_s\\), \\(s = 1,\\ldots, S\\) be an iid sample from \\(G\\) and let \\(r_s = r(\\theta_s) \\sim R\\). Assume that\n\n\\(R\\) is absolutely continuous.\n\\(M = \\mathcal{O}(S^{1/2})\\)\n\\(h \\in L^2(p)\\)\n\\(k\\) and \\(\\sigma\\) are known with \\(\\sigma = \\mathcal{O}(r_{S-M+1:S})\\).\n\nPareto smoothed importance sampling converges in \\(L^1\\) and its variance goes to zero and it is consistent and asymptotically unbiased.\n\n\nCorollary 2 Assume further that\n\nR satisfies the von Mises condition33 \\[\n\\frac{rR'(r)}{1-R(r)} = \\frac{1}{k}(1 +\\mathcal{O}(r^{-1})).\n\\]\n\\(h\\) is bounded34.\n\nThen the L^1 convergence occurs at a rate of of, at most, \\(\\mathcal{O}(S^{-1/2})\\). Furthermore, the variance of the PSIS estimator goes to zero at least as fast as \\(\\mathcal{O}(S^{k/2-1})\\).\n\nHence, under these additional conditions PSIS is35 \\(\\sqrt{n}\\)-consistent."
  },
  {
    "objectID": "posts/2022-06-03-that-psis-proof/that-psis-proof.html#final-thoughts",
    "href": "posts/2022-06-03-that-psis-proof/that-psis-proof.html#final-thoughts",
    "title": "Tail stabilization of importance sampling etimators: A bit of theory",
    "section": "Final thoughts",
    "text": "Final thoughts\nSo that’s what truncation and winsorization does to importance sampling estimates. I haven’t touched on the fairly important topic of asymptotic normality. Essentially, Griffin (1988), in a fairly complex36 paper that suggests that if you winsorize the product \\((h(\\theta_s)r(\\theta_s))\\) and winsorize it at both ends, the von Mises condition37 imply that the WIS estimator is asymptotically normal.\nWhy is this important, well the same proof shows that doubly winsorized importance sampling (dWIS) applied to the vector valued function \\(\\tilde h(\\theta) = (h(\\theta),1)\\) will also be asymptotically normal, which implies, via the delta method, that the self normalized dWIS estimator \\[\nI^S_\\text{SN-IS} = \\frac{\\sum_{s=1}^S\\max\\{\\min\\{h(\\theta_i) r(\\theta_i),T_{S-M+1:S}\\}, T_{M:S}\\}}{\\sum_{s=1}^S\\max\\{\\min\\{r(\\theta_i),T_{S-M+1:S}\\},T_{M:S}\\}}\n\\] is consistent, where \\(T_{m:S}\\) is the \\(m\\)th order statistic of \\(\\max\\{h(\\theta_s)r(\\theta_s), r(\\theta_s)\\}\\).\nIt is very very likely that this can be shown (perhaps under some assumptions) for something closer to the version of PSIS we use in practice. But that is an open question."
  },
  {
    "objectID": "posts/2021-12-09-why-wont-you-cheat-with-me-repost/why-wont-you-cheat-with-me-repost.html",
    "href": "posts/2021-12-09-why-wont-you-cheat-with-me-repost/why-wont-you-cheat-with-me-repost.html",
    "title": "Why won’t you cheat with me? (Repost)",
    "section": "",
    "text": "But I got some ground rules  I’ve found to be sound rules\nand you’re not the one I’m exempting.\nNonetheless, I confess it’s tempting.\n– Jenny Toomey sings Franklin Bruno\nIt turns out that I did something a little controversial in last week’s1 post. As these things always go, it wasn’t the thing I was expecting to get push back from, but rather what I thought was a fairly innocuous scaling of the prior. One commenter (and a few other people on other communication channels) pointed out that the dependence of the prior on the design didn’t seem kosher. Of course, we (Andrew, Mike and I) wrote a paper that was sort of about this a few months ago2, but it’s one of those really interesting topics that we can probably all deal with thinking more about.\nSo in this post, I’m going to go into a couple of situations where it makes sense to scale the prior based on fixed information about the experiment. (The emerging theme for these posts is “things I think are interesting and useful but are probably not publishable” interspersed with “weird digressions into musical theatre / the personal mythology of Patti LuPone”.)\nIf you haven’t clicked yet, this particular post is going to be drier than Eve Arden in Mildred Pierce. If you’d rather be entertained, I’d recommend Tempting: Jenny Toomey sings the songs of Franklin Bruno. (Franklin Bruno is today’s stand in for Patti, because I’m still sad that War Paint closed3. I only got to see it twice.)\n(Jenny Toomey was one of the most exciting American indie musicians in the 90s both through her bands [Tsunami was the notable one, but there were others] and her work with Simple Machines, the label she co-founded. These days she’s working in musician advocacy and hasn’t released an album since the early 2000s. Bruno’s current band is called The Human Hearts. He has had a long solo career and was also in an excellent powerpop band called Nothing Painted Blue, who had an album called The Monte Carlo Method. And, now4 that I live in Canada, I should say that that album has a fabulous cover of Mark Szabo’s I Should Be With You. To be honest, the only reason I work with Andrew and the Stan crew is that I figure if I’m in New York often enough I’ll eventually coincide with a Human Hearts concert5.)"
  },
  {
    "objectID": "posts/2021-12-09-why-wont-you-cheat-with-me-repost/why-wont-you-cheat-with-me-repost.html#sparsity",
    "href": "posts/2021-12-09-why-wont-you-cheat-with-me-repost/why-wont-you-cheat-with-me-repost.html#sparsity",
    "title": "Why won’t you cheat with me? (Repost)",
    "section": "Sparsity",
    "text": "Sparsity\n\nWhy won’t you cheat with me? You and I both know you’ve done it before. – Jenny Toomey sings Franklin Bruno\n\nThe first object of our affliction are priors that promote sparsity in high-dimensional models. There has been a lot of work on this topic, but the cheaters guide is basically this:\n\nWhile spike-and-slab models can exactly represent sparsity and have excellent theoretical properties, they are basically useless from a computational point of view. So we use scale-mixture of normal priors (also known as local-global priors) to achieve approximate sparsity, and then use some sort of decision rule to take our approximately sparse signal and make it exactly sparse.\n\nWhat is a scale-mixture of normals? Well it has the general form \\[\n\\beta_j \\sim N(0, \\tau^2 \\psi^2_j),\n\\] where \\(\\tau\\) is a global standard deviation parameter, controlling how large the \\(\\beta_j\\) parameters are in general6, while the local standard deviation parameters \\(\\psi_j\\) control how big \\(\\beta_j\\) is relative to the other \\(\\beta\\)s.\nThe priors for \\(\\tau\\) and the \\(\\psi_j\\) are typically set to be independent. A lot of theoretical work just treats \\(\\tau\\) as fixed (or as otherwise less important than the local parameters), but this is wrong.\nPedant’s corner: Andrew likes define mathematical statisticians as those who use \\(x\\) for their data rather than \\(y\\). I prefer to characterise them by those who think it’s a good idea to put a prior on variance (an un-elicitable quantity) rather than standard deviation (which is easy to have opinions about). Please people just stop doing this. You’re not helping yourselves!\nActually, maybe that last point isn’t for Pedant’s Corner after all. Because if you parameterise by standard deviation it’s pretty easy to work out what the marginal prior on \\(\\beta_j\\) (with \\(\\tau\\) fixed) is.\nThis is quite useful because, with the notable exception of the “Bayesian” “Lasso” which-does-not-work-but-will-never-die-because-it-was-inexplicably-published-in-the leading-stats-journal-by-prominent-statisticians-and-has-the-word-Lasso-in-the-title-even-though-a-back-of-the-envelope-calculation-or-I-don’t-know-a-fairly-straightforward-simulation-by-the-reviewers-should-have-nixed-it (to use its married name), we can’t compute the marginal prior for most scale-mixtures of normals.\nThe following result, which was killed by reviewers at some point during the PC prior papers long review process, but lives forever in the arXiv’d first version, tells you everything you need to know. It’s a picture because frankly I’ve had a glass of wine and I’m not bloody typing it all again7.\n\nTheorem 1 Let \\(\\pi_d(r)\\) be a prior on the standard deviation of \\(v \\sim {\\mathcal N}(0,r^2)\\). The induced prior \\[\n\\pi(v) = \\int_0^\\infty\n\\frac{1}{2\\pi r}\\exp\\left({-\\frac{v^2}{2r^2}}\\right)\\pi_d(r)\\,dr\n\\] has the following properties. Fix \\(\\delta> 0\\).\n\nIf \\(\\pi_d(r) \\leq Cr^t\\) for all \\(r \\in [0,\\delta]\\) and for some \\(C,t >0\\), then \\(\\pi(v)\\) is finite at \\(v=0\\).\nIf \\(\\pi_d(r) \\in (0,\\infty)\\) for every \\(r \\in [0,\\delta]\\), then \\(\\pi(v)\\) has a weak logarithmic spike at zero, that is \\[\n\\pi(v) = \\mathcal{O}\\left[\\log\\left(1 +\n                                   \\frac{\\delta^2}{v^2}\\right)\\right], \\qquad v \\rightarrow 0.\n\\]\nIf \\(\\int_0^\\delta \\frac{1}{2\\pi  r}\\exp\\left({-\\frac{v^2}{2r^2}}\\right)\\pi_d(r)\\,dr <  \\infty\\), then \\[\n\\pi(v) \\geq\n\\mathcal{O}\\left(v^{-2}\\exp\\left(-\\frac{v^2}{2\\delta^2}\\right)\\right),\n\\qquad |v| \\rightarrow \\infty.\n\\]\nIf \\(\\pi_d(r) {\\leq}({\\geq}) Cr^{-t}\\) for all \\(r \\in [0,\\delta]\\) and for some \\(C,t >0\\), then \\[\n\\pi(v)\n{\\leq}({\\geq}) \\mathcal{O}(|v|^{-t}),\\qquad v \\rightarrow 0.\n\\]\nIf \\(\\pi_d(r) {\\leq}({\\geq}) Cr^{-t}\\) for all \\(r >\\delta\\) and for some \\(C,t >0\\), then \\[\n\\pi(v)\n{\\leq}({\\geq}) \\mathcal{O}(|v|^{-t}),\\qquad |v| \\rightarrow\n\\infty.\n\\]\n\n\n\n\nThe proof is here.\n\nFor any \\(\\delta > 0\\), \\[\n\\pi(v) =\n\\int_0^\\delta\\frac{1}{2\\pi r}\n\\exp\\left({-\\frac{v^2}{2r^2}}\\right)\n\\pi_d(r)\\,dr +\n\\int_\\delta^\\infty\\frac{1}{2\\pi\nr}\\exp\\left({-\\frac{v^2}{2r^2}}\\right)\n\\pi_d(r)\\,dr = I_1 + I_2.\n\\] Examining this splitting, we note that \\(I_1\\) will control the behaviour of \\(\\pi(v)\\) near zero, while \\(I_2\\) will control the tails.\nAssuming that \\(\\int_\\delta^\\infty r^{-1}\\pi_d(r)\\,dr < \\infty\\), we can bound \\(I_2\\) as \\[\n\\frac{1}{2\\pi }\\exp\\left({-\\frac{v^2}{2\\delta^2}}\\right)\n\\int_\\delta^\\infty r^{-1}\\pi_d(r)\\,dr \\leq I_2 \\leq \\frac{1}{2\\pi}\n\\int_\\delta^\\infty r^{-1}\\pi_d(r)\\,dr.\n\\]\nTo prove part 1, let \\(\\pi_d(r) \\leq Cr^t\\), \\(r \\in [0,\\delta]\\) for some \\(t>0\\). Substituting this into \\(I_1\\) and computing the resulting integral using Maple8, we get \\[\\begin{align*}\nI_1 &\\leq - \\frac{C}{2\\pi t}\\left( {2}^{-1/2\\,t}{|v|}^{t}\\Gamma\n\\left( 1-1/2\\,t,1/2\\,{\\frac {v^2}{{\\delta}^{2}}} \\right) -{{\\rm\ne}^{-1/2\\,{\\frac {v^2}{{\\delta}^{2}}}} }{\\delta}^{t}\n\\right) = \\mathcal{O}(1),\n\\end{align*}\\] where \\(\\Gamma(a,x) = \\int_x^\\infty \\exp\\left({-t}\\right)t^{a-1}\\,dt\\) is the incomplete Gamma function.\nTo prove parts 2 and 3, we bound \\(I_1\\) as follows. \\[\\begin{align*}\n\\left(\\inf_{r\\in[0,\\delta]} \\pi_d(r)\n\\right)\\int_0^\\delta\\frac{1}{2\\pi\nr}\\exp\\left({-\\frac{v^2}{2r^2}}\\right) \\,dr &\\leq I_1 \\leq\n\\left(\\sup_{r\\in[0,\\delta]} \\pi_d(r)\n\\right)\\int_0^\\delta\\frac{1}{2\\pi r}\\exp\\left({-\\frac{v^2}{2r^2}}\\right) \\\\\n\\frac{1}{4\\pi}\\left(\\inf_{r\\in[0,\\delta]} \\pi_d(r)\\right)\n\\text{E}_1\\left(\\frac{v^2}{2\\delta^2}\\right) & \\leq I_1 \\leq\n\\frac{1}{4\\pi}\\left(\\sup_{r\\in[0,\\delta]} \\pi_d(r)\\right)\n\\text{E}_1\\left(\\frac{v^2}{2\\delta^2}\\right) \\\\\n\\frac{1}{8\\pi}\\left(\\inf_{r\\in[0,\\delta]} \\pi_d(r)\\right)\n\\exp\\left({-\\frac{v^2}{2\\delta^2}}\\right)\\log\\left( 1 +\n\\frac{4\\delta^2}{v^2}\\right) &\\leq I_1\n\\leq\\frac{1}{4\\pi}\\left(\\sup_{r\\in[0,\\delta]} \\pi_d(r)\\right)\n\\exp\\left({-\\frac{v^2}{2\\delta^2}}\\right)\\log\\left( 1 +\n\\frac{2\\delta^2}{v^2}\\right),\n\\end{align*}\\] where \\(\\text{E}_1(x) = \\int_1^\\infty t^{-1}\\exp\\left({-tx}\\right)\\,dt\\) and the third line of inequalities follows using standard bounds in the exponential integral9.\nCombining the lower and upper bounds, it follows that if \\(0 <\\inf_{r\\in[0,\\delta]} \\pi_d(r) \\leq \\sup_{r\\in[0,\\delta]} \\pi_d(r) < \\infty\\), then \\(\\pi(v)\\) has a logarithmic spike near zero. Similarly, the lower bounds show that \\(\\pi(v) \\geq C v^{-2}\\exp\\left(-\\frac{v^2}{2\\delta^2}\\right)\\) as \\(v\\rightarrow \\infty\\).\nPart 4 follows by considering let \\(\\pi_d(r) = Cr^{-t}\\), \\(r \\in [0,\\delta]\\) for some \\(t>0\\). Substituting this into \\(I_1\\) and computing the resulting integral using Maple, we get \\[\\begin{align*}\nI_1 & = \\frac{C}{2\\pi t}\\left( {|v|}^{-t}\\Gamma \\left(\n1+1/2\\,t,1/2\\,{\\frac {v^2}{{\\delta}^{2}}} \\right)\n{2}^{t/2}-{\\delta}^{-t}{{\\rm e}^{-1/2\\,{\\frac\n{v^2}{{\\delta}^{2}}}}} \\right) \\sim\n\\mathcal{O}(v^{-t})\n\\end{align*}\\] as \\(v \\rightarrow 0\\). We note that \\(I_1 = \\mathcal{O}\\left(\\exp\\left(-v^2/(2\\delta^2)\\right)\\right)\\) as \\(|v| \\rightarrow \\infty\\).\nTo prove part 5, let \\(\\pi_d(r) = Cr^{-t}\\), \\(r \\in (\\delta,\\infty)\\) for some \\(t>0\\). Substituting this into \\(I_2\\), we get \\[\\begin{align*}\nI_2 = \\frac{C}{8\\pi^2}\\,{2}^{1/2\\,t}{|v|}^{-t} \\left( \\Gamma\n\\left( 1/2\\,t \\right) - \\Gamma \\left( 1/2\\,t,1/2\\,{\\frac\n{{v}^{2}}{{\\delta}^{2}}} \\right) \\right) =\n\\mathcal{O}(|v|^{-t}),\n\\end{align*}\\] where we used the identity \\[\n\\Gamma \\left( 1/2\\,t \\right) - \\Gamma\n\\left( 1/2\\,t,1/2\\,{\\frac {{v}^{2}}{{\\delta}^{2}}} \\right)\n\\rightarrow \\Gamma\\left( 1/2\\,t \\right)\n\\] as \\(|v|\\rightarrow \\infty\\).\nDone.\n\nAll of this basically says the following:\n\nIf the density of the prior on the standard deviation is finite at zero, then the implied prior on \\(\\beta_j\\) has a logarithmic spike at zero.\nIf the density of the prior on the standard has a polynomial tail, then the implied prior on \\(\\beta_j\\) has the same polynomial tail.\nNot in the result, but computed at the time: if the prior on the standard deviation is exponential, the prior on \\(\\beta_j\\) still has Gaussian-ish tails. I couldn’t work out what happened in the hinterland between exponential tails and polynomial tails, but I suspect at some point the tail on the standard deviation does eventually get heavy enough to be seen in the marginal, but I can’t tell you when.)\n\nWith this sort of information, you can compute the equivalent of the bounds that I did on the Laplace prior for the general case (or, actually, for the case that will have at least a little bit of a chance, which is the monotonically decreasing priors on the standard deviation).\nIn particular, if you run the argument from the last post, you see that you need a quite heavy tail on the standard deviation prior to get a reasonable prior on the implied sparsity. In particular, we showed that applying this reasoning to the horseshoe prior, where the prior on the local standard deviation is half-Cauchy, you can see that there is a \\(\\lambda\\) that gives a priori weight on \\(p^{-1}\\)-sparse signals, while also letting you have a few very large \\(\\beta_j\\)s.\n\nThe design-scaling in these priors links directly to an implied decision process\n\nYou’d look better if your shadow didn’t follow you around, but it looks as though you’re tethered to the ground, just like every pound of flesh I’ve ever found. – Franklin Bruno in a sourceless light.\n\nFor a very simple decision process (the deterministic threshold process described in the previous post), you can work out exactly how the threshold needs to interact with the prior. In particular, we can see that if we’re trying to detect a true signal that is exactly zero (no components are active), then we know that \\(latex \\| \\mathbf{X} \\boldsymbol{\\beta} \\| = 0\\). This is not possible for these scale-mixture models, but we can require that in this case all of the components are at most \\(latex \\epsilon\\), in which case \\[\n\\| \\mathbf{X}\\boldsymbol{\\beta} \\| \\leq \\epsilon \\| \\mathbf{X} \\|,\n\\] which suggests we want \\(\\epsilon \\ll \\| \\mathbf{X} \\|_\\infty^{-1}\\). The calculation in the previous post shows that if we want this sort of almost zero signal to have any mass at all under the prior, we need to scale \\(\\lambda\\) using information about \\(\\mathbf{X}\\).\nOf course, this is a very very simple decision process. I have absolutely no idea how to repeat these arguments for actually good decision processes, like the predictive loss minimization favoured by Aki. But I’d still expect that we’d need to make sure there was a priori enough mass in the areas of the parameter space where the decision process is firmly one way or another (as well as mass in the indeterminate region). I doubt that the Bayesian Lasso would magically start to work under these more complex losses."
  },
  {
    "objectID": "posts/2021-12-09-why-wont-you-cheat-with-me-repost/why-wont-you-cheat-with-me-repost.html#models-specified-through-their-full-conditionals",
    "href": "posts/2021-12-09-why-wont-you-cheat-with-me-repost/why-wont-you-cheat-with-me-repost.html#models-specified-through-their-full-conditionals",
    "title": "Why won’t you cheat with me? (Repost)",
    "section": "Models specified through their full conditionals",
    "text": "Models specified through their full conditionals\n\nWhy won’t you cheat with me? You and I both know that he’s done the same. – Franklin Bruno\n\nSo we can view the design dependence of sparsity priors as preparation for the forthcoming decision process. (Those of you who just mentally broke into Prepare Ye The Way Of The Lord from Godspell, please come to the front of the class. You are my people.) Now let’s talk about a case where this isn’t true.\nTo do this, we need to cast our minds back to a time when people really did have the original cast recording of Godspell on their mind. In particular, we need to think about Julian Besag (who I’m sure was really into musicals about Jesus. I have no information to the contrary, so I’m just going to assume it’s true.) who wrote a series of important papers, one in 1974 and one in 1975 (and several before and after, but I can’t be arsed linking to them all. We all have google.) about specifying models through conditional independence relations.\nThese models have a special place in time series modelling (where we all know about discrete-time Markovian processes) and in spatial statistics. In particular, generalisations of Besag’s (Gaussian) conditional autoregressive (CAR) models are widely used in spatial epidemiology.\nMathematically, Gaussian CAR models (and more generally Gaussian Markov random fields on graphs) are defined through their precision matrix, that is the inverse of the covariance matrix as \\[\n\\mathbf{x} \\sim N(\\mathbf{0}, \\tau^{-1}\\mathbf{Q}^{-1}).\n\\]\nFor simple models, such as the popular CAR model, we assume \\(\\mathbf{Q}\\) is fixed, known, and sparse (i.e. it has a lot of zeros) and we typically interpret \\(\\tau\\) to be the inverse of the variance of \\(\\mathbf{x}\\).\nThis interpretation of \\(\\tau\\) could not be more wrong.\nWhy? Well, let’s look at the marginal distribution \\[\nx_j \\sim N\\left(0, \\tau^{-1}[Q^{-1}]_{ii}\\right).\n\\]\nTo interpet \\(\\tau\\) and the inverse variance, we need the diagonal elements of \\(\\mathbf{Q}^{-1}\\) to all be around 1. This is never the case.\nA simple, mathematically tractable example is the first order random walk on a one-dimensional lattice, which can be written in terms of the increment process as \\[\nx_{j+1} - x_j \\sim N(0, \\tau^{-1}), \\qquad j = 1, \\ldots J-1.\n\\]\nConditioned on a particular starting point, this process looks a lot like a discrete version of Brownian motion as you move the lattice points closer together. This is a useful model for rough non-linear random effects, such as the baseline hazard rate in a Cox proportional hazard model. A long and detailed (and quite general) discussion of these models can be found in Rue and Held’s book.\nI am bringing this case up because you can actually work out the size of the diagonal of \\(\\mathbf{Q}^{-1}\\). Sørbye and Rue talk about this in detail, but for this model maybe the easiest way to understand it is that if we had a fixed lattice with \\(n\\) points and we’d carefully worked out a sensible prior for \\(\\tau\\). Now imagine that we’ve gotten some new data and instead of only \\(n\\) points in the lattice, we got information at a finer scale, so now the same interval is covered by \\(nk\\) equally spaced nodes. We model this with the new first order random walk prior \\[\nx'_{j+1} - x'_j \\sim N(0,[\\tau']^{-1}).\n\\]\nIt turns out that we can relate the inverse variances of these two increment processes as \\(\\tau' = J \\tau\\).\nThis strongly suggests that we should not use the same prior for \\(\\tau\\) as we should for \\(\\tau'\\), but that the prior should actually know about how many nodes there are on the lattice. Concrete suggestions are in the Sørbye and Rue paper linked above.\n\nDesign dependence for Markov random fields\n\nNot to coin a phrase, but play it as it lays – Franklin Bruno in Nothing Painted Blue\n\nThis type of design dependence is a general problem for multivariate Gaussian models specified through their precision (so-called Gaussian Markov random fields). The critical thing here is that, unlike the sparsity case, the design dependence does not come from some type of decision process. It comes from the gap between the parameterisation (in terms of \\(\\tau\\) and \\(\\mathbf{Q}\\)) and the elicitable quantity (the scale of the random effect).\nThis is kinda a general lesson. When specifying multivariate priors, you must always check the implications of your prior on the one- and two-dimensional quantities of interest. Because weird things happen in multivariate land!"
  },
  {
    "objectID": "posts/2021-12-09-why-wont-you-cheat-with-me-repost/why-wont-you-cheat-with-me-repost.html#gaussian-process-models",
    "href": "posts/2021-12-09-why-wont-you-cheat-with-me-repost/why-wont-you-cheat-with-me-repost.html#gaussian-process-models",
    "title": "Why won’t you cheat with me? (Repost)",
    "section": "Gaussian process models",
    "text": "Gaussian process models\n\nAnd it’s not like we’re tearing down a house of more than gingerbread. It’s not like we’re calling down the wrath of heaven on our heads. – Jenny Toomey sings Franklin Bruno\n\nSo the design dependence doesn’t necessarily come in preparation for some kind of decision, it can also be because we have constructed (and therefore parameterised) our process in an inconvenient way. Let’s see if we can knock out another one before my bottle of wine dies.\nGaussian processes, the least exciting tool in the machine learner’s toolbox, are another example where your priors need to be design dependent. It will probably surprise you not a single sausage that in this case the need for design dependence comes from a completely different place.\nFor simplicity let’s consider a Gaussian process \\(f(t)\\) in one dimension with isotropic covariance function \\[\nc(s,t) =\\sigma^2 (\\kappa|s-t|)^\\nu K_\\nu(|\\kappa|s-t|).\n\\]\nThis is the commonly encountered Whittle-Matérn family of covariance functions. The distinguished members are the exponential covariance function when \\(\\nu = 0.5\\) and the squared exponential function \\[\nc(s,t)= \\sigma^2\\exp\\left(\\kappa |s-t|^2 \\right),\n\\]\nwhich is the limit as \\(\\nu \\rightarrow \\infty\\).\nOne of the inconvenient features of Matérn models in 1-3 dimensions is that it is impossible to consistently recover all of the parameters by simply observing more and more of the random effect on a fixed interval. You need to see new replicates in order to properly pin these down10.\nSo one might expect that this non-identifiability would be the source of some problems.\nOne would be wrong.\nThe squared exponential covariance function does not have this pathology, but it’s still very very hard to fit. Why? Well the problem is that you can interpret \\(\\kappa\\) as an inverse-range parameter. Roughly, the interpretation is that if \\[\n|s - t | > \\frac{ \\sqrt{ 8 \\nu } }{\\kappa}\n\\] then the value of \\(u(s)\\) is approximately independent of the value of \\(u(t)\\).\nThis means that a fixed data set provides no information about \\(\\kappa\\) in large parts of the parameter space. In particular if \\(\\kappa^{-1}\\) is bigger than the range of the measurement locations, then the data has almost no information about the parameter.\nSimilarly, if \\(\\kappa^{-1}\\) is smaller than the smallest distance between two data points (or for irregular data, this should be something like “smaller than some low quantile of the set of distances between points”), then the data will have nothing to say about the parameter.\nOf these two scenarios, it turns out that the inference is much less sensitive to the prior on small values of \\(\\kappa\\) (ie ranges longer than the data) than it is on small values of \\(\\kappa\\) (ie ranges shorter than the data).\nCurrently, we have two recommendations: one based around PC priors and a very similar one based around inverse gamma priors. But both of these require you to specify the design-dependent quantity of a “minimum length scale we expect this data set to be informative about”.\n\nDesign for Gaussian processes (I’d say “Designing Women”, but I’m aware of the demographics)\n\nI’m a disaster, you’re a disaster, we’re a disaster area. – Franklin Bruno in The Human Hearts (featuring alto extraordinaire and cabaret god Ms Molly Pope)\n\nSo in this final example we hit our ultimate goal. A case where design dependent priors are needed not because of a hacky decision process, or an awkward multivariate specification, but due to the limits of the data. In this case, priors that do not recognise the limitation of the design of the experiment will lead to poorly behaving posteriors. This manifests as the Gaussian processes severely over-fitting the data.\nThis is the ultimate expression of the point that we tried to make in the Entropy paper: The prior can often only be understood in the context of the likelihood."
  },
  {
    "objectID": "posts/2021-12-09-why-wont-you-cheat-with-me-repost/why-wont-you-cheat-with-me-repost.html#principles-can-only-get-you-so-far",
    "href": "posts/2021-12-09-why-wont-you-cheat-with-me-repost/why-wont-you-cheat-with-me-repost.html#principles-can-only-get-you-so-far",
    "title": "Why won’t you cheat with me? (Repost)",
    "section": "Principles can only get you so far",
    "text": "Principles can only get you so far\n\nI’m making scenes, you’re constructing dioramas – Franklin Bruno in Nothing Painted Blue\n\nJust to round this off, I guess I should mention that the strong likelihood principle really does suggest that certain details of the design are not relevant to a fully Bayesian analysis. In particular, if the design only pops up in the normalising constant of the likelihood, it should not be relevant to a Bayesian. This seems at odds with everything I’ve said so far.\nBut it’s not.\nIn each of these cases, the design was only invoked in order to deal with some external information. For sparsity, design was needed to properly infer a sparse signal and came in through the structure of the decision process.\nFor the CAR models, the external information was that the elicitable quantity was the marginal standard deviation, which was a complicated function of the design and the standard parameter.\nFor Gaussian processes, the same thing happened: the implicit decision criterion was that we wanted to make good predictions. The design told us which parts of the parameter space obstructed this goal, and a well specified prior removed the problem.\nThere are also any number of cases in real practice where the decision at hand is stochastically dependent on the data gathering mechanism. This is why things like MRP exist.\nI guess this is the tl;dr version of this post (because apparently I’m too wordy for some people. I suggest they read other things. Of course suggesting this in the final paragraph of such a wordy post is very me.):\nDesign matters even if you’re Bayesian. Especially if you want to do something with your posterior that’s more exciting than just sitting on it.\nEdited from an original blog, posted November 2017."
  },
  {
    "objectID": "posts/2022-05-18-sparse4-some-primatives/sparse4-some-primatives.html",
    "href": "posts/2022-05-18-sparse4-some-primatives/sparse4-some-primatives.html",
    "title": "Sparse Matrices 5: I bind you Nancy",
    "section": "",
    "text": "This is part five of our ongoing series on implementing differentiable sparse linear algebra in JAX. In some sense this is the last boring post before we get to the derivatives. Was this post going to include the derivatives? It sure was but then I realised that a different choice was to go to bed so I can get up nice and early in the morning and vote in our election.\nIt goes without saying that before I split the posts, it was more than twice as long and I was nowhere near finished. So probably the split was a good choice."
  },
  {
    "objectID": "posts/2022-05-18-sparse4-some-primatives/sparse4-some-primatives.html#but-how-do-you-add-a-primative-to-jax",
    "href": "posts/2022-05-18-sparse4-some-primatives/sparse4-some-primatives.html#but-how-do-you-add-a-primative-to-jax",
    "title": "Sparse Matrices 5: I bind you Nancy",
    "section": "But how do you add a primative to JAX?",
    "text": "But how do you add a primative to JAX?\nWell, the first step is you read the docs.\nThey tell you that you need to implement a few things:\n\nAn implementation of the call with “abstract types”\nAn implementation of the call with concrete types (aka evaluation the damn function)\n\nThen,\n\nif you want your primitive to be JIT-able, you need to implement a compilation rule.\nif you want your primitive to be batch-able, you need to implement a batching rule.\nif you want your primitive to be differentiable, you need to implement the derivatives in a way that allows them to be propagated appropriately.\n\nIn this post, we are going to do the first task: we are going to register JAX-traceable versions of the four main primitives we are going to need for our task. For the most part, the implementations here will be replaced with C++ bindings (because only a fool writes their own linear algebra code). But this is the beginning1 of our serious journey into JAX."
  },
  {
    "objectID": "posts/2022-05-18-sparse4-some-primatives/sparse4-some-primatives.html#first-things-first-some-primitives",
    "href": "posts/2022-05-18-sparse4-some-primatives/sparse4-some-primatives.html#first-things-first-some-primitives",
    "title": "Sparse Matrices 5: I bind you Nancy",
    "section": "First things first, some primitives",
    "text": "First things first, some primitives\nIn JAX-speak, a primitive is a function that is JAX-traceable2. It is not necessary for every possible transformation to be implemented. In fact, today I’m not going to implement any transformations. That is a problem for future Dan.\nWe have enough today problems.\nBecause today we need to write four new primitives.\nBut first of all, let’s build up a test matrix so we can at least check that this code runs. This is the same example from blog 3. You can tell my PhD was in numerical analysis because I fucking love a 2D Laplacian.\n\nfrom scipy import sparse\nimport numpy as np\n\ndef make_matrix(n):\n    one_d = sparse.diags([[-1.]*(n-1), [2.]*n, [-1.]*(n-1)], [-1,0,1])\n    A = (sparse.kronsum(one_d, one_d) + sparse.eye(n*n)).tocsc()\n    A_lower = sparse.tril(A, format = \"csc\")\n    A_index = A_lower.indices\n    A_indptr = A_lower.indptr\n    A_x = A_lower.data\n    return (A_index, A_indptr, A_x, A)\n\nA_indices, A_indptr, A_x, A = make_matrix(10)\n\n\nPrimitive one: \\(A^{-1}b\\)\nBecause I’m feeling lazy today and we don’t actually need the Cholesky directly for any of this, I’m going to just use scipy. Why? Well, honestly, just because I’m lazy. But also so I can prove an important point: the implementation of the primitive does not need to be JAX traceable. So I’m implementing it in a way that is not now and will likely never be JAX traceable3.\nFirst off, we need to write the solve function and bind it4 to JAX. Specific information about what exactly some of these commands are doing can be found in the docs, but the key thing is that there is no reason to dick around whit JAX types in any of these implementation functions. They are only ever called using (essentially) numpy5 arrays. So we can just program like normal human beings.\n\nfrom jax import numpy as jnp\nfrom jax import core\n\nsparse_solve_p = core.Primitive(\"sparse_solve\")\n\ndef sparse_solve(A_indices, A_indptr, A_x, b):\n  \"\"\"A JAX traceable sparse solve\"\"\"\n  return sparse_solve_p.bind(A_indices, A_indptr, A_x, b)\n\n@sparse_solve_p.def_impl\ndef sparse_solve_impl(A_indices, A_indptr, A_x, b):\n  \"\"\"The implementation of the sparse solve. This is not JAX traceable.\"\"\"\n  A_lower = sparse.csc_array((A_x, A_indices, A_indptr)) \n  \n  assert A_lower.shape[0] == A_lower.shape[1]\n  assert A_lower.shape[0] == b.shape[0]\n  \n  A = A_lower + A_lower.T - sparse.diags(A_lower.diagonal())\n  return sparse.linalg.spsolve(A, b)\n\n## Check it works\nb = jnp.ones(100)\nx = sparse_solve(A_indices, A_indptr, A_x, b)\n\nprint(f\"The error in the sparse sovle is {np.sum(np.abs(b - A @ x)): .2e}\")\n\nThe error in the sparse sovle is  0.00e+00\n\n\nIn order to facilitate its transformations, JAX will occasionally6 call functions using abstract data types. These data types know the shape of the inputs and their data type. So our next step is to specialise the sparse_solve function for this case. We might as well do some shape checking while we’re just hanging around. But the essential part of this function is just saying that the output of \\(A^{-1}b\\) is the same shape as \\(b\\) (which is usually a vector, but the code is no more complex if it’s a [dense] matrix).\n\nfrom jax._src import abstract_arrays\n\n@sparse_solve_p.def_abstract_eval\ndef sparse_solve_abstract_eval(A_indices, A_indptr, A_x, b):\n  assert A_indices.shape[0] == A_x.shape[0]\n  assert b.shape[0] == A_indptr.shape[0] - 1\n  return abstract_arrays.ShapedArray(b.shape, b.dtype)"
  },
  {
    "objectID": "posts/2022-05-18-sparse4-some-primatives/sparse4-some-primatives.html#primitive-two-the-triangular-solve",
    "href": "posts/2022-05-18-sparse4-some-primatives/sparse4-some-primatives.html#primitive-two-the-triangular-solve",
    "title": "Sparse Matrices 5: I bind you Nancy",
    "section": "Primitive two: The triangular solve",
    "text": "Primitive two: The triangular solve\nThis is very similar. We need to have a function that computes \\(L^{-1}b\\) and \\(L^{-T}b\\). The extra wrinkle from the last time around is that we need to pass a keyword argument transpose to indicate which system should be solved.\nOnce again, we are going to use the appropriate scipy function (in this case sparse.linalg.spsolve_triangular). There’s a little bit of casting between sparse matrix types here as sparse.linalg.spsolve_triangular assumes the matrix is in CSR format.\n\nsparse_triangular_solve_p = core.Primitive(\"sparse_triangular_solve\")\n\ndef sparse_triangular_solve(L_indices, L_indptr, L_x, b, *, transpose: bool = False):\n  \"\"\"A JAX traceable sparse  triangular solve\"\"\"\n  return sparse_triangular_solve_p.bind(L_indices, L_indptr, L_x, b, transpose = transpose)\n\n@sparse_triangular_solve_p.def_impl\ndef sparse_triangular_solve_impl(L_indices, L_indptr, L_x, b, *, transpose = False):\n  \"\"\"The implementation of the sparse triangular solve. This is not JAX traceable.\"\"\"\n  L = sparse.csc_array((L_x, L_indices, L_indptr)) \n  \n  assert L.shape[0] == L.shape[1]\n  assert L.shape[0] == b.shape[0]\n  \n  if transpose:\n    return sparse.linalg.spsolve_triangular(L.T, b, lower = False)\n  else:\n    return sparse.linalg.spsolve_triangular(L.tocsr(), b, lower = True)\n\nNow we can check if it works. We can use the fact that our matrix (A_indices, A_indptr, A_x) is lower-triangular (because we only store the lower triangle) to make our test case.\n\n## Check if it works\nb = np.random.standard_normal(100)\nx1 = sparse_triangular_solve(A_indices, A_indptr, A_x, b)\nx2 = sparse_triangular_solve(A_indices, A_indptr, A_x, b, transpose = True)\nprint(f\"\"\"Error in trianglular solve: {np.sum(np.abs(b - sparse.tril(A) @ x1)): .2e}\nError in triangular transpose solve: {np.sum(np.abs(b - sparse.triu(A) @ x2)): .2e}\"\"\")\n\nError in trianglular solve:  3.53e-15\nError in triangular transpose solve:  5.08e-15\n\n\nAnd we can also do the abstract evaluation.\n\n@sparse_triangular_solve_p.def_abstract_eval\ndef sparse_triangular_solve_abstract_eval(L_indices, L_indptr, L_x, b, *, transpose = False):\n  assert L_indices.shape[0] == L_x.shape[0]\n  assert b.shape[0] == L_indptr.shape[0] - 1\n  return abstract_arrays.ShapedArray(b.shape, b.dtype)\n\nGreat! Now on to the next one!\n\nPrimitive three: The sparse cholesky\nOk. This one is gonna be a pain in the arse. But we need to do it. Why? Because we are going to need a JAX-traceable version further on down the track.\nThe issue here is that the non-zero pattern of the Cholesky decomposition is computed on the fly. This is absolutely not allowed in JAX. It must know the shape of all things at the moment it is called.\nThis is going to make for a somewhat shitty user experience for this function. It’s unavoidable with JAX designed7 the way it is.\nThe code in jax.experimental.sparse.bcoo.fromdense has this exact problem. In their case, they are turning a dense matrix into a sparse matrix and they can’t know until they see the dense matrix how many non-zeros there are. So they do the sensible thing and ask the user to specify it. They do this using the nse keyword parameter. If you’re curious what nse stands for, it turns out it’s not “non-standard evaluation” but rather “number of specified entries”. Most other systems use the abbreviation nnz for “number of non-zeros”, but I’m going to stick with the JAX notation.\nThe one little thing we need to add to this code is a guard to make sure that if the sparse_cholesky function is called without specifying\n\nsparse_cholesky_p = core.Primitive(\"sparse_cholesky\")\n\ndef sparse_cholesky(A_indices, A_indptr, A_x, *, L_nse: int = None):\n  \"\"\"A JAX traceable sparse cholesky decomposition\"\"\"\n  if L_nse is None:\n    err_string = \"You need to pass a value to L_nse when doing fancy sparse_cholesky.\"\n    _ = core.concrete_or_error(None, A_x, err_string)\n  return sparse_cholesky_p.bind(A_indices, A_indptr, A_x, L_nse = L_nse)\n\n@sparse_cholesky_p.def_impl\ndef sparse_cholesky_impl(A_indices, A_indptr, A_x, *, L_nse = None):\n  \"\"\"The implementation of the sparse cholesky This is not JAX traceable.\"\"\"\n  \n  L_indices, L_indptr= _symbolic_factor(A_indices, A_indptr)\n  if L_nse is not None:\n    assert len(L_indices) == nse\n    \n  L_x = _structured_copy(A_indices, A_indptr, A_x, L_indices, L_indptr)\n  L_x = _sparse_cholesky_impl(L_indices, L_indptr, L_x)\n  return L_indices, L_indptr, L_x\n\nThe rest of the code is just the sparse Cholesky code from blog 2 and I’ve hidden it under the fold. (You would think I would package this up properly, but I simply haven’t. Why not? Who knows8.)\n\n\nClick here to see the implementation\n\n\ndef _symbolic_factor(A_indices, A_indptr):\n  # Assumes A_indices and A_indptr index the lower triangle of $A$ ONLY.\n  n = len(A_indptr) - 1\n  L_sym = [np.array([], dtype=int) for j in range(n)]\n  children = [np.array([], dtype=int) for j in range(n)]\n  \n  for j in range(n):\n    L_sym[j] = A_indices[A_indptr[j]:A_indptr[j + 1]]\n    for child in children[j]:\n      tmp = L_sym[child][L_sym[child] > j]\n      L_sym[j] = np.unique(np.append(L_sym[j], tmp))\n    if len(L_sym[j]) > 1:\n      p = L_sym[j][1]\n      children[p] = np.append(children[p], j)\n        \n  L_indptr = np.zeros(n+1, dtype=int)\n  L_indptr[1:] = np.cumsum([len(x) for x in L_sym])\n  L_indices = np.concatenate(L_sym)\n  \n  return L_indices, L_indptr\n\n\n\ndef _structured_copy(A_indices, A_indptr, A_x, L_indices, L_indptr):\n  n = len(A_indptr) - 1\n  L_x = np.zeros(len(L_indices))\n  \n  for j in range(0, n):\n    copy_idx = np.nonzero(np.in1d(L_indices[L_indptr[j]:L_indptr[j + 1]],\n                                  A_indices[A_indptr[j]:A_indptr[j+1]]))[0]\n    L_x[L_indptr[j] + copy_idx] = A_x[A_indptr[j]:A_indptr[j+1]]\n  return L_x\n\ndef _sparse_cholesky_impl(L_indices, L_indptr, L_x):\n  n = len(L_indptr) - 1\n  descendant = [[] for j in range(0, n)]\n  for j in range(0, n):\n    tmp = L_x[L_indptr[j]:L_indptr[j + 1]]\n    for bebe in descendant[j]:\n      k = bebe[0]\n      Ljk= L_x[bebe[1]]\n      pad = np.nonzero(                                                       \\\n          L_indices[L_indptr[k]:L_indptr[k+1]] == L_indices[L_indptr[j]])[0][0]\n      update_idx = np.nonzero(np.in1d(                                        \\\n                    L_indices[L_indptr[j]:L_indptr[j+1]],                     \\\n                    L_indices[(L_indptr[k] + pad):L_indptr[k+1]]))[0]\n      tmp[update_idx] = tmp[update_idx] -                                     \\\n                        Ljk * L_x[(L_indptr[k] + pad):L_indptr[k + 1]]\n            \n    diag = np.sqrt(tmp[0])\n    L_x[L_indptr[j]] = diag\n    L_x[(L_indptr[j] + 1):L_indptr[j + 1]] = tmp[1:] / diag\n    for idx in range(L_indptr[j] + 1, L_indptr[j + 1]):\n      descendant[L_indices[idx]].append((j, idx))\n  return L_x\n\n\nOnce again, we can check to see if this worked!\n\nL_indices, L_indptr, L_x = sparse_cholesky(A_indices, A_indptr, A_x)\nL = sparse.csc_array((L_x, L_indices, L_indptr))\nprint(f\"The error in the sparse cholesky is {np.sum(np.abs((A - L @ L.T).todense())): .2e}\")\n\nThe error in the sparse cholesky is  1.02e-13\n\n\nAnd, of course, we can do abstract evaluation. Here is where we actually need to use L_nse to work out the dimension of our output.\n\n@sparse_cholesky_p.def_abstract_eval\ndef sparse_cholesky_abstract_eval(A_indices, A_indptr, A_x, *, L_nse):\n  return core.ShapedArray((L_nse,), A_indices.dtype),                   \\\n         core.ShapedArray(A_indptr.shape, A_indptr.dtype),             \\\n         core.ShapedArray((L_nse,), A_x.dtype)"
  },
  {
    "objectID": "posts/2022-05-18-sparse4-some-primatives/sparse4-some-primatives.html#primitive-four-loga",
    "href": "posts/2022-05-18-sparse4-some-primatives/sparse4-some-primatives.html#primitive-four-loga",
    "title": "Sparse Matrices 5: I bind you Nancy",
    "section": "Primitive four: \\(\\log(|A|)\\)",
    "text": "Primitive four: \\(\\log(|A|)\\)\nAnd now we have our final primitive: the log determinant! Wow. So much binding. For this one, we compute the Cholesky factorisation and note that \\[\\begin{align*}\n|A| = |LL^T| = |L||L^T| = |L|^2.\n\\end{align*}\\] If we successfully remember that the determinant of a triangular matrix is the product of its diagonal entries, we have a formula we can implement.\nSame deal as last time.\n\nsparse_log_det_p = core.Primitive(\"sparse_log_det\")\n\ndef sparse_log_det(A_indices, A_indptr, A_x):\n  \"\"\"A JAX traceable sparse log-determinant\"\"\"\n  return sparse_log_det_p.bind(A_indices, A_indptr, A_x)\n\n@sparse_log_det_p.def_impl\ndef sparse_log_det_impl(A_indices, A_indptr, A_x):\n  \"\"\"The implementation of the sparse log-determinant. This is not JAX traceable.\n  \"\"\"\n  L_indices, L_indptr, L_x = sparse_cholesky_impl(A_indices, A_indptr, A_x)\n  return 2.0 * sum(np.log(L_x[L_indptr[:-1]]))\n\nA canny reader may notice that I’m assuming that the first element in each column is the diagonal. This will be true as long as the diagonal elements of \\(L\\) are non-zero, which is true as long as \\(A\\) is symmetric positive definite.\nLet’s test9 it out.\n\nld = sparse_log_det(A_indices, A_indptr, A_x)\nLU = sparse.linalg.splu(A)\nld_true = sum(np.log(LU.U.diagonal()))\nprint(f\"The error in the log-determinant is {ld - ld_true: .2e}\")\n\nThe error in the log-determinant is  0.00e+00\n\n\nFinally, we can do the abstract evaluation.\n\n@sparse_log_det_p.def_abstract_eval\ndef sparse_log_det_abstract_eval(A_indices, A_indptr, A_x):\n  return core.ShapedArray((1,), A_x.dtype)"
  },
  {
    "objectID": "posts/2022-05-18-sparse4-some-primatives/sparse4-some-primatives.html#where-are-we-now-but-nowhere",
    "href": "posts/2022-05-18-sparse4-some-primatives/sparse4-some-primatives.html#where-are-we-now-but-nowhere",
    "title": "Sparse Matrices 5: I bind you Nancy",
    "section": "Where are we now but nowhere?",
    "text": "Where are we now but nowhere?\nSo we are done for today. Our next step will be to implement all of the bits that are needed to make the derivatives work. So in the next instalment we will differentiate log-determinants, Cholesky decompositions, and all kinds of other fun things.\nIt should be a blast."
  },
  {
    "objectID": "posts/2021-10-11-n-sane-in-the-membrane/n-sane-in-the-membrane.html",
    "href": "posts/2021-10-11-n-sane-in-the-membrane/n-sane-in-the-membrane.html",
    "title": "\\((n-1)\\)-sane in the membrane",
    "section": "",
    "text": "And when you’re in a period of heavy teaching, every-fucking-thing is about teaching.\nSo this blogpost is about teaching.\nRight now, I’m coming to the end of a second year class called Statistical Thinking. It’s been fun to work out how to teach the material. It’s standard fare: sampling variation, tests, bootstraps1, regression, and just a hint of Bayes in the last 2 weeks that you incentivize by promising a bastard of an exam question. So you know, (arms up even though I’m Catholic) tradition!\n\nIf I were a rich man (Katrina Lenk with a violin)\nThe thing about teaching an intro stats class is that it brings screaming to mind that quote from Bennett’s The History Boys2: (paraphrasing) “How do I define [intro to Statistics]? It’s just one fucking thing after another”.\nConstructing twelve moderately sequential weeks from the whole mass of things that someone being introduced to statistics needs to know is not unlike being thrown in the middle of the lake with nothing but an ice-cream container and a desiccated whale penis: confusing, difficult, and rather damp.\nThe nice thing about building an intro stats course is you’re not alone. You’re adrift in a sea of shit ideas! (Also a lot of good ones3, but don’t ruin my flow!)\nThe trouble is that this sort of course is simultaneously teaching big concepts and complex details. And while it’s not toooooo hard to make the concepts build and reinforce as time inexorably marches on, the techniques and details needed to illuminate the big concepts are not quite as linear.\nThere are two routes through this conundrum: incantations inscribed onto books made of human skin using the blood of sacrificial virgins (aka gathered during engineering statistics service teaching) or computers.\nI went with computers because we are in lockdown and I couldn’t be bothered sourcing and bleeding virgins.\nThe downside is that you need the students to have a grip on R programming (and programmatic thinking). This only happens if the degree you are teaching in is built in such a way that these skills have already been taught. Otherwise you need to teach both (which is very possible, but you need to teach less statistical content).\nThis is not a postmortem on my teaching, but if it were, it would be about that last point.\n\n\nI saw Goody Proctor with the devil!\n\n\n\nA tweet from Sanjay Srivastava\n\n\nThis is a very long way to say I saw a tweet an had feelings.\nBecause I’m thinking about this stuff pretty hard right now, I am (as Hedwig would say) fully dilated.\nAnd my question is what is the use of teaching this distinction? Should anyone bother dividing by \\((n-1)\\) instead of \\(n\\) in their variance estimates?\nWell I guess the first question is is there a difference in this distinction? Let’s do the sort of R experiment I want my students to do!\n\n# Independent samples for a qq-plot!\n# Thanks to Rob Trangucci for catching this!\nlibrary(tidyverse)\nn_sim <- 100000\nn <- 10\nexperiments <- tibble(exp = rep(1:n_sim, each = n),\n                      sample = rnorm(n * n_sim),\n                      sample2 = rnorm(n * n_sim))\n\ncompare <- experiments %>%\n  group_by(exp) %>%\n  summarise(m = mean(sample),\n            m2 = mean(sample2),\n            var_bias = mean((sample - m)^2),\n            z_bias = m / sqrt(mean(var_bias)),\n            z = m2 / sd(sample2))\n\n\ncompare %>% \n  ggplot(aes(sort(z), sort(z_bias))) +\n  geom_point() +\n  geom_abline(slope = 1, intercept = 0) +\n  theme_bw() + \n  coord_fixed(xlim = c(-2,2), y = c(-2,2))\n\n\n\n\nWell that is clear. There is not.\nOr, well, there is a small difference.\nBut to see it, you need a lot of samples! Why? Well the easy answer is maths.\nFor one thing, when \\(n=10\\), \\[\n\\frac{1}{n} - \\frac{1}{n-1} = \\frac{1}{90} = 0.01.\n\\] This does not compare well against the sampling variance, which (assuming \\(\\sigma^2\\approx 1\\), which is usual if you’ve scaled your problem correctly) is about \\(0.3\\).\nBut we could choose to do it properly. The bias in the MLE (aka the divide by \\(n\\)) variance estimate is \\[\n-\\frac{\\sigma^2}{n}.\n\\] This is a lot smaller than the sampling variability of the estimate (aka how much uncertainty you have because of the finite sample), which is \\[\n\\frac{\\sigma}{\\sqrt{n}}.\n\\]\nAnd that’s the whole story. Dividing by \\(n\\) instead of \\((n-1)\\) leaves you with a slightly biased estimate. But the bias if fucking tiny. It is possibly moving your second decimal place by about 1 number (assume our population variance is one). The sampling variably is moving the first decimal place by several digits.\nTruly. What is the point. The old guys4 who went wild about bias are now mostly dead. Or they’ve changed their minds (which is, you know, a reasonable thing to do as information about best practice is updated). The war against bias was lost before your undergraduates were born.\n\n\nEven in crisis, I maintain\nBut nevertheless, this whole DIVIDE BY N-1 OR THE BIAS MONSTER IS GONNA GET YA bullshit continues.\nAnd to some extent, maybe I shouldn’t care. I definitely shouldn’t care this many words about it.\nBut I do. And I do for a couple of reasons.\nReason One: What is the point teaching students about uncertainty and that you can’t just say “this number is different” because the estimate on a single sample is different. If I am to say that I need things to be at least5 \\(\\mathcal{O}(n^{-1/2})\\) apart before I’m willing to say they are maybe different, then why am I harping on about the much smaller difference?\nReason Two: It’s a shitty example. Bias and bias corrections have a role to play in statistics6. But if this is your first introduction to bias correction, you are going to teach either:\n\nBias is always bad, regardless of context / sampling variance / etc\nBias can be corrected, but it’s trivial and small.\n\nBoth of those things are bullshit. Just teach them how to bootstrap and teach the damn thing properly. You do not have to go very far to show bias actually making a difference!\nMaybe the only place the difference will be noticed is if you compare against the in-build var or sd functions. This is not the use case I would build my class around, but it is a thing you would need to be aware of.\n\n\nThe worlds is a question, this room is an answer. And the answer is no.\nIf you are going to teach statistics as more than just stale incantations and over-done fear-mongering, you need to construct the types of stakes that are simply not present in the \\(n\\) vs \\(n-1\\) bullshit.\nIt is present when you are teaching the normal vs t distribution. You are teaching that the design of your experiment changes the possible extreme behaviour and sometimes it can change a lot.\nThe \\(n\\) vs \\((n-1)\\) denominator for a variance estimator is a curiosity. It is the source of thrilling7 exercises or exam questions. But it is not interesting.\nIt could maybe set up the idea that MLEs are not unbiased. But even then, the useless correction term is not needed. Just let it be slightly biased and move on with your life.\nBecause if that is the biggest bias in your analysis, you are truly blessed.\nIn real life, bias is the price you pay for being good at statistics. And like any market, if you pay too much you’re maybe not that good. But if you pay nothing at all, you don’t get to play.\n\n\n\n\n\nFootnotes\n\n\nTo paraphrase Jimmy Somerville, tell me whyyyyyyyyy about 90% of the bootstrap material on the web is … misguided. And why tidymodels only has the shit bootstrap in it?↩︎\nOk. Straight up, “[Intro to statistics] is a commentary on the various and continuing incapabilities of men” would’ve also worked.↩︎\nThis course stands on the shoulders of giants: Di Cook and Catherine Forbes gave me a great base. And of course every single textbook (shout out to the OpenIntro crew!), blog post, weird subsection of some other book, paper from 1987 on some weird bootstrap, etc that I have used to make a course!↩︎\nYes. I used the word on purpose.↩︎\n\\(n\\) is the size of the sample.↩︎\nI spend most of my time doing Bayes shit, and we play this game somewhat differently. But the gist is the same.↩︎\nNot thrilling.↩︎\n\nReusehttps://creativecommons.org/licenses/by-nc/4.0/CitationBibTeX citation:@online{simpson2021,\n  author = {Dan Simpson},\n  editor = {},\n  title = {\\$(N-1)\\$-Sane in the Membrane},\n  date = {2021-10-14},\n  url = {https://dansblog.netlify.app/n-sane-in-the-membrane},\n  langid = {en}\n}\nFor attribution, please cite this work as:\nDan Simpson. 2021. “$(N-1)$-Sane in the Membrane.” October\n14, 2021. https://dansblog.netlify.app/n-sane-in-the-membrane."
  },
  {
    "objectID": "posts/2022-09-04-everybodys-got-something-to-hide-except-me-and-my-monkey/everybodys-got-something-to-hide-except-me-and-my-monkey.html",
    "href": "posts/2022-09-04-everybodys-got-something-to-hide-except-me-and-my-monkey/everybodys-got-something-to-hide-except-me-and-my-monkey.html",
    "title": "A first look at multilevel regression; or Everybody’s got something to hide except me and my macaques",
    "section": "",
    "text": "Eliza knows a little something about monkeys. This will become relevant in a moment.\nIn about 2016, Almeling et al. published a paper that suggested aged Barbary macaques maintained interest in members of their own species while losing interest in novel non-social stimuli (eg toys or puzzles with food inside).\nThis is where Eliza—who knows a little something about monkeys—comes into frame: this did not gel with her experiences at all.\nSo Eliza (and Mark1 2, who also knows a little something about monkeys) decided to look into it."
  },
  {
    "objectID": "posts/2022-09-04-everybodys-got-something-to-hide-except-me-and-my-monkey/everybodys-got-something-to-hide-except-me-and-my-monkey.html#what-are-the-stakes-according-to-the-papers-not-according-to-me-who-knows-exactly-nothing-about-this-type-of-work",
    "href": "posts/2022-09-04-everybodys-got-something-to-hide-except-me-and-my-monkey/everybodys-got-something-to-hide-except-me-and-my-monkey.html#what-are-the-stakes-according-to-the-papers-not-according-to-me-who-knows-exactly-nothing-about-this-type-of-work",
    "title": "A first look at multilevel regression; or Everybody’s got something to hide except me and my macaques",
    "section": "What are the stake?s (According to the papers, not according to me, who knows exactly nothing3 about this type of work)",
    "text": "What are the stake?s (According to the papers, not according to me, who knows exactly nothing3 about this type of work)\nA big motivation for studying macaques and other non-human primates is that they’re good models of humans. This means that if there was solid evidence of macaques becoming less interested in novel stimuli as they age (while maintaining interest in people), this could suggest an evolutionary reason from this (commonly observed) behaviour in humans.\nSo if this result is true, it could help us understand the psychology of humans as they age (and in particular, the learned vs evolved trade off they are making)."
  },
  {
    "objectID": "posts/2022-09-04-everybodys-got-something-to-hide-except-me-and-my-monkey/everybodys-got-something-to-hide-except-me-and-my-monkey.html#so-what-did-eliza-and-mark-do",
    "href": "posts/2022-09-04-everybodys-got-something-to-hide-except-me-and-my-monkey/everybodys-got-something-to-hide-except-me-and-my-monkey.html#so-what-did-eliza-and-mark-do",
    "title": "A first look at multilevel regression; or Everybody’s got something to hide except me and my macaques",
    "section": "So what did Eliza and Mark do?",
    "text": "So what did Eliza and Mark do?\nThere are a few things you can do when confronted with a result that contradicts your experience: you can complain about it on the Internet, you can mobilize a direct replication effort, or you can conduct your own experiments. Eliza and Mark opted for the third option, designing a conceptual replication.\nDirect replications tell you more about the specific experiment that was conducted, but not necessarily more about the phenomenon under investigation. In a study involving aged monkeys4, it’s difficult to imagine how a direct replication could take place.\nOn the other hand, a conceptual replication has a lot more flexibility. It allows you to probe the question in a more targeted manner, appropriate for incremental science. In this case, Eliza and Mark opted to study only the claim that the monkeys lose interest in novel stimuli as they age (paper here). They did not look into the social claim. They also used a slightly different species of macaque (M. mulatta rather than M. butterfly). This is reasonable insofar as understanding macaques as a model for human behaviour."
  },
  {
    "objectID": "posts/2022-09-04-everybodys-got-something-to-hide-except-me-and-my-monkey/everybodys-got-something-to-hide-except-me-and-my-monkey.html#what-does-the-data-look-like",
    "href": "posts/2022-09-04-everybodys-got-something-to-hide-except-me-and-my-monkey/everybodys-got-something-to-hide-except-me-and-my-monkey.html#what-does-the-data-look-like",
    "title": "A first look at multilevel regression; or Everybody’s got something to hide except me and my macaques",
    "section": "What does the data look like?",
    "text": "What does the data look like?\nThe experiment used 2435 monkeys aged between 4 and 30 and gave them a novel puzzle task (opening a fancy tube with food in it) for twenty minutes over two days. The puzzle was fitted with an activity tracker. Each monkey had two tries at the puzzle over two days. Monkeys had access to the puzzle for around6 20 minutes.\nIn order to match the original study’s analysis, Eliza and Mark divided the first two minutes into 15 second intervals and counted the number of intervals where the monkey interacted with the puzzle. They also measured the same thing over 20 minutes in order to see if there was a difference between short-term curiosity and more sustained exploration.\nFor each monkey, we have the following information:\n\nMonkey ID\nAge (4-30)\nDay (one or two)\nNumber of active intervals in the first two minutes (0-8)\nNumber of active intervals in the first twenty minutes (0-80)\n\nThe data and their analysis are freely7 available here.\n\nlibrary(tidyverse)\nacti_data <- read_csv(\"activity_data.csv\") \nactivity_2mins <- acti_data |>\n  filter(obs<9) |> group_by(subj_id, Day) |>\n  summarize(total=sum(Activity), \n            active_bins = sum(Activity > 0), \n            age = min(age)) |>\n  rename(monkey = subj_id, day = Day) |>\n  ungroup()\n\nactivity_20minms80 <- acti_data |> filter(obs<81) |>\n  group_by(subj_id, Day) |>\n  summarize(total=sum(Activity), \n            active_bins = sum(Activity > 0), \n            age = min(age)) |>\n  rename(monkey = subj_id, day = Day) |>\n  ungroup()"
  },
  {
    "objectID": "posts/2022-09-04-everybodys-got-something-to-hide-except-me-and-my-monkey/everybodys-got-something-to-hide-except-me-and-my-monkey.html#ok-mary-how-are-we-going-to-analyze-this-data",
    "href": "posts/2022-09-04-everybodys-got-something-to-hide-except-me-and-my-monkey/everybodys-got-something-to-hide-except-me-and-my-monkey.html#ok-mary-how-are-we-going-to-analyze-this-data",
    "title": "A first look at multilevel regression; or Everybody’s got something to hide except me and my macaques",
    "section": "Ok Mary, how are we going to analyze this data?",
    "text": "Ok Mary, how are we going to analyze this data?\nEliza and Mark’s monkey data is an example of a fairly common type of experimental data, where the same subject is measured multiple times. It is useful to break the covariates down into three types: grouping variables, group-level covariates, and individual-level covariates.\nGrouping variables indicate what group each observation is in. We will see a lot of different ways of defining groups as we go on, but a core idea is that observations within a group should conceptually more similar to each other than observations in different groups. For Eliza and Mark, their grouping variable is monkey. This encodes the idea that different monkeys might have very different levels of curiosity, but the same monkey across two different days would probably have fairly similar levels of curiosity.\nGroup-level covariates are covariates that describe a feature of the group rather than the observation. In this example, age is a group-level covariate, because the monkeys are the same age at each observation.\nIndividual-level covariates are covariates that describe a feature that is specific to an observation. (The nomenclature here can be a bit confusing: the “individual” refers to individual observations, not to individual monkeys. All good naming conventions go to shit eventually.) The individual-level covariate is experiment day. This can be a bit harder to see than the other designations, but it’s a little clearer if you think of it as an indicator of whether this is the first time the monkey has seen the task or the second time. Viewed this way, it is very clearly a measurement of an property of an observation rather than of a group.\nEliza and Mark’s monkey data is an example of a fairly general type of experimental data where subjects (our groups) are given the same task under different experimental conditions (described through individual-level covariates). As we will see, it’s not uncommon to have much more complex group definitions (that involve several grouping covariates) and larger sets of both group-level and individual-level covariates.\nSo how do we fit a model to this data.\n\nThere are just too many monkeys; or Why can’t we just analyse this with regression?\nThe temptation with this sort of data is to fit a linear regression to it as a first model. In this case, we are using grouping, group-level, and individual-level covariates in the same way. Let’s suck it and see.\n\nlibrary(broom)\nfit_lm <- lm(active_bins ~ age*factor(day) + factor(monkey), data = activity_2mins)\n\ntidy(fit_lm) \n\n\n\n  \n\n\n\nSo the first thing you will notice is that that is a lot of regression coefficients! There are 243 monkeys and 2 days, but only 485 observations. This isn’t enough data to reliably estimate all of these parameters. (Look at the standard errors for the monkey-related coefficients. They are huge!)\nSo what are we to do?\nThe problem is the monkeys. If we use monkey as a factor variable, we only have (at most) two observations of each factor level. This is simply not enough observations per to estimate a different intercept for each monkey!\nThis type of model is often described as having no pooling, which indicates that there is no explicit dependence between the intercepts for each group (monkey). (There is some dependence between groups due to the group-level covariate age.)\n\n\nIf we ignore the monkeys, will they go away? or Another attempt at regression\nOur first attempt at a regression model didn’t work particularly well, but that doesn’t mean we should give up8. A second option is that we can assume that there is, fundamentally, no difference between monkeys. If all monkeys of the same age have similar amounts of interest in new puzzles, this would be a reasonable assumption. The best case scenario is that not accounting for differences between individual monkeys would still lead to approximately normal residuals, albeit with probably a larger residual variance.\nThis type of modelling assumption is called complete pooling as it pools the information between groups by treating them all as the same.\nLet’s see what happens in this case!\n\nfit_lm_pool <- lm(active_bins ~ age*factor(day), data = activity_2mins)\nsummary(fit_lm_pool)\n\n\nCall:\nlm(formula = active_bins ~ age * factor(day), data = activity_2mins)\n\nResiduals:\n    Min      1Q  Median      3Q     Max \n-4.5249 -1.5532  0.1415  1.6731  4.1884 \n\nCoefficients:\n                 Estimate Std. Error t value Pr(>|t|)    \n(Intercept)      3.789718   0.344466  11.002   <2e-16 ***\nage              0.003126   0.021696   0.144    0.885    \nfactor(day)2     0.056112   0.488818   0.115    0.909    \nage:factor(day)2 0.025170   0.030759   0.818    0.414    \n---\nSignif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1\n\nResidual standard error: 2.103 on 481 degrees of freedom\nMultiple R-squared:  0.01365,   Adjusted R-squared:  0.0075 \nF-statistic: 2.219 on 3 and 481 DF,  p-value: 0.0851\n\n\nOn the up side, the regression runs and doesn’t have too many parameters!\nThe brave and the bold might even try to interpret the coefficients and say something like there doesn’t seem to be a strong effect of age. But there’s real danger in trying to interpret regression coefficients in the presence of a potential confounder (in this case, the monkey ID). And it’s particularly bad form to do this without ever looking at any sort of regression diagnostics. Linear regression is not a magic eight ball.\nLet’s look at the diagnostic plots.\n\nlibrary(broom)\naugment(fit_lm_pool) |> \n  ggplot(aes(x = .fitted, y = active_bins - .fitted)) +\n  geom_point() +\n  geom_smooth(method = \"lm\", se = FALSE) +\n  theme_classic()\n\n\n\naugment(fit_lm_pool) |> ggplot(aes(sample = .std.resid)) + \n  stat_qq() +\n  geom_abline(slope = 1, intercept = 0, linetype = \"dashed\") + \n  theme_classic()\n\n\n\n\nThere are certainly some patterns in those residuals (and some suggestion that the error need a heavier tail for this model to make sense)."
  },
  {
    "objectID": "posts/2022-09-04-everybodys-got-something-to-hide-except-me-and-my-monkey/everybodys-got-something-to-hide-except-me-and-my-monkey.html#what-is-between-no-pooling-and-complete-pooling-multilevel-models-thats-what",
    "href": "posts/2022-09-04-everybodys-got-something-to-hide-except-me-and-my-monkey/everybodys-got-something-to-hide-except-me-and-my-monkey.html#what-is-between-no-pooling-and-complete-pooling-multilevel-models-thats-what",
    "title": "A first look at multilevel regression; or Everybody’s got something to hide except me and my macaques",
    "section": "What is between no pooling and complete pooling? Multilevel models, that’s what",
    "text": "What is between no pooling and complete pooling? Multilevel models, that’s what\nWe are in a Goldilocks situation: no pooling results in a model that has too many independent parameters for the amount of data that we’ve got, while complete pooling has too few parameters to correctly account for the differences between the monkeys. So what is our perfectly tempered porridge9?\nThe answer is to assume that each monkey has its own intercept, but that it’s intercept can only be so far from the overall intercept (that we would’ve gotten from complete pooling). There are a bunch of ways to realize this concept, but the classical method is to use a normal distribution.\nIn particular, if the \\(j\\)th monkey has observations \\(y_{ij}\\), \\(i=1,2\\), then we can write our model as \\[\ny_{ij}  \\sim N(\\mu_j + \\beta_\\text{age}\\, \\text{age}_j + \\beta_\\text{day}\\, \\text{day}_{ij} + \\beta_\\text{age,day}\\, \\text{[age*day]}_{ij}, \\sigma^2).\n\\]\nThe effects of age and day and the data standard deviation (\\(\\sigma\\)) are just like they’d be in an ordinary linear regression model. Our modification comes in how we treat the \\(\\mu_j\\).\nIn a classical linear regression model, we would fit the \\(\\mu_j\\)s independently, perhaps with some weakly informative prior distribution. But we’ve already discussed that that won’t work.\nInstead we will make the \\(\\mu_j\\) exchangeable rather than independent. Exchangeability is a relaxation of the independence assumption to say instead encode that we have no idea which of the intercepts will do what. That is, if we switch around the labels of our intercepts the prior should not change. There is a long and storied history of exchangeable models in statistics, but the short version that is more than sufficient for our purposes is that they usually10 take the form \\[\\begin{align*}\n\\mu_j \\mid \\tau \\stackrel{\\text{iid}}{\\sim} &p(\\mu_j \\mid \\tau), \\qquad i = 1,\\ldots, J \\\\\n\\tau \\sim & p(\\tau).\n\\end{align*}\\]\nIn a regression context, we typically assume that \\[\n\\mu_j \\mid \\tau \\sim N(\\mu, \\tau^2)\n\\] for some \\(\\mu\\) and \\(\\tau\\) that will need their own priors.\nWe can explore this difference mathematically. The regression model, which assumes independence of the \\(\\mu_j\\), uses \\[\np(\\mu_1, \\ldots, \\mu_J) = \\prod_{j=1}^J N(\\mu, \\tau_\\text{fixed}^2)\n\\] as the joint prior on \\(\\mu_1,\\ldots,\\mu_J\\). On the other hand, the exchangeable model, which forms the basis of multilevel models, assumes the joint prior \\[\np(\\mu_1, \\ldots, \\mu_J) = \\int_0^\\infty \\left(\\prod_{j=1}^J N(\\mu, \\tau^2)\\right)p(\\tau)\\,d\\tau,\n\\] for some prior on \\(p(\\tau)\\) on \\(\\tau\\).\nThis might not seem like much of a change, but it can be quite profound. In both cases, the prior is saying that each \\(\\mu_j\\) is, with high probability, at most \\(3\\tau\\) away from the overall mean \\(\\mu\\). The difference is that while the classical least squares formulation uses a fixed value of \\(\\tau\\) that needs to be specified by the modeller, while the exchangeable model lets \\(\\tau\\) adapt to the data.\nThis data adaptation is really nifty! It means that if the groups have similar means, they can borrow information from the other groups (via the narrowing of \\(\\tau\\)) in order to improve their precision over an unpooled estimate. On the other hand, if there is a meaningful difference between the groups11, this model can still represent that, unlike the unpooled model.\nIn our context, however, we need a tiny bit more. We have a group-level covariate (specifically age) that we think is going to effect the group mean. So the model we want is \\[\\begin{align*}\ny_{ij}  \\mid \\mu_j,\\beta, \\sigma &\\sim N(\\mu_j + \\beta_\\text{day}\\, \\text{day}_{ij} + \\beta_\\text{age,day}\\, \\text{[age*day]}_{ij} , \\sigma^2) \\\\\n\\mu_j\\mid \\tau, \\mu,\\beta &\\sim N(\\mu +  \\beta_\\text{age}\\, \\text{age}_j, \\tau^2) \\\\\n\\mu &\\sim p(\\mu)\\\\\n\\beta &\\sim p(\\beta)\\\\\n\\tau & \\sim p(\\tau) \\\\\n\\sigma &\\sim p(\\sigma).\n\\end{align*}\\]\nIn order to fully specify the model we need to set the four prior distributions.\nThis is an example of a multilevel12 model. The name comes from the data having multiple levels (in this case two: the observation level and the group level). Both levels have an appropriate model for their mean.\nThis mathematical representation does a good job in separating out the two different levels. However, there are a lot of other ways of writing multilevel models. An important example is the extended formula notation created13 by R’s lme4 package. In their notation, we would write this model as\n\nformula <- active_bins_scaled ~ age_centred*day + (1 | monkey)\n\nThe first bit of this formula is the same as the formula used in linear regression. The interesting bit is is the (1 | monkey). This is the way to tell R that the intercept (aka 1 in formula notation) is going to be grouped by monkey and we are going to put an exchangeable normal prior on it. For more complex models there are more complex variations on this theme, but for the moment we won’t go any further."
  },
  {
    "objectID": "posts/2022-09-04-everybodys-got-something-to-hide-except-me-and-my-monkey/everybodys-got-something-to-hide-except-me-and-my-monkey.html#reasoning-out-some-prior-distributions",
    "href": "posts/2022-09-04-everybodys-got-something-to-hide-except-me-and-my-monkey/everybodys-got-something-to-hide-except-me-and-my-monkey.html#reasoning-out-some-prior-distributions",
    "title": "A first look at multilevel regression; or Everybody’s got something to hide except me and my macaques",
    "section": "Reasoning out some prior distributions",
    "text": "Reasoning out some prior distributions\nWe need to set priors. The canny amongst you may have noticed that I did not set priors in the previous two examples. There are two reasons for this: firstly I didn’t feel like it, and secondly none but the most terrible prior distributions would have meaningfully changed the conclusions. This is, it turns out, one of the great truths when it comes to prior distributions: they do not matter until they do14.\nIn particular, if you have a parameter that directly sees the data (eg it’s in the likelihood) and there is nothing weird going on15, then the prior distribution will usually not do much as any prior will be quickly overwhelmed by the data.\nThe problem is that we have one parameter in our model (\\(\\tau\\)) that does not directly see the data. Instead of directly telling us about an observation, it tells us about how different the groups of observations are. There is usually less information in the data about this type of parameter and, consequently, the prior distribution will be more important. This is especially true when you have more than one grouping variable, or when a variable only has a small number of groups.\nSo let’s pay some proper attention to the priors.\nTo begin with, let’s set priors on \\(\\mu\\), \\(\\beta\\), and \\(\\sigma\\) (aka the data-level parameters). This is a considerably easier task if the data is scaled. Otherwise, you need to encode information about the usual scale16 of the data into your priors. Sometimes this is a sensible and easy thing to do, but usually it’s easier to simply scale the data. (A lot of software will simply scale your data for you, but it is always better to do it yourself!)\nSo let’s scale our data. We have three variables that need scaling: age (aka the covariate that isn’t categorical) and active_bins (aka the response). For age, we are going to want to measure it as either years from the youngest monkey or years from the average monkey. I think, in this situation, the first version could make a lot of sense, but we are going with the second. This allows us to interpret \\(\\mu\\) as the over-all mean. Otherwise, \\(\\mu\\) would tell us about the overall average activity of 4 year old monkeys and we will use \\(\\beta(\\text{age}_j - 4)\\) to estimate how much the activity changes, on average keeping all other aspects constant, as the monkey ages.\nOn the other hand, we have no sensible baseline for activity, so deviation from the average seems like a sensible scaling. I also don’t know, a priori, how variable activity is going to be, so I might want to scale17 it by its standard deviation. In this case, I’m not going to do that because we have a sensible fixed18 upper limit (8), which I can scale by.\nOne important thing here is that if we scale the data by data-dependent quantities (like the minimum, the mean, or the standard deviation) we must keep track of this information. This is because any future data we try to predict with this model will need to be transformed the same way using the same19 numbers! This particularly has implication when you are doing things like test/training set validation or cross validation: in the first case, the test set needs to be scaled in the same way the training set was; while in the second case each cross validation training set needs to be scaled independently and that scaling needs to be used on the corresponding left-out data20.\n\nage_centre <- mean(activity_2mins$age)\nage_scale <- diff(range(activity_2mins$age))/2\nactive_bins_centre <- 4\n\nactivity_2mins_scaled <- activity_2mins |>\n  mutate(monkey = factor(monkey),\n         day = factor(day),\n         age_centred = (age - age_centre)/age_scale,\n         active_bins_scaled = (active_bins - active_bins_centre)/4)\n\nWith our scaling completed, we can now start thinking about prior distributions. The trick with priors is to make them wide enough to cover all plausible values of a parameter without making them so wide that they put a whole bunch of weight on essentially silly values.\nWe know, for instance, that our unscaled activity will go between 0 and 8. That means that it’s unlikely for the mean of the scaled process to be much bigger than 3 or 4. These considerations, along with the fact that we have centred the data so the mean should be closer to zero, suggest that a \\(N(0,1)\\) prior should be appropriate for \\(\\mu\\).\nAs we normalised our age data relative to the smallest age, we should think more carefully about the scaling of \\(\\beta\\). Macaques live for 20-3021 years, so we need to think about, for instance, an ordinary aged macaque that would be 15 years older than the baseline. Thanks to our scaling, the largest change that we can have is around 1, which strongly suggests that if \\(\\beta\\) was too much larger than \\(1/8\\) we are going to be in unreasonable territory. So let’s put a \\(N(0,0.2^2)\\) prior22 on \\(\\beta_\\text{age}\\) and \\(\\beta_\\text{age,day}\\). For \\(\\beta_\\text{day}\\) we can use a \\(N(0,1)\\) prior.\nSimilarly, the scaling of activity_bins suggests that a \\(N(0,1)\\) prior would be sufficient for the data-level standard deviation \\(\\sigma\\).\nThat just leaves us with our choice of prior for the standard deviation of the intercept23 \\(\\mu_j\\), \\(\\tau\\). Thankfully, we considered this case in detail in the previous blog post. There I argued that a sensible prior for \\(\\tau\\) would be an exponential prior. To be quite honest with you, a half-normal or a half-t also would be fine. But I’m going to stick to my guns. For the scaling, again, it would be a touch surprising (given the scaling of the data) if the group means were more than 3 apart, so choosing \\(\\lambda=1\\) in the exponential distribution should give a relatively weak prior without being so wide that we are putting prior mass on a bunch of values that we would never actually want to put prior mass on.\nWe can then fit the model with brms. In this case, I’m using the cmdstanr back end, because it’s fast and I like it.\nTo specify the model, we use the lme4-style formula notation discussed above.\nTo set the priors, we will use brms. Now, if you are Paul you might be able to remember how to set priors in brms without having to look it up, but I am sadly not Paul24, so every time I need to set priors in brms I write the formula and use the convenient get_prior function\n\nlibrary(cmdstanr)\nlibrary(brms)\nget_prior(formula, activity_2mins_scaled)\n\n\n\n  \n\n\n\nFrom this, we can see that the default prior on \\(\\beta\\) is an improper flat prior, the default prior on the intercept is a Student-t with 3 degrees of freedom centred at zero with standard deviation 2.5. The same prior (restricted to positive numbers) is put on all of the standard deviation parameters. These default prior distributions are, to be honest, probably fine in this context25, but it is good practice to always set your prior.\nWe do this as follows. (Note that brms uses Stan, which parameterises the normal distribution by its mean and standard deviation!)\n\npriors <- prior(normal(0, 0.2), coef = \"age_centred\") + \n  prior(normal(0,0.2), coef = \"age_centred:day2\") +\n  prior(normal(0, 1), coef = \"day2\") +\n  prior(normal(0,1), class = \"sigma\") +\n  prior(exponential(1), class = sd) + # tau\n  prior(normal(0,1), class = \"Intercept\")"
  },
  {
    "objectID": "posts/2022-09-04-everybodys-got-something-to-hide-except-me-and-my-monkey/everybodys-got-something-to-hide-except-me-and-my-monkey.html#pre-experiment-prophylaxis",
    "href": "posts/2022-09-04-everybodys-got-something-to-hide-except-me-and-my-monkey/everybodys-got-something-to-hide-except-me-and-my-monkey.html#pre-experiment-prophylaxis",
    "title": "A first look at multilevel regression; or Everybody’s got something to hide except me and my macaques",
    "section": "Pre-experiment prophylaxis",
    "text": "Pre-experiment prophylaxis\nSo we have specified some priors using the power of our thoughts. But we should probably check to see if they are broadly sensible. A great thing about Bayesian modelling is that we are explicitly specifying our a priori (or pre-data) assumptions about the data generating process. That means that we can do a fast validation of our priors by simulating from them and checking that they’re not too wild.\nThere are lots of ways to do this, but the easiest26 way to do this is to use the sample_prior = \"only\" option in the brm() function.\n\nprior_draws <- brm(formula, \n           data = activity_2mins_scaled,\n           prior = priors,\n           sample_prior = \"only\",\n           backend = \"cmdstanr\",\n           cores = 4,\n           refresh = 0)\n\nStart sampling\n\n\nRunning MCMC with 4 parallel chains...\n\nChain 1 finished in 0.5 seconds.\nChain 2 finished in 0.5 seconds.\nChain 3 finished in 0.5 seconds.\nChain 4 finished in 0.5 seconds.\n\nAll 4 chains finished successfully.\nMean chain execution time: 0.5 seconds.\nTotal execution time: 0.6 seconds.\n\n\nNow that we have samples from the prior distribution, we can assemble them to work out what our prior tells us we would, pre-data, predict for the number of active bins for a single monkey (in this a single monkey27 that is 10 years older than the baseline).\n\npred_data <- data.frame(age_centred = 10, day = 1, monkey = \"88\") \ntibble(pred = brms::posterior_predict(prior_draws, \n                                      newdata = pred_data )) |>\n  ggplot(aes(pred)) +\n  geom_histogram(aes(y = after_stat(density)), fill = \"lightgrey\") +\n  geom_vline(xintercept = -1, linetype = \"dashed\") + \n  geom_vline(xintercept = 1, linetype = \"dashed\") +\n  xlim(c(-20,20)) + \n  theme_bw()\n\n\n\n\nThe vertical lines are (approximately) the minimum and maximum of the data. This28 suggests that the implied priors are definitely wider than our observed data, but they are not several orders of magnitude too wide. This is a good situation to be in: it gives enough room in the priors that we might be wrong with our specification while also not allowing for truly wild values of the parameters (and implied predictive distribution). One could even go so far as to say that the prior is weakly informative.\nLet’s compare this to the default priors on the standard deviation parameters. (The default priors on the regression parameters are improper so we can’t simulate from them. So I replaced the improper prior with a much narrower \\(N(0,10^2)\\) prior. If you make the prior on the \\(\\beta\\) wider the prior predictive distribution also gets wider.)\n\npriors_default <- prior(normal(0,10), class = \"b\")\nprior_draws_default <- brm(formula, \n           data = activity_2mins_scaled,\n           prior = priors_default,\n           sample_prior = \"only\",\n           backend = \"cmdstanr\",\n           cores = 4,\n           refresh = 0)\n\nRunning MCMC with 4 parallel chains...\n\nChain 1 finished in 0.4 seconds.\nChain 2 finished in 0.4 seconds.\nChain 3 finished in 0.4 seconds.\nChain 4 finished in 0.4 seconds.\n\nAll 4 chains finished successfully.\nMean chain execution time: 0.4 seconds.\nTotal execution time: 0.5 seconds.\n\ntibble(pred = brms::posterior_predict(prior_draws_default, \n                                      newdata = pred_data )) |>\n  ggplot(aes(pred)) +\n  geom_histogram(aes(y = after_stat(density)), fill = \"lightgrey\") +\n  geom_vline(xintercept = -1, linetype = \"dashed\") + \n  geom_vline(xintercept = 1, linetype = \"dashed\") +\n  theme_bw()\n\n\n\n\nThis is considerably wider."
  },
  {
    "objectID": "posts/2022-09-04-everybodys-got-something-to-hide-except-me-and-my-monkey/everybodys-got-something-to-hide-except-me-and-my-monkey.html#fitting-the-data-or-do-my-monkeys-get-less-interesting-as-they-age",
    "href": "posts/2022-09-04-everybodys-got-something-to-hide-except-me-and-my-monkey/everybodys-got-something-to-hide-except-me-and-my-monkey.html#fitting-the-data-or-do-my-monkeys-get-less-interesting-as-they-age",
    "title": "A first look at multilevel regression; or Everybody’s got something to hide except me and my macaques",
    "section": "Fitting the data; or do my monkeys get less interesting as they age",
    "text": "Fitting the data; or do my monkeys get less interesting as they age\nWith all of that in hand, we can now fit the data. Hooray. This is done with the same command (minus the sample_prior bit).\n\nposterior_draws <- brm(formula, \n           data = activity_2mins_scaled,\n           prior = priors,\n           backend = \"cmdstanr\",\n           cores = 4,\n           refresh = 0)\n\nStart sampling\n\n\nRunning MCMC with 4 parallel chains...\n\nChain 1 finished in 1.2 seconds.\nChain 2 finished in 1.2 seconds.\nChain 3 finished in 1.2 seconds.\nChain 4 finished in 1.2 seconds.\n\nAll 4 chains finished successfully.\nMean chain execution time: 1.2 seconds.\nTotal execution time: 1.3 seconds.\n\nposterior_draws\n\n Family: gaussian \n  Links: mu = identity; sigma = identity \nFormula: active_bins_scaled ~ age_centred * day + (1 | monkey) \n   Data: activity_2mins_scaled (Number of observations: 485) \n  Draws: 4 chains, each with iter = 2000; warmup = 1000; thin = 1;\n         total post-warmup draws = 4000\n\nGroup-Level Effects: \n~monkey (Number of levels: 243) \n              Estimate Est.Error l-95% CI u-95% CI Rhat Bulk_ESS Tail_ESS\nsd(Intercept)     0.31      0.03     0.24     0.37 1.00     1351     2196\n\nPopulation-Level Effects: \n                 Estimate Est.Error l-95% CI u-95% CI Rhat Bulk_ESS Tail_ESS\nIntercept           -0.04      0.03    -0.11     0.02 1.00     4039     2964\nage_centred          0.01      0.07    -0.12     0.14 1.00     3902     3049\nday2                 0.10      0.04     0.03     0.18 1.00     8897     2663\nage_centred:day2     0.07      0.07    -0.07     0.22 1.00     6157     2947\n\nFamily Specific Parameters: \n      Estimate Est.Error l-95% CI u-95% CI Rhat Bulk_ESS Tail_ESS\nsigma     0.43      0.02     0.39     0.47 1.00     1997     2630\n\nDraws were sampled using sample(hmc). For each parameter, Bulk_ESS\nand Tail_ESS are effective sample size measures, and Rhat is the potential\nscale reduction factor on split chains (at convergence, Rhat = 1).\n\n\nThere doesn’t seem to be much of an effect of age in this data.\nIf you’re curious, this matches well29 with the output of lme4, which is a nice sense check for simple models. Generally speaking, if they’re the same then they’re both fine. If they are different30, then you’ve got to look deeper.\n\nlibrary(lme4)\nfit_lme4 <- lmer(formula, activity_2mins_scaled)\nfit_lme4\n\nLinear mixed model fit by REML ['lmerMod']\nFormula: active_bins_scaled ~ age_centred * day + (1 | monkey)\n   Data: activity_2mins_scaled\nREML criterion at convergence: 734.9096\nRandom effects:\n Groups   Name        Std.Dev.\n monkey   (Intercept) 0.3091  \n Residual             0.4253  \nNumber of obs: 485, groups:  monkey, 243\nFixed Effects:\n     (Intercept)       age_centred              day2  age_centred:day2  \n        -0.04114           0.01016           0.10507           0.08507  \n\n\nWe can also compare the fit using leave-one-out cross validation. This is similar to AIC, but more directly interpretable. It is the average of \\[\n\\log p_\\text{posterior predictive}(y_{ij} \\mid y_{-ij}) = \\log \\left(\\int_\\theta p(y_{ij} \\mid \\theta)p(\\theta \\mid y_{-ij})\\, d\\theta\\right),\n\\] where \\(\\theta\\) is a vector of all of the parameters in the model. The notation \\(y_{-ij}\\) is the data without the \\(ij\\)th observation. This average is sometimes called the expected log predictive density or elpd.\nTo compare it with the two linear regression models, I need to fit them in brms. I will use a \\(N(0,1)\\) prior for the monkey intercepts and the same priors as the previous model for the other parameters.\n\npriors_lm <-  prior(normal(0,1), class = \"b\") +\n  prior(normal(0, 0.2), coef = \"age_centred\") + \n  prior(normal(0,0.2), coef = \"age_centred:day2\") +\n  prior(normal(0, 1), coef = \"day2\") +\n  prior(normal(0,1), class = \"Intercept\") +\n  prior(normal(0,1), class = \"sigma\")\n\nposterior_nopool <- brm(\n  active_bins_scaled ~ age_centred * day + monkey, \n  data = activity_2mins_scaled,\n  prior = priors_lm,\n  backend = \"cmdstanr\",\n  cores = 4,\n  refresh = 0)\n\nRunning MCMC with 4 parallel chains...\n\nChain 1 finished in 2.5 seconds.\nChain 3 finished in 2.5 seconds.\nChain 2 finished in 2.5 seconds.\nChain 4 finished in 2.5 seconds.\n\nAll 4 chains finished successfully.\nMean chain execution time: 2.5 seconds.\nTotal execution time: 2.7 seconds.\n\nposterior_pool <- brm(\n  active_bins_scaled ~ age_centred * day, \n  data = activity_2mins_scaled,\n  prior = priors_lm,\n  backend = \"cmdstanr\",\n  cores = 4,\n  refresh = 0)\n\nRunning MCMC with 4 parallel chains...\n\nChain 1 finished in 0.1 seconds.\nChain 2 finished in 0.1 seconds.\nChain 3 finished in 0.1 seconds.\nChain 4 finished in 0.1 seconds.\n\nAll 4 chains finished successfully.\nMean chain execution time: 0.1 seconds.\nTotal execution time: 0.3 seconds.\n\n\nWe an now use the loo_compare function to compare the models. By default, the best model is listed first and the other models are listed below it with the difference in elpd values given. To do this, we need to tell brms to compute the loo criterion using the add_criterion function.\n\nposterior_draws <- add_criterion(posterior_draws, \"loo\")\n\nWarning: Found 6 observations with a pareto_k > 0.7 in model 'posterior_draws'.\nIt is recommended to set 'moment_match = TRUE' in order to perform moment\nmatching for problematic observations.\n\nposterior_nopool <- add_criterion(posterior_nopool, \"loo\")\n\nWarning: Found 61 observations with a pareto_k > 0.7 in model\n'posterior_nopool'. It is recommended to set 'moment_match = TRUE' in order to\nperform moment matching for problematic observations.\n\nposterior_pool <- add_criterion(posterior_pool, \"loo\")\nloo_compare(posterior_draws, posterior_nopool, posterior_pool)\n\n                 elpd_diff se_diff\nposterior_draws    0.0       0.0  \nposterior_pool   -29.2       7.4  \nposterior_nopool -54.2       9.0  \n\n\nThere are some warnings there suggesting that we could recompute these using a slower method, but for the purposes of today I’m not going to do that and I shall declare that the multilevel model performs far better than the other two models."
  },
  {
    "objectID": "posts/2022-09-04-everybodys-got-something-to-hide-except-me-and-my-monkey/everybodys-got-something-to-hide-except-me-and-my-monkey.html#post-experiment-prophylaxis",
    "href": "posts/2022-09-04-everybodys-got-something-to-hide-except-me-and-my-monkey/everybodys-got-something-to-hide-except-me-and-my-monkey.html#post-experiment-prophylaxis",
    "title": "A first look at multilevel regression; or Everybody’s got something to hide except me and my macaques",
    "section": "Post-experiment prophylaxis",
    "text": "Post-experiment prophylaxis\nOf course, we would be fools to just assume that because we fit a model and compared it to some other models, the model is a good representation of the data. To do that, we need to look at some posterior checks.\nThe easiest thing to look at is the predictions themselves.\n\nfitted <- activity_2mins_scaled |>\n  cbind(t(posterior_predict(posterior_draws,ndraws = 200))) |>\n  pivot_longer(8:207, names_to = \"draw\", values_to = \"fitted\")\n\nday_labs <- c(\"Day 1\", \"Day 2\")\nnames(day_labs) <- c(\"1\", \"2\")\n\nviolin_plot <- fitted |> \n  ggplot(aes( x=age, y = 4*fitted + active_bins_centre, group = age)) + \n  geom_violin(colour = \"lightgrey\") +\n  geom_point(aes(y = active_bins), colour = \"red\") +\n  facet_wrap(~day, labeller = labeller(day = day_labs)) +\n  theme_bw() \nviolin_plot\n\n\n\n\nThat appears to be a reasonably good fit, although it’s possible that the prediction intervals are a bit wide. We can also look at the plot of the posterior residuals vs the fitted values. Here the fitted values are the mean of the posterior predictive distribution.\nNext, let’s check for evidence of non-linearity in age.\n\nplot_data <- activity_2mins_scaled |>\n  mutate(fitted_mean = colMeans(posterior_epred(posterior_draws,ndraws = 200)))\n\nage_plot <- plot_data |> \n  ggplot(aes(x = age, y = active_bins_scaled - fitted_mean)) +\n  geom_point() +\n  theme_bw()\nage_plot\n\n\n\n\nThere doesn’t seem to be any obvious evidence of non-linearity in the residuals, which suggests the linear model for age was sufficient.\nWe can also check the distributional assumption31 that the residuals \\[\nr_{ij} = y_{ij} - \\mu_j\n\\] have a Gaussian distribution. We can check this with a qq-plot. Here we are using the posterior mean to define our residuals.\nWe can look at the qq-plot to see how we’re doing with normality.\n\ndistribution_plot <- plot_data |> ggplot(aes(sample = (active_bins_scaled - fitted_mean)/sd(active_bins_scaled - fitted_mean))) + \n  stat_qq() +\n  geom_abline(slope = 1, intercept = 0, linetype = \"dashed\") + \n  theme_classic()\ndistribution_plot\n\n\n\n\nThat’s not too bad. A bit of a deviation from normality in the tails but nothing that would make me weep. It could well be an artifact of how I defined and normalised the residuals.\nWe can also look at the so-called k-hat plot, which can be useful for finding high-leverage observations in general models.\n\nloo_posterior <- LOO(posterior_draws) #warnings suppressed\nloo_posterior\n\n\nComputed from 4000 by 485 log-likelihood matrix\n\n         Estimate   SE\nelpd_loo   -349.5 12.3\np_loo       117.0  5.1\nlooic       699.0 24.6\n------\nMonte Carlo SE of elpd_loo is NA.\n\nPareto k diagnostic values:\n                         Count Pct.    Min. n_eff\n(-Inf, 0.5]   (good)     417   86.0%   748       \n (0.5, 0.7]   (ok)        62   12.8%   341       \n   (0.7, 1]   (bad)        6    1.2%   275       \n   (1, Inf)   (very bad)   0    0.0%   <NA>      \nSee help('pareto-k-diagnostic') for details.\n\nplot(loo_posterior)\n\n\n\n\nThis suggests that observations 10, 233, 234, 367, 394, 479 are potentially high leverage and we should check them more carefully. I won’t be doing that today.\nFinally, let’s look at the residuals vs the fitted values. This is a commonly used diagnostic plot in linear regression and it can be very useful for visually detecting non-linear patterns and heteroskedasticity in the residuals. So let’s make the plot32.\n\nproblem_plot <- plot_data |> \n  ggplot(aes(x = fitted_mean, y = active_bins_scaled - fitted_mean)) + \n  geom_point() +\n  geom_smooth(method = \"lm\", se = FALSE, linetype = \"dashed\", colour = \"blue\")+\n  facet_wrap(~day) +\n  theme_bw() +  theme(legend.position=\"none\") +\n  xlim(c(-1,1)) +\n  ylim(c(-1,1))\nproblem_plot\n\n\n\n\nHmmmm. That’s not excellent. The stripes are related to the 8 distinct values the response can take, but there is definitely a trend in the residuals. In particular, we are under-predicting small values and over-predicting large values. There is something here and we will look into it!"
  },
  {
    "objectID": "posts/2022-09-04-everybodys-got-something-to-hide-except-me-and-my-monkey/everybodys-got-something-to-hide-except-me-and-my-monkey.html#understanding-diagnostic-plots-from-multilevel-models",
    "href": "posts/2022-09-04-everybodys-got-something-to-hide-except-me-and-my-monkey/everybodys-got-something-to-hide-except-me-and-my-monkey.html#understanding-diagnostic-plots-from-multilevel-models",
    "title": "A first look at multilevel regression; or Everybody’s got something to hide except me and my macaques",
    "section": "Understanding diagnostic plots from multilevel models",
    "text": "Understanding diagnostic plots from multilevel models\nThe thing is, multilevel models are notorious for having patterns that are essentially a product of the data design and not of any type of statistical misspecification. In a really great paper that you should all read, Adam Loy, Heike Hofmann, and Di Cook talk extensively about the challenges with interpreting diagnostic plots for linear mixed effects models33.\nI’m not going to fully follow their recommendations, mostly because I’m too lazy34 to write a for loop, but I am going to appropriate the guts of their idea.\nThey note that strange patterns can occur in diagnostic plots even for correctly specified models. Moreover, we simply do not know what these patters will be. It’s too complex a function of the design, the structure, the data, and the potential misspecification. That sounds bad, but they note that we don’t need to know what pattern to expect. Why not? Because we can simulate it!\nSo this is the idea: Let’s simulate some fake35 data from a correctly specified model that otherwise matches with our data. We can then compare the diagnostic plots from the fake data with diagnostic plots from the real data and see if the patterns are meaningfully different.\nIn order to do this, we should have a method to construct multiple fake data sets. Why? Well a plot is nothing but another test statistic and we must take this variability into account.\n(That said, do what I say, not what I do. This is a blog. I’m not going to code well enough to make this clean and straightforward, so I’m just going to do one.)\nThere is an entire theory of visual inference that uses these lineups of diagnostic plots, where one uses the real data and the rest use realisations of the null data, that is really quite interesting and well beyond the scope of this post. But if you want to know more, read the Low, Hoffman, and Cook paper!\n\nMaking new data\nThe first thing that we need to do is to work out how to simulate fake data from a correctly specified model with the same structure. Following the Low etc paper, I’m going to do a simple parameteric bootstrap, where I take the posterior medians of the fitted distribution and simulate data from them.\nThat said, there are a bunch of other options. Specifically, we have a whole bag of samples from our posterior distribution and it would be possible to use that to select values of36 \\((\\mu, \\beta, \\tau, \\sigma)\\) for our simulation.\nSo let’s make some fake data and fit the model to it!\n\nmonkey_effect <- tibble(monkey = unique(activity_2mins_scaled$monkey), \n                        monkey_effect = rnorm(243,0,0.31))\ndata_fake <- activity_2mins_scaled |>\n  left_join(monkey_effect, by = \"monkey\")  |>\n  mutate(active_bins_scaled = rnorm(length(age_centred),\n            mean = -0.04 +0.01 * age_centred + \n              monkey_effect + if_else(day == \"2\", 0.1 + 0.085 *age_centred, 0.0), \n            sd = 0.43))\n                                              \nposterior_draws_fake <- brm(formula, \n           data = data_fake,\n           prior = priors,\n           backend = \"cmdstanr\",\n           cores = 4,\n           refresh = 0)\n\nRunning MCMC with 4 parallel chains...\n\nChain 1 finished in 1.2 seconds.\nChain 2 finished in 1.2 seconds.\nChain 3 finished in 1.3 seconds.\nChain 4 finished in 1.2 seconds.\n\nAll 4 chains finished successfully.\nMean chain execution time: 1.2 seconds.\nTotal execution time: 1.4 seconds.\n\n\n\n\nThe good plots\nFirst up, let’s look at the violin plot.\n\nlibrary(cowplot)\nfitted_fake <- data_fake |>\n  cbind(t(posterior_predict(posterior_draws_fake,ndraws = 200))) |>\n  pivot_longer(8:207, names_to = \"draw\", values_to = \"fitted\")\n\nday_labs <- c(\"Day 1\", \"Day 2\")\nnames(day_labs) <- c(\"1\", \"2\")\n\nviolin_fake <- fitted_fake |> \n  ggplot(aes( x=age, y = 4*fitted + active_bins_centre, group = age)) + \n  geom_violin(colour = \"lightgrey\") +\n  geom_point(aes(y = active_bins), colour = \"red\") +\n  facet_wrap(~day, labeller = labeller(day = day_labs)) +\n  theme_bw() \n  \nplot_grid(violin_plot, violin_fake, labels = c(\"Real\", \"Fake\"))\n\n\n\n\nThat’s very similar to our data plot.\nNext up, we will look at the residuals ordered by age\n\nplot_data_fake <- data_fake |>\n  mutate(fitted_mean = colMeans(posterior_epred(posterior_draws_fake,ndraws = 200)))\n\nage_fake <- plot_data_fake |> \n  ggplot(aes(x = age, y = active_bins_scaled - fitted_mean)) +\n  geom_point() +\n  theme_bw()\nplot_grid(age_plot, age_fake, labels = c(\"Real\", \"Fake\"))\n\n\n\n\nFabulous!\nNow let’s check the distributional assumption on the residuals!\n\ndistribution_fake <- plot_data_fake |>\n  ggplot(aes(sample = (active_bins_scaled - fitted_mean)/sd(active_bins_scaled - fitted_mean))) + \n  stat_qq() +\n  geom_abline(slope = 1, intercept = 0, linetype = \"dashed\") + \n  theme_classic()\n\nplot_grid(distribution_plot, distribution_fake, labels = c(\"Real\", \"Fake\"))\n\n\n\n\nExcellent!\nFinally, we can look at the k-hat plot. Because I’m lazy, I’m not going to put them side by side. You can scroll.\n\nloo_fake <- LOO(posterior_draws_fake)\n\nWarning: Found 4 observations with a pareto_k > 0.7 in model\n'posterior_draws_fake'. It is recommended to set 'moment_match = TRUE' in order\nto perform moment matching for problematic observations.\n\nloo_fake\n\n\nComputed from 4000 by 485 log-likelihood matrix\n\n         Estimate   SE\nelpd_loo   -362.3 14.3\np_loo       115.1  5.8\nlooic       724.6 28.5\n------\nMonte Carlo SE of elpd_loo is NA.\n\nPareto k diagnostic values:\n                         Count Pct.    Min. n_eff\n(-Inf, 0.5]   (good)     422   87.0%   571       \n (0.5, 0.7]   (ok)        59   12.2%   205       \n   (0.7, 1]   (bad)        4    0.8%   169       \n   (1, Inf)   (very bad)   0    0.0%   <NA>      \nSee help('pareto-k-diagnostic') for details.\n\nplot(loo_fake)\n\n\n\n\nAnd look: we get some extreme values. (Depending on the run we get more or less). This suggests that while it would be useful to look at the data points flagged by the k-hat statistic, it may just be sampling variation.;\nAll of this suggests our model assumptions are not being grossly violated. All except for that residual vs fitted values plot…\n\n\nThe haunted residual vs fitted plot\nNow let’s look at our residual vs fitted plot.\n\nproblem_fake <- plot_data_fake |> \n  ggplot(aes(x = fitted_mean, y = active_bins_scaled - fitted_mean)) + \n  geom_point() +\n  geom_smooth(method = \"lm\", se = FALSE, linetype = \"dashed\", colour = \"blue\")+\n  facet_wrap(~day) +\n  theme_bw() +  theme(legend.position=\"none\") +\n  xlim(c(-1,1)) +\n  ylim(c(-1,1))\nplot_grid(problem_plot, problem_fake, labels = c(\"Real\", \"Fake\"))\n\n\n\n\nAnd what do you know! They look the same. (Well, minus the discretisation artefacts.)\n\n\nSo what the hell is going on?\nGreat question! It turns out that this is one of those cases where our intuition from linear models does not transfer over to multilevel models.\nWe can actually reason this out by thinking about a model where we have no covariates.\nIf we have no pooling then the observations for every monkey are, essentially, averaged to get our estimate of \\(\\mu_j\\). If we repeat this, we will find that our \\(\\mu_j\\) are basically37 unbiased and the corresponding residual \\[\nr_{ij} = y_{ij} - \\mu_j\n\\] will have mean zero.\nBut that’s not what happens when we have partial pooling. When we have partial pooling we are combining our naive average38 \\(\\bar y_j\\) with the global average \\(\\mu\\) in a way that accounts for the size of group \\(j\\) relative to other groups as well as the within-group variability relative to the between-group variability.\n\n\nExpand for maths. Just a little\n\nThere is, in fact, a formula for it. Just in case you’re a formula sort of person. The posterior estimate for a Gaussian multilevel model with an intercept but no covariates is \\[\n\\frac{1}{1 +\\frac{\\sigma^2/n}{\\tau^2}}\\left(\\bar{y}_j + \\frac{\\sigma^2/n}{\\tau^2} \\mu\\right).\n\\] When \\(\\sigma/\\sqrt{n}\\) is small, which happens when the sampling standard deviation of \\(\\bar y_j\\) is small relative to the between group variation \\(\\tau\\), this is almost equal to \\(\\bar{y}_j\\) and there is almost no pooling. On the other hand, when \\(\\sigma/\\sqrt{n}\\) is large relative to \\(\\tau\\), then the estimate of \\(\\mu_j\\) will be very close to the overall mean \\(\\mu\\).\n\nThe short version is that there is some magical number \\(\\alpha\\), which depends on \\(\\tau\\), \\(\\sigma\\), and \\(n_j\\) such that \\[\n\\hat \\mu_j = \\alpha \\bar{y}_j + (1-\\alpha) \\mu.\n\\] Because of this, the residuals \\[\nr_{ij} = y_j - \\alpha \\bar{y_j} - (1-\\alpha)\\mu\n\\] are suddenly not going to have mean zero.\nIn fact, if we think about it a bit more, we will realise that the model will drag extreme groups to the centre, which accounts for the positive slope in the residuals vs the fitted values.\nThe slope in this example is quite extreme because the groups are very small (only one or two individuals). But it is a general phenomenon and it’s discussed extensively in Chapter 7 of Jim Hodges’ excellent book. His suggestion is that there isn’t really a good, general way to remove the trend. But that doesn’t mean the plot is useless. It is still able to pinpoint outliers and heteroskedasticity. You’ve just got to tilt your head.\nBut for the purposes of today we can notice that there don’t seem to be any extreme outliers so everything is probably ok."
  },
  {
    "objectID": "posts/2022-09-04-everybodys-got-something-to-hide-except-me-and-my-monkey/everybodys-got-something-to-hide-except-me-and-my-monkey.html#conclusion",
    "href": "posts/2022-09-04-everybodys-got-something-to-hide-except-me-and-my-monkey/everybodys-got-something-to-hide-except-me-and-my-monkey.html#conclusion",
    "title": "A first look at multilevel regression; or Everybody’s got something to hide except me and my macaques",
    "section": "Conclusion",
    "text": "Conclusion\nSo what have we done? Well we’ve gone through the process of fitting and scruitinising a simple Bayesian multilevel model. We’ve talked about some of the challenges associated with graphical diagnostics for structured data. And we’ve all39 learnt something about the residual-vs-fitted plot for a multilevel model.\nMost importantly, we’ve all learnt the value of using fake data simulated from the posterior model to help us understand our diagnostics.\nThere is more to the scientific story here. It turns out that while there is no effect over 2 minutes, there is a slight effect over 20 minutes. So the conceptual replication failed, but still found some interesting things.\nOf course, I’ve ignored one big elephant in the room: That data was discrete. In the end, our distributional diagnostics didn’t throw up any massive red flags, but nevertheless it could be an interesting exercise to see what happens if we use a more problem-adapted likelihood.\nLast, and certainly not least, I barely scratched the surface40 of the Loy, Hoffman, and Cook paper. Anyone who is interested in fitting Gaussian multilevel models should definitely give it a read."
  },
  {
    "objectID": "posts/2021-10-14-priors2/priors2.html",
    "href": "posts/2021-10-14-priors2/priors2.html",
    "title": "Priors: Whole New Way (Track 2)",
    "section": "",
    "text": "If we’re going to talk about priors, let’s talk about priors. And let’s talk about the most prior-y priors in the whole damn prior universe. Let’s talk about conjugate priors."
  },
  {
    "objectID": "posts/2021-10-14-priors2/priors2.html#ok.-maybe-we-should-try-again",
    "href": "posts/2021-10-14-priors2/priors2.html#ok.-maybe-we-should-try-again",
    "title": "Priors: Whole New Way (Track 2)",
    "section": "Ok. Maybe we should try again",
    "text": "Ok. Maybe we should try again\nDeep breaths. You soul is an island of positivity.\n\nWhat is a conjugate prior?\nConjugate priors are wild and fabulous beasts. They roam the strange, mathematic plains and live forever in our dreams of a better future.\nToo much?\nOK.\nConjugate priors are a mathematical curiosity that occasional turn out to be slightly useful.\nA prior distribution \\(p(\\theta)\\) is conjugate to the likelihood1 \\(p(y \\mid \\theta)\\) if the posterior distribution \\(p(\\theta \\mid y)\\) is in the same distributional family as the prior.\nMoreover, there is an rule to update the parameters in the prior to get the parameters in the posterior based on some simple summaries of the data. This means that you can simply write the posterior down as a specific distribution that you can2 easily sample from and get on with your life.\nReally, it seems like a pretty good thing. But there is, unsurprisingly, a hitch: almost no likelihoods have conjugate priors. And if you happen to have a model with a nice3 conjugate prior then good for you, but if you modify your model even slightly, you will no longer have one.\nThat is, the restriction to conjugate priors is a massive restriction on your entire model.\n\n\nWho uses conjugate priors?\nConjugate priors are primarily used by two types of people:\n\nPeople who need to write exam questions for undergraduate Bayesian statistics courses4,\nPeople who need to implement a Gibbs sampler and don’t want to live through the nightmare5 that is Metropolis-within-Gibbs.\n\nFor the most part, we can ignore the first group of people as a drain on society.\nThe second group is made up of:\n\npeople who are using software that forces it on them. And like we don’t all have time to learn new software6. Leave, as hero7 Chris Crocker, Britney alone.\npeople who are writing their own Gibbs sampler. Annie Lennox said it best: Why-y-y-y-y-y-y-y-y-y-y? For a very large variety of problems, you do not have to do this8. The exception is when you have a discrete parameter in your model that you can’t marginalise out9, like an exponential random graph model or something equally hideous. Thankfully, a lot of work in machine learning has expanded the options for Bayesian and pseudo-semi-kinda Bayesian10 estimation of these types of models. Anyway. Discrete parameters are disgusting. I am tremendously indiscrete.\n\nThe third type are the odd ducks who insist that because the posterior and the prior being in the same family means that the prior can be interpreted as the outcome of Bayesian analysis on a previous experiment. Instead of the much more realistic way of arriving at a conjugate prior where you find yourself waking up alone in a bathtub full of ice and using an \\(\\text{Inverse-Gamma}(1/2, 0.0005)\\) prior on the variance (which is conjugate for a Gaussian likelihood) because some paper from 199511 told you it was a good choice.\n\n\nShould I use conjugate priors?\nThere is actually one situation where they can be pretty useful. If your parameter space breaks down into \\(\\theta = (\\eta, \\phi)\\), where \\(\\eta\\) is a high-dimensional variable, then if \\(p(y \\mid \\theta) = p(y \\mid \\eta)\\) and \\(p(\\eta \\mid \\phi)\\) is conjugate for \\(p(y \\mid \\eta)\\), then a magical thing happens: you can compute \\(p(\\eta \\mid y, \\phi)\\) explicitly (using the conjugate property) and then you can greatly simplify the posterior as \\(p(\\theta\\mid y ) = p(\\eta \\mid y, \\phi) p(\\phi \\mid y)\\), where12 \\[\np(\\phi \\mid y) = \\frac{p(y \\mid \\eta)p(\\eta \\mid \\phi)p(\\phi)}{p(y) p(\\eta \\mid y, \\phi)} \\propto \\left.\\frac{p(y \\mid \\eta)p(\\eta \\mid \\phi)p(\\phi)}{p(\\eta \\mid y, \\phi)}\\right|_{\\eta = \\text{anything}},\n\\] where every term on the right hand side is able to be calculated13. Even if this doesn’t have a known distribution form, it is much much lower-dimensional than the original problem and much more amenable to MCMC or possibly deterministic integration methods.\nThis really does feel a bit abstract, so I will give you the one case where I know it’s used very commonly.This is the case where \\(y \\sim N(A\\eta, R)\\) and14 \\(\\eta \\mid \\phi \\sim N(0, \\Sigma(\\phi))\\), where \\(\\Sigma(\\phi)\\) is a covariance matrix and \\(A\\) is a matrix (the dimension of \\(\\eta\\) is often higher than the dimension of \\(y\\)).\nThis is an example of a class of models that occur constantly in statistics: Håvard Rue15 calls them Latent Gaussian models. They basically extend16 (geostatistical)? linear|additive (mixed)? models. So for all of these models, we can explicitly integrate out the high-dimensional Gaussian component, which makes inference a breeze17.\nIt gets slightly better than that because if you combine this observation with a clever asymptotic approximation, you get an approximately conjugate model and can produce Laplace approximations, nested Laplace approximations18, and Integrated Nested Laplace approximations19, depending on how hard you are willing to work.\n\n\nA conclusion, such as it is\nYes we have drifted somewhat from the topic, but that’s because the topic is boring.\nConjugate priors are mostly a mathematical curiosity and their role in Bayesian statistics is inexplicably inflated20 to make them seem like a core topic. If you never learn about conjugate priors your Bayesian education will not be lacking anything. It will not meaningfully impact your practice. But even stopped clocks are right 2-3 times a day21"
  },
  {
    "objectID": "posts/2021-11-24-getting-into-the-subspace/getting-into-the-subspace.html",
    "href": "posts/2021-11-24-getting-into-the-subspace/getting-into-the-subspace.html",
    "title": "Getting into the subspace; or what happens when you approximate a Gaussian process",
    "section": "",
    "text": "Now that we know what they are, I guess we should do something with a Gaussian process. But we immediately hit a problem. You see, Gaussian processes are charming things, sweet and caring. But they have a dark side. Used naively1, they’re computationally expensive when you’ve got a lot of data.\nStab of dramatic music\nYeah. So. What’s the problem here? Well, the first problem is people seem to really like having a lot of data. Fuck knows why. Most of it is rubbish2. But they do.\nThis is a problem for our poor little Gaussian processes because of how the data tends to come.\nA fairly robust model for data is that it comes like \\[\n(y_i, s_i, x_i),\n\\] where \\(y_i\\) is our measurement of choice (which might be a continuous, discrete or weird3), \\(s_i\\) is our location4 in the index set5 \\(\\Omega\\) (usually \\(\\Omega \\subset \\mathbb{R}^d\\)) of the Gaussian process, and \\(x_i\\) is whatever other information we have6. If we want to be really saucy, we could also assume these things are iid samples from some unknown distribution and then pretend like that isn’t a wildly strong structural assumption. But I’m not like that. I’ll assume the joint distribution of the samples is exchangeable7 8 9. Or something. I’m writing this sequentially, so I have no idea where this is going to end up.\nSo where is the problem? The problem is that, if we use the most immediately computational definition of a Gaussian process, then we need to build \\[\n\\begin{pmatrix} u(s_1)\\\\ u(s_2) \\\\ \\vdots \\\\ u(s_n)\\end{pmatrix} \\sim N\\left(\n\\begin{pmatrix} \\mu(s_1)\\\\ \\mu(s_2) \\\\ \\vdots \\\\ \\mu(s_n)\\end{pmatrix},\n\\begin{pmatrix} c(s_1, s_1) & c(s_1, s_2) & \\cdots & c(s_1, s_n)  \\\\ c(s_2, s_1) & c(s_2, s_2) & \\cdots & c(s_2, s_n) \\\\\\vdots &\\vdots  &\\ddots &\\vdots \\\\ c(s_n, s_1) & c(s_n, s_2) & \\cdots & c(s_n, s_n)\\end{pmatrix}\\right).\n\\] Where \\(s_1,\\ldots, s_n\\) are all of the distinct values of \\(s_i\\) in the dataset. If there are a lot of these, the covariance matrix is very large and this becomes a problem. First, we must construct it. Then we must solve it. Then we must do actual computations with it. The storage scales quadratically in \\(n\\). The computation scales cubically in \\(n\\). This is too much storage and too much computation if the data set has a lot of distinct GP evaluations, it will simply be too expensive to do the matrix work that we need to do in order to make this run.\nSo we need to do something else."
  },
  {
    "objectID": "posts/2021-11-24-getting-into-the-subspace/getting-into-the-subspace.html#a-tangent-or-can-we-just-be-smarter",
    "href": "posts/2021-11-24-getting-into-the-subspace/getting-into-the-subspace.html#a-tangent-or-can-we-just-be-smarter",
    "title": "Getting into the subspace; or what happens when you approximate a Gaussian process",
    "section": "A tangent; or Can we just be smarter?",
    "text": "A tangent; or Can we just be smarter?\nOn a tangent, because straight lines are for poor souls who don’t know about Gaussian processes, there’s a body of work on trying to circumvent this problem by being good at maths. The idea is to try to find some cases where we don’t need to explicitly form the covariance matrix in order to do all of the calculations. There’s a somewhat under-cooked10 literature on this. It dances around an idea that traces back to fast multipole methods for integral equations: We know that correlations decay as points get further apart, so we do not need to calculate the correlations between points that are far apart as well as we need to calculate the correlations between points that are close together. For a fixed covariance kernel that decays in a certain way, you can modify the fast multipole method, however it’s more fruitful to use an algebraic11 method. H-matrices was the first real version of this, and there’s a paper from 2008 using them to approximate GPs. A solid chunk of time later, there have been two good papers recently on this stuff. Paper 1 Paper 2. These methods really only provide gradient descent type methods for maximum likelihood estimation and it’s not clear to me that you’d be able to extend these ideas easily to a Bayesian setting (particularly when you need to infer some parameters in the covariance function)12.\nI think this sort of stuff is cool for a variety of reasons, but I also don’t think it’s the entire solution. (There was also a 2019 NeurIPS paper that scales a GP fit to a million observations as if that’s a good idea. It is technically impressive, however.) But I think the main possibility of the H-matrix work is that it allows us to focus on the modelling and not have to make premature trade offs with the computation.\nThe problem with modelling a large dataset using a GP is that GPs are usually fit with a bunch of structural assumptions (like stationarity and isotropy) that are great simplifying assumptions for moderate data sizes but emphatically do not capture the complex dependency structures when there is a large amount of data. As you get more data, your model should become correspondingly more complex13 and stationary, and/or isotropic Gaussian processes emphatically do not do this.\nThis isn’t to say that you shouldn’t use GPs on a large data set (I am very much on record as thinking you should), but that it needs to be a part of your modelling arsenal and probably not the whole thing. The real glory of GPs is that they are a flexible enough structure to play well with other modelling techniques. Even if you end up modelling a large data set with a single GP, that GP will most likely be anisotropic, non-stationary, and built up from multiple scales. Which is a different way to say that it likely does not have a squared exponential kernel with different length scales for each feature.\n(It’s probably worth making the disclaimer at this point, but when I’m thinking about GPs, I’m typically thinking about them in 1-4 dimensions. My background is in spatial statistics, so that makes sense. Some of my reasoning doesn’t apply in more typical machine learning applications where \\(s_i\\) might be quite high-dimensional. That said, you simply get a different end of the same problem. In that case you need to balance the smoothness needed to interpolate in high dimensions with the structure needed to allow your variables to be a) scaled differently and b) correlated. Life is pain either way.)"
  },
  {
    "objectID": "posts/2021-11-24-getting-into-the-subspace/getting-into-the-subspace.html#so-can-we-make-things-better",
    "href": "posts/2021-11-24-getting-into-the-subspace/getting-into-the-subspace.html#so-can-we-make-things-better",
    "title": "Getting into the subspace; or what happens when you approximate a Gaussian process",
    "section": "So can we make things better?",
    "text": "So can we make things better?\nThe problem with Gaussian processes, at least from a computational point of view, is that they’re just too damn complicated. Because they are supported on some infinite dimensional Banach space \\(B\\), the more we need to see of them (for instance because we have a lot of unique \\(s_i\\)s) the more computational power they require. So the obvious solution is to somehow make Gaussian processes less complex.\nThis somehow has occupied a lot of people’s time over the last 20 years and there are many many many many possible options. But for the moment, I just want to focus on one of the generic classes of solutions: You can make Gaussian processes less computationally taxing by making them less expressive.\nOr to put it another way, if you choose an \\(m\\) dimensional subspace \\(V_m \\subset B\\) and rep;ace the GP \\(u\\), which is supported on the whole of \\(B\\), with a different Gaussian process \\(u_m\\) supported on \\(V_m\\), then all of your problems go away.\nWhy? Well because the Gaussian process on \\(V_m\\) can be represented in terms of an \\(m\\)-dimensional Gaussian random vector. Just take \\(\\phi_j\\), \\(j=1,\\ldots, m\\) to be a basis for \\(V_m\\), then the GP \\(u_m\\) can be written as \\[\nu_m = \\sum_{j=1}^m w_j \\phi_j,\n\\] where \\(w \\sim N(\\mu, \\Sigma)\\), for some \\(\\mu\\) and \\(\\Sigma\\). (The critical thing here is that the \\(\\phi_j\\) are functions so \\(u_m\\) is still a random function! That link between the multivariate Gaussian \\(w\\) and the function \\(u_m\\) that can be evaluated at any \\(s_i\\) is really important!)\nThis means that I can express my Gaussian process prior in terms of the multivariate Gaussian prior on \\(w\\), and I only need \\(\\mathcal{O}(m^3)\\) operations to evaluate its log-density.\nIf our observation model is such that \\(p(y_i \\mid u) = p(y_i \\mid u(s_i))\\), and we assume conditional14 independence, then we can eval the log-likelihood term \\[\n\\sum_{i=1}^n p(y \\mid u_m(s_i)) = \\sum_{i=1}^n p(y \\mid a_i^Tw)\n\\] in \\(\\mathcal{O}(m^2 n)\\) operations. Here \\([a_i]_j = \\phi_j(s_i)\\) is the vector that links the basis in \\(u_n\\) that we use to define \\(w\\) to the observation locations15.\nMany have been tempted to look at the previous paragraph and conclude that a single evaluation of the log-posterior (or its gradient) will be \\(\\mathcal{O}(n)\\), as if that \\(m^2\\) multiplier were just a piece of fluff to be flicked away into oblivion.\nThis is, of course, sparkly bullshit.\nThe subspace size \\(m\\) controls the trade off between bias and computational cost and, if we want that bias to be reasonably small, we need \\(m\\) to be quite large. In a lot of cases, it needs to grow with \\(n\\). A nice paper by David Burt, Carl Rasmussen, and Mark van der Wilk suggests that \\(m(n)\\) needs to depend on the covariance function16. In the best case (when you assume your function is so spectacularly smooth that a squared-exponential covariance function is ok), you need something like \\(m = \\mathcal{O}(\\log(n)^d)\\), while if you’re willing to make a more reasonable assumption that your function has \\(\\nu\\) continuous17 derivatives, then you need something like \\(m = \\mathcal{O}(n^\\frac{2d}{2\\nu-d})\\).\nYou might look at those two options for \\(m\\) and say to yourself “well shit. I’m gonna use a squared exponential from now on”. But it is never as simple as that. You see, if you assume a function is so smooth it is analytic18, then you’re assuming that it lacks the derring-do to be particularly interesting between its observed values19. This translates to relatively narrow uncertainty bands. Whereas a function with \\(\\nu\\) derivatives has more freedom to move around the smaller \\(\\nu\\) is. This naturally results in wider uncertainty bands.\nI think20 in every paper I’ve seen that compares a squared exponential covariance function to a Matérn-type covariance function (aka the ones that let you have \\(\\nu\\)-times differentiable sample paths), the Matérn family has performed better (in my mind this is also in terms of squared error, but it’s definitely the case when you’re also evaluating the uncertainty of the prediction intervals). So I guess the lesson is that cheap isn’t always good?\nAnyway. The point of all of this is that if we can somehow restrict our considerations to an \\(m\\)-dimensional subspace of \\(B\\), then we can get some decent (if not perfect) computational savings.\nBut what are the costs?"
  },
  {
    "objectID": "posts/2021-11-24-getting-into-the-subspace/getting-into-the-subspace.html#some-notation-that-rapidly-degenerates-into-a-story-thats-probably-not-interesting",
    "href": "posts/2021-11-24-getting-into-the-subspace/getting-into-the-subspace.html#some-notation-that-rapidly-degenerates-into-a-story-thats-probably-not-interesting",
    "title": "Getting into the subspace; or what happens when you approximate a Gaussian process",
    "section": "Some notation that rapidly degenerates into a story that’s probably not interesting",
    "text": "Some notation that rapidly degenerates into a story that’s probably not interesting\nSo I guess the key question we need to answer before we commit to any particular approximation of our Gaussian process is what does it cost? That is, how does the approximation affect the posterior distribution?\nTo quantify this, we need a way to describe the posterior of a Gaussian process in general. As happens so often when dealing with Gaussian processes, shit is about to get wild.\nA real challenge with working with Gaussian processes theoretically is that they are objects that naturally live on some (separable21) Banach space \\(B\\). One of the consequences of this is that we cannot just write the density of \\(u\\) as \\[\np(u) \\propto  \\exp\\left(-\\frac{1}{2}C_u(u, u)\\right)\n\\] because there is no measure22 on \\(B\\) such that \\[\n\\Pr(u \\in A) = \\int_A p(u)\\,du.\n\\]\nThis means that we can’t just work with densities to do all of our Bayesian stuff. We need to work with posterior probabilities properly.\nUgh. Measures.\nSo let’s do this. We are going to need a prior probability associated with the Gaussian process \\(u\\), which we will write as \\[\n\\mu_0(A) = \\Pr(u \\in A),\n\\] where \\(A\\) is a nice23 set in \\(B\\). We can then use this as a base for our posterior, which we define as \\[\n\\mu^y(A) = \\Pr(u \\in A \\mid y) = \\frac{1}{Z}\\mathrm{e}^{-\\Phi(u;y)},\n\\] where \\(\\Phi(u;y)\\) is the negative log-likelihood function. Here \\(Z\\) is the normalising constant \\[\nZ = \\mathbb{E}_\\mu\\left( \\mathrm{e}^{-\\Phi(u;y)}\\right),\n\\] which is finite as long as \\(\\exp(-\\Phi(u;y)) \\leq C(\\epsilon)\\exp(\\epsilon\\|u\\|^2)\\) for all \\(\\epsilon > 0\\), where \\(C(\\epsilon)\\geq 0\\) is a constant. This is a very light condition.\nThis way of looking at posteriors resulting Gaussian process priors was popularised in the inverse problems literature24. It very much comes from a numerical analysis lens: the work is framed as here is an object, how do we approximate it?.\nThese questions are different to the traditional ones answered by a theoretical statistics papers, which are almost always riffs on “what happens in asymptopia?”.\nI came across this work for two reasons: one is because I have been low-key fascinated by Gaussian measures ever since I saw a talk about them during my PhD; and secondly my PhD was in numerical analysis, so I was reading the journals when these papers came out.\nThat’s not why I explored these questions, though. That is a longer story. The tl;dr is\n\nI had to learn this so I could show a particular point process model converges, and so now the whole rest of this blog post is contained in a technical appendix that no one has ever read in this paper.\n\n\nHere comes the anecdote. Just skip to the next bit. I know you’re like “but Daniel just delete the bullshit text” but that is clearly not how this works.\n\n\nExpand at your peril\n\nI know these papers pretty much backwards for the usual academic reason: out of absolute spite. One of my postdocs involved developing some approximation methods for Markovian Gaussian processes25, which allowed for fast computation, especially when combined with INLA26, which is a fabulous method for approximating posterior distributions when a big chunk of the unobserved parameters have a joint Gaussian prior27.\nOne of the things that INLA was already pretty good at doing was fitting log-Gaussian Cox processes (LGCP), which are a type of model for point patterns28 that can be approximated over a regular grid by a Poisson regression with a log-mean given by (covariates +) a Gaussian process defined on the grid. If that process is Markov, you can get full posterior inference quickly and accurately using INLA. This compared very favourably with pre-INLA methods, which gave you full posterior inference laboriously using a truncated gradient MALA scheme in about the same amount of time it would take the US to get a high-speed rail system.\nAnyway. I was in Trondheim working on INLA and the, at that stage, very new SPDE29 stuff (the 2011 JRSSSB read paper had not been written yet, let alone been read). Janine Illian, who is a very excellent statistician and an all round fabulous person, had been working on the grided LGCP stuff in INLA and came to Trondheim to work with Håvard30 and she happened to give a seminar on using these new LGCP methods to do species distribution mapping. I was strongly encouraged to work with Janine to extend her grid methods to the new shiny SPDE methods, which did not need a grid.\nJanine had to tell me what a Poisson distribution was.\nAnyway. A little while later31 we had a method that worked and we32 wrote it up. We submitted it to Series B and they desk rejected it. We then, for obscure reasons33, submitted it to Biometrika. Due to the glory of arXiv, I can link to the original version.\nAlthough it was completely unlike anything else that Biometrika publishes, we got some quite nice reviews and either major revisions or a revise and resubmit. But one of the reviewer comments pissed me off: they said that we hadn’t demonstrated that our method converges. Now, I was young at the time and new to the field and kinda shocked by all of the shonky numerics that was all over statistics at the time. So this comment34 pissed me off. More than that, though, I was fragile and I hated the comment because I was new to this and had absolutely no fucking idea how to prove this method would converge. Rasmus Waagepetersen had proven convergence of the grid approximation but a) I didn’t understand the proof and b) our situation was so far away there was no chance of piggybacking off it.\nIt was also very hard to use other existing statistics literature, because, far from being an iid situation, the negative log-likelihood for a Poisson process35 on an observation window \\(\\Omega\\) is \\[\n\\Phi(u;y) = \\int_\\Omega e^{u(s)}\\,ds - \\sum_{s_i \\in y}e^{u(s_i)} - |\\Omega|,\n\\] where the point pattern \\(y\\) is a (random) collection of points \\(s_j\\) and \\(|\\Omega|\\) is the area/volume of the observation window. This is fundamentally not like a standard GP regression.\nSo, long story short36, I was very insecure and rather than admit that it was difficult to show that these approximations converged, I worked on and off for like 2 years trying to work out how to do this37 and eventually came up with a fairly full convergence theory for posteriors derived from approximate likelihoods and finite dimensional approximations to Gaussian processes38. Which I then put into the appendix of a paper that was essentially about something completely different.\nI don’t have all that many professional regrets (which is surprising because I’ve made a lot of questionable choices), but I do regret not just making that appendix its own paper. Because it was really good work.\nBut anyway, I took the inverse problems39 work of Andrew Stuart and Masoumeh Dashti and extended it out to meet my needs. And to that end, I’m going to bring out a small corner of that appendix because it tells us what happens to a posterior when we replace a Gaussian process by a finite dimensional approximation."
  },
  {
    "objectID": "posts/2021-11-24-getting-into-the-subspace/getting-into-the-subspace.html#how-do-we-measure-if-a-posterior-approximation-is-good",
    "href": "posts/2021-11-24-getting-into-the-subspace/getting-into-the-subspace.html#how-do-we-measure-if-a-posterior-approximation-is-good",
    "title": "Getting into the subspace; or what happens when you approximate a Gaussian process",
    "section": "How do we measure if a posterior approximation is good?",
    "text": "How do we measure if a posterior approximation is good?\nPart of the struggle when you’re working with Gaussian processes as actual objects rather than as a way to generate a single finite-dimensional Gaussian distribution that you use for analysis is that, to quote Cosma Shalizi40, “the topology of such spaces is somewhat odd, and irritatingly abrupt”. Or to put it less mathematically, it is hard to quantify which Gaussian processes are close together.\nWe actually saw this in the last blog where we noted that the distribution of \\(v = cu\\) has no common support with the distribution of \\(u\\) if \\(|c| \\neq 1\\). This means, for instance, that the total variation between \\(u\\) and \\(v\\) is 2 (which is it’s largest possible value) even if \\(c = 1 + \\epsilon\\) for some tiny \\(\\epsilon\\).\nMore generally, if you’re allowed to choose what you mean by “these distributions are close” you can get a whole range of theoretical results for the posteriors of infinite dimensional parameters, ranging from this will never work and Bayes in bullshit to everything is wonderful and you never have to worry.\nSo this is not a neutral choice.\nIn the absence of a neutral choice, we should try to make a meaningful one! An ok option for that is to try to find functions \\(G(u)\\) that we may be interested in. Classically, we would choose \\(G\\) to be bounded (weak41 convergence / convergence in distribution) or bounded Lipschitz42. This is good but it precludes things like means and variances, which we would quite like to converge!\nThe nice thing about everything being based off a Gaussian process is that we know43 that there is some \\(\\epsilon > 0\\) (which may be very small) such that \\[\n\\mathbb{E}_{\\mu_0}\\left(\\mathrm{e}^{\\epsilon \\|u\\|_B^2}\\right) < \\infty.\n\\] This suggests that as long as the likelihood isn’t too evil, the posterior will also have a whole arseload of moments.\nThis is great because it suggests that we can be more ambitious than just looking at bounded Lipschitz functions. It turns out that we can consider convergence over the class of functionals \\(G\\) such that \\[\n|G(u) - G(v)| \\leq L(u) \\|u - v\\|_B,\n\\] where \\(\\mathbb{E}_{\\mu_0}(L(u)) < \\infty\\). Critically this includes functions like moments of \\(\\|u\\|_B\\) and, assuming all of the functions in \\(B\\) are continuous, moments of \\(u(s)\\). These are the functions we tend to care about!"
  },
  {
    "objectID": "posts/2021-11-24-getting-into-the-subspace/getting-into-the-subspace.html#convergence-of-finite-dimensional-gaussian-processes",
    "href": "posts/2021-11-24-getting-into-the-subspace/getting-into-the-subspace.html#convergence-of-finite-dimensional-gaussian-processes",
    "title": "Getting into the subspace; or what happens when you approximate a Gaussian process",
    "section": "Convergence of finite dimensional Gaussian processes",
    "text": "Convergence of finite dimensional Gaussian processes\nIn order to discuss the convergence of finite dimensional Gaussian processes, we need to define them and, in particular, we need to link them to some Gaussian process on \\(B\\) that they are approximating.\nLet \\(u\\) be a Gaussian process supported on a Banach space \\(B\\). We define a finite dimensional Gaussian process to be a Gaussian process supported on some space \\(V_m \\subset B\\) that satisfies \\[\nu_n = R_m u,\n\\] where \\(R_m: B \\rightarrow V_m\\) is some operator. (For this to be practical we want this to be a family of operators indexed by \\(m\\).)\nIt will turn out that how this restriction is made is important. In particular, we are going to need to see how stable this restriction is. This can be quantified by examining \\[\n\\sup_{\\|f\\|_V = 1} \\|R_m f\\|_{B} \\leq A_m \\|f\\|_V,\n\\] where \\(A_m > 0\\) is a constant that could vary with \\(m\\) and \\(V \\subseteq B\\) is some space we will talk about later. (Confusingly, I have set up the notation so that it’s not necessarily true that \\(V_m \\subset V\\). Don’t hate me because I’m pretty, hate me because I do stupid shit like that.)\n\nExample 1: An orthogonal truncation\nThere is a prototypical example of \\(R_m\\). Every Gaussian process on a separable Banach space admits a Karhunen-Loève representation \\[\nu = \\sum_{k = 0}^\\infty \\lambda_k^{1/2} z_k \\phi_k,\n\\] \\(z_k\\) are iid standard normal random variables and \\((\\lambda_k, \\phi_k)\\) are the eigenpairs44 of the covariance operator \\(C_u\\). The natural restriction operator is then \\[\nR_m f = \\sum_{j=0}^m \\langle f, \\phi_j\\rangle_{L^2}\\phi_j.\n\\] This was the case considered by Dashti and Stuart in their 2011 paper. Although it’s prototypical, we typically do not work with the Karhunen-Loève basis directly, as it tends to commit us to a domain \\(\\Omega\\). (Also because we almost45 never know what the \\(\\phi_j\\) are.)\nBecause this truncation is an orthogonal projection, it follows that we have the stability bound with \\(A_m = 1\\) for all \\(m\\).\n\n\nExample 2: Subset of regressors\nMaybe a more interesting example is the subset of regressors46. In this case, there are a set of inducing points \\(s_1, \\ldots, s_m\\) and \\[\nR_m f = \\sum_{j=1}^m w_j r_u(\\cdot, s_j),\n\\] where the weights solve \\[\nK_m w = b,\n\\] \\([K_m]_{ij} = r_u(s_i, s_j)\\) and \\(b_j = f(s_j)\\).\nIt’s a bit harder to get the stability result in this case. But if we let \\(V_m\\) have the RKHS47 norm, then \\[\\begin{align*}\n\\|R_m f\\|^2_{H_u} &= w^TK_m w \\\\\n&= b^T K^{-1} b \\\\\n&\\leq \\|K^{-1}\\|_2 \\|b\\|_2^2\n\\end{align*}\\]\nAssuming that \\(B\\) contains continuous functions, then \\(\\|b\\|_2 \\leq C\\sqrt{m} \\|f\\|_B\\). I’m pretty lazy so I’m choosing not to give a shit about that \\(\\sqrt{m}\\) but I doubt it’s unimprovable48. To be honest, I haven’t thought deeply about these bounds, I am doing them live, on my couch, after a couple of red wines. If you want a good complexity analysis of subset of regressors, google.\nMore interestingly, \\(\\|K_m^{-1}\\|_2\\) can be bounded, under mild conditions on the locations of the \\(s_j\\) by the \\(m\\)-th largest eigenvalue of the operator \\(Kf = \\int_\\Omega r_u(s,t)f(t)\\,dt\\). This eigenvalue is controlled by how differentiable \\(u\\) is, and is roughly \\(\\mathcal{O}\\left(m^{-\\alpha - d/2}\\right)\\) if \\(u\\) has a version with \\(\\alpha\\)-almost sure (Hölder) derivatives. In the (common) case where \\(u\\) is analytic (eg if you used the squared exponential covariance function), then this bound increases exponentially (or squared exponentially for the squared exponential) in \\(m\\).\nThis means that the stability constant \\(A_m \\geq \\|K_m^{-1}\\|\\) will increase with \\(m\\), sometimes quite alarmingly. Wing argues that it is always at least \\(\\mathcal{O}(m^2)\\). Wathan and Zhu have a good discussion for the one-dimensional case and a lot of references to the more general situation.\n\n\nExample 3: The SPDE method\nMy personal favourite way to approximate Gaussian processes works when they are Markovian. The Markov property, in general, says that if, for every49 set of disjoint open domains \\(S_1\\) and \\(S_2 = \\Omega \\backslash \\bar S_1\\) such that \\(S_1 \\cup \\Gamma \\cup S_2\\), where \\(\\Gamma\\) is the boundary between \\(S_1\\) and \\(S_2\\), then \\[\n\\Pr(A_1 \\cup A_2 \\mid B_\\epsilon) = \\Pr(A_1 \\mid B_\\epsilon) \\Pr(A_2 \\mid B_\\epsilon),\n\\] where \\(A_j \\in \\sigma\\left(\\{u(s), s \\in S_j\\}\\right)\\) and50 \\(B_\\epsilon \\in \\sigma\\left(\\{u(s); d(s, \\Gamma) < \\epsilon\\}\\right)\\) and \\(\\epsilon>0\\).\nWhich is to say that it’s the normal Markov property, but you may need to fatten out the boundary between disjoint domains infinitesimally for it to work.\nIn this case, we51 know that the reproducing kernel Hilbert space has the property that the inner product is local. That means that if \\(f\\) and \\(g\\) are in \\(H_u\\) and have disjoint support52 then \\[\n\\langle f, g\\rangle_{H_u} = 0,\n\\] which, if you squint, implies that the precision operator \\(\\mathcal{Q}\\) is a differential operator. (That the RKHS inner product being local basically defines the Markov property.)\nWe are going to consider a special case53, where \\(u\\) solves the partial differential equation \\[\nL u = W,\n\\] where \\(L\\) is some differential operator and \\(W\\) is white noise54.\nWe make sense of this equation by saying a Gaussian process \\(u\\) solves it if \\[\n\\int_\\Omega \\left(L^*\\phi(s)\\right)\\left( u(s)\\right)\\,ds  \\sim N\\left(0, \\int_\\Omega \\phi^2(s)\\,ds\\right),\n\\] for every smooth function \\(\\phi\\), where \\(L^*\\) is the adjoint of \\(L\\) (we need to do this because, in general, the derivatives of \\(u\\) could be a bit funky).\nIf we are willing to believe this exists (it does—it’s a linear filter of white noise, electrical engineers would die if it didn’t) then \\(u\\) is a Gaussian process with zero mean and covariance operator \\[\n\\mathcal{C} = (L^*L)^{-1},\n\\] where \\(L^*\\) is the adjoint of \\(L\\).\nThis all seems like an awful lot of work, but it’s the basis of one of the more powerful methods for approximating Gaussian processes on low-dimensional spaces (or low-dimensional manifolds). In particular in 1-3 dimensions55 or in (1-3)+1 dimensions56 (as in space-time), Gaussian processes that are built this way can be extremely efficient.\nThis representation was probably first found by Peter Whittle and Finn Lindgren, Johan Lindström and Håvard Rue combined it with the finite element method to produce the SPDE method57 A good review of the work that’s been done can be found here. There’s also a whole literature on linear filters and stochastic processes.\nWe can use this SDPE representation of \\(u\\) to construct a finite-dimensional Gaussian process and a restriction operator \\(R_m\\). To do this, we define \\(L_m\\) as the operator defined implicitly through the equation \\[\n\\langle \\phi, L\\psi\\rangle_{L^2} = \\langle \\phi, L_m\\psi\\rangle_{L^2}, \\quad \\forall \\phi,\\psi \\in V_m.\n\\] This is often called the Galerkin projection58. It is at the heart of the finite element method for solving elliptic partial differential equations.\nWe can use \\(L_m\\) to construct a Gaussian process with covariance function \\[\n\\mathcal{C}_m = (L_m^*L_m)^\\dagger,\n\\] where \\(^\\dagger\\) is a pseudo-inverse59.\nIt follows that \\[\n\\mathcal{C}_m  =(L_m)^\\dagger L L^{-1}(L^*)^{-1}L^*(L_m^*)^\\dagger = R_m \\mathcal{C} R_m^*,\n\\] where \\(R_m = L_m^\\dagger L\\).\nBefore we can get a stability estimate, we definitely need to choose our space \\(V_m\\). In general, the space will depend on the order of the PDE60, so to make things concrete we will work with second-order elliptic61 PDE \\[\nLu = -\\sum_{i,j = 1}^d\\frac{\\partial}{\\partial s_j}\\left(a_{ij}(s) \\frac{\\partial u}{\\partial s_i} \\right) +\\sum_{i=1}^d b_i\\frac{\\partial u}{\\partial s_i} + b_0(s)u(s),\n\\] where all of the \\(a_{ij}(s)\\) and \\(b_j(s)\\) are \\(L^\\infty(\\Omega)\\) and the uniform ellipticity condition62 holds.\nThese operators induce (potentially non-stationary) Gaussian processes that have continuous versions as long as63 \\(d \\leq 3\\).\nWith this fixed, the natural finite element space to use is the space of continuous piecewise linear functions. Traditionally, this is done using combinations of tent functions on a triangular mesh.\n\n\n\nA piecewise linear approximation. Source\n\n\nWith this basis, we can get stability estimates by defining \\(v\\) and \\(v_m\\) by \\(Lv = f\\) and \\(L_m v_m = f_m\\), from which we get \\[\n\\|R_m v\\|_B = \\|v_m\\|_{V_m} \\leq A\\|f\\|_{L_2}\n\\] which holds, in particular, when the \\(L\\) has no first order derivatives64.\nAn oddity about this structure is that functions in \\(V_m\\) are not not continuously differentiable, while the sample paths of \\(u\\) almost surely are65. This means that \\(V_m\\) isn’t necessarily a subset of \\(B\\) as we would naturally define it. In this case, we need to inflate \\(B\\) to be big enough to contain the \\(V_m\\). So instead of taking \\(B = C^1(\\Omega)\\), we need to take \\(B = C(\\Omega)\\) or \\(B = L^2(\\Omega)\\).\nThis has implications on the smoothness assumptions on \\(\\Phi(u;y)\\), which will need to hold uniformly over \\(B\\) and \\(V_m\\) if \\(V_m \\not \\subset B\\) and on the set of functionals \\(G(u)\\) that we use to measure convergence.\n\n\nA bit of perspective\nThe critical difference between the SPDE method and the subset-of-regressors approximation is that for the SPDE method, the stability constant \\(A_m = A\\) is independent of \\(m\\). This will be important, as this constant pops up somewhere important when we are trying to quantify the error in the finite dimensional approximation.\nOn the other hand, the SPDE method only works in three and fewer dimensions and while it allows for quite flexible covariance structures66, it is can only directly construct Gaussian processes with integer numbers of continuous derivatives. Is this a problem? The asymptotics say yes, but they only hold if we are working with the exact Gaussian process (or, I guess, if we let the dimension of \\(V_m\\) hurtle off towards infinity as we get more and more data).\nIn practice, the Gaussian processes constructed via SPDE methods perform very well on real data67. I suspect part of this is that the stable set of basis functions are very good at approximating functions and the misspecification error plays off against the approximation error."
  },
  {
    "objectID": "posts/2021-11-24-getting-into-the-subspace/getting-into-the-subspace.html#bounding-the-approximation-error",
    "href": "posts/2021-11-24-getting-into-the-subspace/getting-into-the-subspace.html#bounding-the-approximation-error",
    "title": "Getting into the subspace; or what happens when you approximate a Gaussian process",
    "section": "Bounding the approximation error",
    "text": "Bounding the approximation error\nWith all of this setup, we are finally ready to bound the error between the posterior we would get with the full Gaussian process prior and the posterior we would get using the finite dimensional Gaussian process prior.\nWe are going to deal with a simpler scenario than the paper we are (sort of) following, because in that situation, I was forced to deal with simultaneously approximating the likelihood and honestly who needs that trouble.\nTo remind ourselves, we have two priors: the full fat Gaussian process prior, the law of which we denote \\(\\mu_0\\) and the one we could possibly work with \\(\\mu_0^m\\). These lead to two different posteriors \\(\\mu_y\\) and \\(\\mu_y^m\\) given by \\[\n\\frac{d\\mu_y}{d\\mu_0}(u) = \\frac{1}{Z}\\mathrm{e}^{-\\Phi(u;y)} \\quad \\text{and}\\quad \\frac{d\\mu_y^m}{d\\mu_0^m}(u) = \\frac{1}{Z_m}\\mathrm{e}^{-\\Phi(u;y)} ,\n\\] where \\(Z_1\\) and \\(Z_m\\) are normalising constants.\nWe assume that the Gaussian process \\(u\\) is supported on some Banach space \\(V \\subseteq B\\) and the approximating spaces \\(V_m \\subset B\\). This covers the case where the approximating functions are rougher than the true realisations of the Gaussian process we are approximating. With this notation, we have the restriction operator \\(R_m\\) that satisfies \\[\n\\|R_mf\\|_{V_m} \\leq A_m \\|f\\|_V,\n\\] which is a slightly more targeted bound when \\(B\\) is larger than \\(V\\).\nWe will make the following assumptions about the negative log-likelihood (or potential function) \\(\\Phi\\): For every \\(\\epsilon > 0\\), \\(r> 0\\), and68 \\(\\|y\\| < r\\), there exist positive constants \\(C_1, C_2, C_3, C_4\\) that may depend on \\(\\epsilon\\) and \\(r\\) such that the following 4 conditions hold. (Note: when the norm isn’t specified, we want it to hold over both the \\(V\\) and \\(B\\) norms.)\n\nFor all \\(u \\in V \\cup \\left(\\bigcup_{m\\geq 1} V_m\\right)\\) \\[\n\\Phi(u;y) \\geq C_1 - \\epsilon \\|u\\|^2\n\\]\nFor every \\(u\\in B\\), \\(y \\in Y\\) with \\(\\max \\{\\|u\\|, \\|y\\|_Y\\} < r\\), \\[\n\\Phi(u;y) \\leq C_2\n\\]\nFor every \\(\\max \\{\\|u_1\\|_V, \\|u_2\\|_B, \\|y\\|_Y\\} < r\\), \\[\n|\\Phi(u_1; y) - \\Phi(u_2; y )| \\leq \\exp\\left(\\epsilon\\max\\{\\|u_1\\|_V^2, \\|u_2\\|_B^2\\} - C_3\\right) \\|u_1 - u_2\\|_B\n\\]\nFor every \\(u\\in B\\) and \\(\\max \\{\\|y_1\\|_Y, \\|y_2\\|_Y\\} < r\\), \\[\n|\\Phi(u; y_1) - \\Phi(u; y_2) | \\leq  \\exp\\left(\\epsilon \\|u\\|^2 + C_4\\right)\\|y_1 - y_2\\|_Y\n\\]\n\nThese restrictions are pretty light and are basically what are needed to make sure the posteriors exist. The first one say “don’t grow too fast” to the likelihood and is best explained while humming ABBA’s Slipping Through My Fingers. The second one makes sure the likelihood isn’t zero. The third and fourth are Lipschitz conditions that basically make sure that a small change in \\(u\\) (or \\(y\\)) doesn’t make a big change in the likelihood. It should be pretty clear that if that could happen, the two posteriors wouldn’t be close.\nWe are also going to need some conditions on our test functions. Once again, we need them to apply over \\(V\\) and \\(B\\) when no space is specified for the norm.\n\nFor all \\(u \\in V\\), \\(G(u) = \\exp(\\epsilon \\|u\\|^2_V+ C_5)\\)\nFor all \\(u_1 \\in V\\), \\(u_2 \\in V_m\\), \\[\n|G(u_1) - G(u_2)| \\leq \\exp(\\epsilon\\max\\{\\|u_1\\|^2_V, \\|u_2\\|^2_B\\})\\|u_1 - u_2\\|_B.\n\\]\n\nUnder these conditions, we get the following theorem, which is a simplified version of Theorem A2 here.\n\nTheorem 1 Under the above assumptions, \\[\n\\left|\\mathbb{E}_{\\mu_y}(G(u)) - \\mathbb{E}_{\\mu^m_y}(G(u_m))\\right| \\leq C_m \\sup_{f \\in V}\\left(\\frac{\\|f - R_m f\\|_B}{\\|f\\|_V}\\right),\n\\] where \\(C_m\\) only depends on \\(m\\) through \\(A_m\\).\n\nI seriously doubt that the dependence on \\(A_m\\) is exponential, as it is in the proof, but I’m not going to try to track that down. That said, I’m also quite sure that the dependence \\(C_m\\) is not uniform in \\(m\\) unless \\(A_m\\) is constant.\nIt’s also worth noting that there’s nothing special about \\(G\\) being real-valued. In general it can take values in any Banach space \\(E\\). Just replace all those absolute values with norms. That means that the result covers convergence of approximations to things like covariance matrices.\n\n\nProof, if you’re interested\n\nWe are interested in approximating \\[\ne_G = \\left|\\mathbb{E}_{\\mu_y}(G(u)) - \\mathbb{E}_{\\mu^m_y}(G(u_m))\\right|.\n\\] We can expand this to get \\[\\begin{align*}\ne_G \\leq & \\frac{1}{Z}\\left|\\mathbb{E}_{\\mu_0}\\left(G(u)\\exp(-\\Phi(u;y))\\right)\n- \\mathbb{E}_{\\mu_0^m}\\left(G(u_m)\\exp(-\\Phi(u_mm;y))\\right)\\right| \\\\\n&\\quad +\n\\left|\\frac{1}{Z}\n- \\frac{1}{Z_m}\\right|\\mathbb{E}_{\\mu_0^m}\\left(|G(u_m)|\\exp(-\\Phi(u_m;y))\\right). \\\\\n&= B_1 + B_2.\n\\end{align*}\\]\nIt follows from Andrew Stuart’s work that the normalising constants \\(Z\\) and \\(Z_m\\) can be bounded above and below independently of \\(m\\), so the above expression makes sense.\nWe will now attack \\(B_1\\) and \\(B_2\\) separately. To do this, we need to consider the joint prior \\(\\lambda_0(u, u_m)\\) that is the joint law of the Gaussian process \\(u\\) and its finite dimensional approximation \\(u_m = R_m u\\).\nFor \\(B_1\\) we basically use the same trick again. \\[\\begin{align*}\nZB_1 \\leq & \\mathbb{E}_{\\lambda_0}\\left(|G(u)|\\left|\\exp(-\\Phi(u;y)) -\\exp(\\Phi(u;y))\\right| \\right) \\\\\n&\\quad + \\mathbb{E}_{\\lambda_0}\\left(\\exp(-\\Phi(u_m;y)) | G(u) - G(u_m)|\\right) \\\\\n&\\leq  \\mathbb{E}_{\\lambda_0}\\left(\\mathrm{e}^{C_5 + \\epsilon \\|u\\|_V^2}\\mathrm{e}^{\\epsilon\\max\\{1,A_m\\}\\|u\\|_v^2 - C_1} \\mathrm{e}^{\\epsilon\\max\\{1,A_m\\}\\|u\\|_V^2 + C_3}\\|u - u_m\\|_B\\right) \\\\\n& \\quad +\\mathbb{E}_{\\lambda_0}\\left(\\mathrm{e}^{\\epsilon A_m\\|u\\|_V^2 - C_1}\\mathrm{e}^{\\epsilon\\max\\{1,A_m\\}\\|u\\|_V^2 + C_6}\\|u - u_m\\|_V\\right) \\\\\n&\\leq \\sup_{f \\in V}\\left(\\frac{\\|f - R_m f\\|_B}{\\|f\\|_V}\\right)\n\\mathrm{e}^{C_3 + C_5 + C_6 -2 C_1}\\mathbb{E}_{\\mu_0}\\left(\\|u\\|_V\\mathrm{e}^{(1+3\\max\\{1,A_m\\} + A_m)\\epsilon \\|u\\|_V^2}\\right)\\\\\n&\\leq C_7 \\sup_{f \\in V}\\left(\\frac{\\|f - R_m f\\|_B}{\\|f\\|_V}\\right),\n\\end{align*}\\] where the second inequality comes from using all of the assumptions on \\(\\Phi\\) and \\(G\\) and noting that \\(\\left|e^{-x} - e^{-y}\\right| \\leq e^{-\\min\\{x,y\\}}|x-y|\\); and the final inequality comes from Fernique’s theorem, which implies that expectation is finite.\nWe can also bound \\(B_2\\) by noting that \\[\\begin{align*}\n\\left|Z^{-1} - Z_m^{-1} \\right| & \\leq \\max \\{Z^{-2}, Z_m^{-2}\\}\\mathbb{E}_{\\lambda_0}\\left(|\\exp(-\\Phi(u;y)) - \\exp(-\\Phi(u_m;z))\\right) \\\\\n&\\leq C_8 \\sup_{f \\in V}\\left(\\frac{\\|f - R_m f\\|_B}{\\|f\\|_V}\\right)\n\\end{align*}\\] by the same reasoning as above."
  },
  {
    "objectID": "posts/2021-11-24-getting-into-the-subspace/getting-into-the-subspace.html#dealing-with-the-approximation-error",
    "href": "posts/2021-11-24-getting-into-the-subspace/getting-into-the-subspace.html#dealing-with-the-approximation-error",
    "title": "Getting into the subspace; or what happens when you approximate a Gaussian process",
    "section": "Dealing with the approximation error",
    "text": "Dealing with the approximation error\nThe theorem above shows that the worst-case error in posterior functionals caused by replacing a Gaussian process \\(u\\) with it’s approximation \\(u_m = R_m u\\) is driven entirely by how well a general function from \\(V\\) can be approximated by a function in \\(V_m\\). This is not really a surprising result: if the approximation \\(u_m\\) is unable to approximate the sample paths of \\(u\\) it is very unlikely it will do a good job with all functionals.\nThankfully, approximation error is one of the better studied things in this world. Especially in the case where \\(V = B\\).\nFor instance, it’s pretty easy to show69 that if \\(u\\) has \\(\\nu\\) derivatives, then \\(e_G \\leq Cm^{-\\frac{\\nu}{d} + \\epsilon}\\) for all \\(\\epsilon>0\\).\nIf you dive deep enough into the literature, you can get similar results for the type of approximation underneath the subset of regressors approximation.\nFor the SPDE approximation, it’s all a little bit more tricky as \\(V_m \\not \\subset V\\). But ultimately, you get that, for any \\(\\epsilon >0\\), \\(e_G \\leq C h^{1-\\epsilon}\\), where \\(h\\) is a measure of the mesh size70. This is roughly what you’d expect, there’s a loss of \\(\\epsilon\\) from the ordinary interpolation rate which may or may not be a result of me being a bit shit at maths.\nThe argument that gets us here is really cute so I’ll sketch it below. This is here for two reasons: firstly, because I think it’s cool and secondly because the paper is so compressed it’s hard to completely follow the argument, so I thought it would be nice to put on here. (It also took me a whole afternoon to decipher the proof in the paper, which is usually a sign that it could do with a bit of a re-write. How successfully I clarified it is something I will leave up to others to decide.)\n\n\nFinite element shit\n\nSetup. Gird yourselves!\nWe are going to bound that error rate in a way that’s relevant for the finite element method. The natural choices for the function spaces are \\(V = H^{1-\\epsilon}(\\Omega)\\) for some fixed \\(0 < \\epsilon < 1/2\\) (close to zero is what we want). and \\(B = L^2(\\Omega)\\). (To be honest the domain \\(\\Omega\\) isn’t changing so I’m gonna forget it sometimes.)\nOnce again, we’re going to assume that \\(L\\) is a second order uniformly elliptic PDE with no first-order terms (aka \\(b_1 = \\cdots = b_d = 0\\)) and that \\(b_0(s) >0\\) on some subset of \\(\\Omega\\). We will use the symmetric, coercive bilinear form associated71 with \\(L\\), which we can define, for any \\(u,v \\in H^1\\), as \\[\na(u, v) = \\int_\\Omega (A(s)\\nabla u(s))\\cdot \\nabla v(s)\\,ds + \\int_\\Omega b_0(s) u(s)v(s)\\,ds\n\\]\nRemembering that \\(R_m = LL_m^\\dagger\\), we have \\[\n\\sup_{v \\in V}\\frac{ \\left\\|v - R_m v\\right\\|_B}{\\|v\\|_V} =\\sup_{f\\in LV}\\frac{ \\left\\|L^{-1}f - L_n^{\\dagger}f\\right\\|_B}{\\|L^{-1}f\\|_V}.\n\\]\nThe set of functions \\(f \\in LV\\) is the set of all functions \\(f = Lv\\) for some \\(v \\in V\\). It can be shown that \\(LV = H^{-1-\\epsilon}\\), where the negative index indicates a dual Sobolev space (aka the space of continuous linear functionals on \\(H^{1+ \\epsilon}\\)).\nThis means that we are looking at the difference between the solution to \\(Lu = f\\) and \\(L_m u_m = f_m\\), where \\(f_m\\) is the \\(L^2\\)-orthogonal projection of \\(f\\) onto \\(V_m\\), which is the space of piecewise linear functions on some72 triangular mesh \\(\\mathcal{T}_m\\).\nWe define the projection of the function \\(f \\in H^{-1-\\epsilon}(\\Omega)\\) onto \\(V_m\\) as the unique function \\(f_m \\in V_m\\) such that73 \\[\n\\int_\\Omega f_n(s) v_n(s)\\,ds = \\int f(s) v_n(s)\\,ds, \\quad \\forall v_n \\in V_n.\n\\]\nNow let’s do this!\nWith all of this in place, we can actually do something. We want to bound \\[\n\\frac{\\|u - u_m\\|_{L^2}}{\\|u\\|_{H^{1+\\epsilon}}},\n\\] where74 \\(a(u, \\phi) = \\int_\\Omega f(s) \\phi(s)\\,ds\\) for all \\(\\phi \\in H^{1+\\epsilon}\\) and \\(a(u_m, \\phi_m) = \\int_\\Omega f(s) \\phi_m(s)\\,ds\\) for all \\(\\phi_m \\in V_m \\subset H^{1+\\epsilon}\\).\nThe key observation is that \\[\n\\int_\\Omega f(s) \\phi_m(s)\\,ds = \\int_\\Omega f_m(s) \\phi_m(s)\\,ds,\n\\] which suggests that \\(u_m(s)\\) is an approximation to two different problems!\nLet’s write this second problem down! We want to find \\(z^{(m)}\\) such that \\[\na({z}^{(m)}, \\phi) = \\int_\\Omega f_n(s) \\phi(s)\\,ds \\quad \\forall \\phi \\in H^{1} ,\n\\] where the \\(m\\) superscript indicates that it depends on \\(m\\) through it’s right hand side. The projection \\(f_n \\in L^2\\), which means that we are in the realm of usual PDEs and (assuming some regularity) \\(z^{(m)} \\in H^2\\).\nHence, we can write \\[\n\\|u - u_m\\|_{L^2}\\leq \\|u - z^{(m)}\\|_{L^2} + \\|z^{(m)} - u_m\\|_{L^2}.\n\\]\nWe can bound the second term almost immediately from standard finite element theory, which says that \\[\n\\|z^{(m)} - u_m\\|_{L^2} \\leq Ch^2 \\|f_n\\|_{L^2}.\n\\]\nTo estimate \\(\\|f_m\\|\\) we use the inverse estimates of Ben Belgacem and Brenner to show that, for any \\(v\\in L^2(\\Omega)\\), \\[\n\\int_\\Omega f_m(s) v(s) \\,ds = \\int_\\Omega f(s)v_m(s)  \\,ds\\leq\\|f\\|_{H^{-1-\\epsilon}}\\|v_m\\|_{H^{1+\\epsilon}} \\leq Ch^{-1-\\epsilon} \\|f\\|_{H^{-1-\\epsilon}} \\|v\\|_{L^2},\n\\] where \\(v_m\\) is the orthogonal projection of \\(v\\) onto \\(V_m\\).\nIf we set \\(v = f_m\\) in the above equation, we get \\(\\|f_m\\|_{L^2} \\leq Ch^{-1-\\epsilon} \\|f\\|_{H^{-1-\\epsilon}}\\), which combines with our previous estimate to give \\[\n\\|z^{(m)} - u_m\\|_{L^2} \\leq Ch^{1-\\epsilon} \\|f_n\\|_{L^2}.\n\\]\nFinally, to bound \\(\\|u - z^{(m)}\\|_{L^2}\\) we are going to use one of my75 favourite arguments. Fix \\(w \\in L^2\\) and let \\(W\\) be the solution of the dual equation \\(a(\\phi, W) = \\int_\\Omega \\phi(s)w(s)\\,ds\\). It then follows that, for any \\(v_m \\in V_m\\), \\[\\begin{align*}\n\\left|\\int_\\Omega (u(s) - z^{(m)}(s))w(s)\\,ds\\right| &= \\left|a(u - z^{(m)}, W)\\right| \\\\\n&= \\left|\\int_\\Omega (f(s) - f_m(s))W(s)\\,ds\\right|\\\\\n&= \\left|\\int_\\Omega (f(s) - f_m(s))(W(s) - v_m(s))\\,ds\\right|\\\\\n&\\leq\\left|\\int_\\Omega f(s)(W(s) - v_m(s))\\,ds\\right|+  \\left|\\int_\\Omega f_m(s)(W(s) - v_m(s))\\,ds\\right| \\\\\n&\\leq \\|f\\|_{H^{-1-\\epsilon}}\\|W - v_m\\|_{H^{1+\\epsilon}} + Ch^{-1-\\epsilon} \\|f\\|_{H^{-1-\\epsilon}} \\|W - v_m\\|_{L^2} \\\\\n&\\leq C \\|f\\|_{H^{-1-\\epsilon}} h^{-1 -\\epsilon}\\left(h^{1+\\epsilon}\\|W - v_m\\|_{H^{1+\\epsilon}} +  \\|W - v_m\\|_{L^2} \\right),\n\\end{align*}\\] where the first line uses the definition of \\(W\\); the second uses the definition of \\(u\\) and \\(z^{(m)}\\); the third uses the fact that \\((f - f_m) \\perp V_m\\) so subtracting off \\(v_m\\) doesn’t change anything; the fourth is the triangle inequality; the fifth is the Hölder inequality on the left and the estimate from half a screen up on the right; and the sixth line is clean up.\nBecause the above bound holds for any \\(v_m \\in V_m\\), we can choose the one that makes the bound the smallest. This leads to \\[\\begin{align*}\n\\left|\\int_\\Omega (u(s) - z^{(m)}(s))w(s)\\,ds\\right| &\\leq  C \\|f\\|_{H^{-1-\\epsilon}} h^{-1 -\\epsilon}\\inf_{v \\in V_m}\\left(h^{1+\\epsilon}\\|W - v_m\\|_{H^{1+\\epsilon}} +  \\|W - v_m\\|_{L^2} \\right) \\\\\n& \\leq C\\|f\\|_{H^{-1-\\epsilon}} h^{-1 -\\epsilon} h^2 \\|W\\|_{H^2}\\\\\n&\\leq C h^{1-\\epsilon} \\|w\\|_{L^2},\n\\end{align*}\\] where the last two inequalities are Theorem 14.4.2 from Brenner and Scott and a standard estimate of the solution to an elliptic PDE by it’s RHS.\nPutting this all together we get the result. Phew.\nThis whole argument was a journey, but I think it’s quite pretty. It’s clobbered together from a lot of sleepless nights and an argument inspired by strip-mining76 a Ridgeway Scott paper from 1976. Anyway, I think it’s nifty."
  },
  {
    "objectID": "posts/2021-11-24-getting-into-the-subspace/getting-into-the-subspace.html#wrapping-it-up",
    "href": "posts/2021-11-24-getting-into-the-subspace/getting-into-the-subspace.html#wrapping-it-up",
    "title": "Getting into the subspace; or what happens when you approximate a Gaussian process",
    "section": "Wrapping it up",
    "text": "Wrapping it up\nSo. That was quite a lot. I enjoyed it, but I’m weird like that. This has mostly been me trying to remember what I did in 2015. Why? Because I felt like it.\nI also think that there’s some value in this way of thinking about Gaussian processes and it’s nice to show off some ways to use all of that weird shit in the last post.\nAll of these words can be boiled down to this take away:\n\nIf your finite dimensional GP \\(u_m\\) is linked to a GP \\(u\\) by some (potentially non-linear relationship) \\(u_m= R_m u\\), then the posterior error will be controlled by how well you can approximate a function \\(v\\) that could be a realisation of the GP by \\(R_m v\\).\n\nThis is a very intuitive result if you are already thinking of GP approximation as approximating a random function. But a lot of the literature takes a view that we are approximating a covariance matrix or a multivariate normal. This might be enough to approximate a maximum likelihood estimator, but it’s insufficient for approximating a posterior77\nFurthermore, because most of the constants in the bounds don’t depend too heavily on the specific finite dimensional approximation (except through \\(A_m\\)), we can roughly say that if we have two methods for approximating a GP, the one that does a better job at approximating functions will be the better choice.\nAs long as it was, this isn’t a complete discussion of the problem. We have not considered hyper-parameters! This is a little bit tricky because if \\(\\mu_0\\) depends on parameters \\(\\theta\\), then \\(R_m\\) will also depend on parameters (and for subset of regressors, \\(V_m\\) also depends on the parameters).\nIn theory, we could use this to bound the error in the posterior \\(p(\\theta \\mid y)\\). To see how we would do that, let’s consider the case where we have Gaussian observations.\nThen we get \\[\\begin{align*}\np(\\theta \\mid y) & \\frac{\\exp(-\\Phi(u;y))}{p(y)} \\left[\\frac{d\\mu_y}{d\\mu_0}\\right]^{-1} p(\\theta) \\\\\n&= \\frac{Z(\\theta) p(\\theta)}{\\int_\\Theta Z(\\theta)p(\\theta)\\,d\\theta},\n\\end{align*}\\] where \\(Z(\\theta) = \\mathbb{E}_{\\mu_0}\\left(e^{-\\Phi(u;y)}\\right)\\).\nWe could undoubtedly bound the error in this using similar techniques to the ones we’ve already covered (in fact, we’ve already got a bound on \\(|Z - Z_m|\\)). And then it would just be a matter of piecing it all together.\nBut I’m tired and I just want to cry for me."
  },
  {
    "objectID": "posts/2021-10-15-priors3/priors3.html",
    "href": "posts/2021-10-15-priors3/priors3.html",
    "title": "Priors: Fire With Fire (Track 3)",
    "section": "",
    "text": "It is Friday night, I am in lockdown, and I have had a few drinks. So let’s talk about objective priors.\nThe first and most obvious thing is that they are not fucking objective. It is bad/unethical marketing from the 90s that has stuck. I dislike it. I think it’s unethical (and, personally, immoral) to proclaim a statistical method objective in any context, let alone one in which all you did was compute some derivatives and maybe sent something that isn’t going to fucking infinity to infinity. It’s fucking trash and I hate it.\nBut let’s talk about some objective priors."
  },
  {
    "objectID": "posts/2021-10-15-priors3/priors3.html#ok-lets-try-again.",
    "href": "posts/2021-10-15-priors3/priors3.html#ok-lets-try-again.",
    "title": "Priors: Fire With Fire (Track 3)",
    "section": "Ok let’s try again.",
    "text": "Ok let’s try again.\nNo I do not think I will.\nI am willing to talk about finite dimensional priors that add minimal information or are otherwise related to MLEs.\nLater, I guess because I’m mathematically interested in it, I’ll talk about the infinite dimensional case. But not today. Because I’m pissed off.\nAnyway.\n\nWhat is an objective prior\nHonestly, still a pretty vague and stupid concept. It is difficult to define for interesting (aka not univariate) cases, but maybe the most practical definition is priors that come from rules.\nBut that’s not a … great definition. Many priors that I will talk about over the next little while could probably be shoved under the objective banner. But in this post I’m going to talk about the OG concept of an objective prior: the type of priors that try to add minimal information beyond the data.\nNominally, the aim of these priors is to let the data speak for itself. And I’ve been doing this a while, and no matter how long I’ve listened to my .csv file, it has never said a word. But if it weren’t for silly justifications, we wouldn’t have silly concepts.\nThere are, essentially, three main types of priors that fall into this traditionally objective category:\n\nJeffreys priors\nReference priors\nMatching priors\n\nJefferys priors argue, for a bunch of very sensible and solid geometrical reasons, that the value of the parameter \\(\\theta\\) is less important than the way that moving from \\(\\theta\\) to \\(\\theta + d\\theta\\) will change the likelihood \\(p(y \\mid \\theta)\\). This push back against the Arianist notion that the prior can be separated from its context is welcome!\nThe actual prior itself comes from, I guess, the idea that the prior should be invariant to reparameterisations and after some maths you get \\[\np(\\theta ) \\propto |I(\\theta)|^{1/2},\n\\] where \\(|I(\\theta)|\\) is the determinant of the Fisher1 information matrix \\[\nI(\\theta)_{ij} = \\frac{\\partial^2}{\\partial \\theta_i \\theta_j} \\log p(y \\mid \\theta).\n\\]\nThis immediately turns out to be a terrible idea for general models. When \\(\\theta\\) has more than one component, the Jeffreys prior tends to concentrate in silly places in the parameter space.\nBut when \\(\\theta\\) is one dimensional, it works fine. In fact, if you use it you will get the sampling distribution Maximum Likelihood estimator (or withing \\(\\mathcal{O}_p(n^{-1})\\) of it). So there’s very little purpose pursing this line of reasoning.\nThere’s actually a bit of a theme that develops here: for models with a single parameter a lot of things work perfectly. Sadly the intersection of one-dimensional statistical models that are regular enough for all this maths to work and interesting statistical problems is not exactly hefty.\nReference priors are an attempt to extend Jeffreys priors to multiple parameters while avoiding some of the more egregious problems of multivariate Jeffreys priors. They were also the topic of the most boring talk I have ever seen at a conference2. It was 45 minutes going through all of the different reference priors you can make for inferring a bivariate normal (you see, to construct a reference prior you need to order your parameters and this ordering matters). If I didn’t already think that reference priors were an impractical waste of time, that certainly convinced me. A lot of people seem to mention reference priors, but it is rarer to see them in use.\nMatching priors try to spin off Jeffreys priors in a different direction. They are a mathematically very interesting idea asking if there is a prior that will produce a posterior uncertainty interval that is exactly the same as (or very close to) the sampling distribution of the MLE. It turns out that for one parameter models you can totally do this (the Jeffreys prior does it! And you can get even closer). But when there are nuisance parameters (aka parameters that aren’t of direct inferential interest but are important to modelling the data), the resulting prior tends to be data-dependent. A really nice example of the literature is Reid, Mukerjee, and Fraser’s 2003 paper. To some extent the matching priors literature is asking “should we even Bayes?”, which is not the worst question to ask3.\nThese three ideas have a number of weird bastard children. Most of these are not recommended by anyone, but used prominently. These are the vague priors. The \\(N(0,100^2)\\) priors. The \\(\\text{Inverse-Gamma}(\\epsilon, \\epsilon)\\) priors. The Uniform over large interval priors. The misinformed concept behind these priors is that wider prior = less information. This is, of course, bullshit. As many4 many5 many6 examples show.\nThe one big thing that I haven’t mentioned so far is that most of the time the priors produced using these methods are not proper, which is to say that you can’t integrate them. That isn’t a big deal mathematically as long as \\(\\int_\\Theta p(y \\mid \\theta)p(\\theta)\\,d\\theta\\) is finite for all7 data sets \\(y\\). This is a fairly difficult thing to check for most models and if you want to really upset a grad student at a Bayesian conference spend some time staring at their poster and then grimace and ask “are you sure that posterior is proper?”8 The frequent impropriety of these classes of means you can’t simulate from them, can’t really consider them a representation of prior information, and can’t easily transfer them from one problem to another without at least a little bit of fear that the whole house of cards is gonna come tumbling down.\n\n\nWho uses objective priors\nFrequentists. People who are obsessed with statistical bias of their estimators (the Venn diagram here isn’t a circle, but it’s also not the poster child for diversity of thought or modernity). People who read boring textbooks. People who write boring textbook. People who believe that it’s the choice of prior and somehow not the choice of the likelihood or, you know, their choice of data that will somehow lead to incorrect inferences9. People who tell you, without being asked10, that they went to Duke.\n\n\nShould I use objective priors\nIf you’ve more parameters than a clumsy butcher has fingers on their non-dominant hand, you probably shouldn’t use objective priors. In these cases, you almost always need to inject some form of regularisation, prior information, or just plain hope into your model to make it behave sensibly11.\nBut if you have less, I mean, live your life I guess. But why go to the effort. Just compute a maximum likelihood if you’re looking for something that is very very similar to a maximum likelihood estimate. It’s faster, it’s cleaner, and it’s not pretending to be something it isn’t.\nI actually think you can usually make stronger, more explicitly justified choices using other things we can talk about later. But I’m not the boss of statistics so you don’t have to listen to me."
  },
  {
    "objectID": "posts/2022-01-26-barry-gibb-came-fourth-in-a-barry-gibb-look-alike-contest-repost/barry-gibb-came-fourth-in-a-barry-gibb-look-alike-contest-repost.html",
    "href": "posts/2022-01-26-barry-gibb-came-fourth-in-a-barry-gibb-look-alike-contest-repost/barry-gibb-came-fourth-in-a-barry-gibb-look-alike-contest-repost.html",
    "title": "Barry Gibb came fourth in a Barry Gibb look alike contest (Repost)",
    "section": "",
    "text": "Every day a little death, in the parlour, in the bed. On the lips and in the eyes. In the curtains in the silver, in the buttons, in the bread, in the murmurs, in the pauses, in the gestures, in the sighs. Sondheim\nThe most horrible sound in the world is that of a reviewer asking you to compare your computational method to another, existing method. Like bombing countries in the name of peace, the purity of intent drowns out the voices of our better angels as they whisper: at what cost.\nBefore the unnecessary drama of that last sentence1 sends you running back to the still-open browser tab documenting the world’s slow slide into a deeper, danker, more complete darkness that we’ve seen before, I should say that I understand that for most people this isn’t a problem. Most people don’t do research in computational statistics. Most people are happy2.\nSo why does someone asking for a comparison of two methods for allegedly computing the same thing fill me with the sort of dread usually reserved for climbing down the ladder into my basement to discover, by the the light of a single, swinging, naked light bulb, that the evil clown I keep chained in the corner has escaped? Because it’s almost impossible to do well."
  },
  {
    "objectID": "posts/2022-01-26-barry-gibb-came-fourth-in-a-barry-gibb-look-alike-contest-repost/barry-gibb-came-fourth-in-a-barry-gibb-look-alike-contest-repost.html#option-1-we-want-to-fill-in-our-sparse-observation-by-predicting-at-more-and-more-points",
    "href": "posts/2022-01-26-barry-gibb-came-fourth-in-a-barry-gibb-look-alike-contest-repost/barry-gibb-came-fourth-in-a-barry-gibb-look-alike-contest-repost.html#option-1-we-want-to-fill-in-our-sparse-observation-by-predicting-at-more-and-more-points",
    "title": "Barry Gibb came fourth in a Barry Gibb look alike contest (Repost)",
    "section": "Option 1: We want to fill in our sparse observation by predicting at more and more points",
    "text": "Option 1: We want to fill in our sparse observation by predicting at more and more points\n(This is known as “in-fill asymptotics”). This type of question occurs when, for instance, we want to fill in the holes in satellite data (which are usually due to clouds).\nThis is the case that most closely resembles the design of the simulation study in this paper. In this case you refine your estimated coverage by computing more prediction intervals and checking if the true value lies within the interval.\nMost of the easy to find results about coverage in these is from the 1D literature (specifically around smoothing splines and non-parametric regression). In these cases, it’s known that the first option is bad, the second option will lead to conservative regions (the coverage will be too high), the third option involves some sophisticated understanding of how Gaussian random fields work, and the fourth is not something I know anything about."
  },
  {
    "objectID": "posts/2022-01-26-barry-gibb-came-fourth-in-a-barry-gibb-look-alike-contest-repost/barry-gibb-came-fourth-in-a-barry-gibb-look-alike-contest-repost.html#option-2-we-want-to-predict-at-one-point-where-the-field-will-be-monitored-multiple-times",
    "href": "posts/2022-01-26-barry-gibb-came-fourth-in-a-barry-gibb-look-alike-contest-repost/barry-gibb-came-fourth-in-a-barry-gibb-look-alike-contest-repost.html#option-2-we-want-to-predict-at-one-point-where-the-field-will-be-monitored-multiple-times",
    "title": "Barry Gibb came fourth in a Barry Gibb look alike contest (Repost)",
    "section": "Option 2: We want to predict at one point, where the field will be monitored multiple times",
    "text": "Option 2: We want to predict at one point, where the field will be monitored multiple times\nThis second option comes up when we’re looking at a long-term monitoring network. This type data is common in environmental science, where a long term network of sensors is set up to monitor, for example, air pollution. The new observations are not independent of the previous ones (there’s usually some sort of temporal structure), but independence can often be assumed if the observations are distant enough in time.\nIn this case as you are repeating observations at a single site, Option 1 will be the right way to construct your interval, option 2 will probably still be a bit broad but might be ok, and options 3 and 4 will probably be too narrow if the underlying process is smooth."
  },
  {
    "objectID": "posts/2022-01-26-barry-gibb-came-fourth-in-a-barry-gibb-look-alike-contest-repost/barry-gibb-came-fourth-in-a-barry-gibb-look-alike-contest-repost.html#option-3-mixed-asymptotics-you-do-both-at-once",
    "href": "posts/2022-01-26-barry-gibb-came-fourth-in-a-barry-gibb-look-alike-contest-repost/barry-gibb-came-fourth-in-a-barry-gibb-look-alike-contest-repost.html#option-3-mixed-asymptotics-you-do-both-at-once",
    "title": "Barry Gibb came fourth in a Barry Gibb look alike contest (Repost)",
    "section": "Option 3: Mixed asymptotics! You do both at once",
    "text": "Option 3: Mixed asymptotics! You do both at once\nSimulation studies are the last refuge of the damned."
  },
  {
    "objectID": "posts/2022-08-29-priors4/priors4.html",
    "href": "posts/2022-08-29-priors4/priors4.html",
    "title": "Priors part 4: Specifying priors that appropriately penalise complexity",
    "section": "",
    "text": "At some point in the distant past, I wrote three posts about prior distributions. The first was very basic, because why not. The second one talked about conjugate priors. The third one talked about so-called objective priors.\nI am suddenly1 of a mood to write some more on this2 topic.\nThe thing is, so far I’ve only really talked about methods for setting prior distributions that I don’t particularly care for. Fuck that. Let’s talk about things I like. There is enough negative energy3 in the world.\nSo let’s talk about priors. But the good stuff. The aim is to give my answer to the question “how should you set a prior distribution?”."
  },
  {
    "objectID": "posts/2022-08-29-priors4/priors4.html#bro-do-you-even-know-what-a-parameter-is",
    "href": "posts/2022-08-29-priors4/priors4.html#bro-do-you-even-know-what-a-parameter-is",
    "title": "Priors part 4: Specifying priors that appropriately penalise complexity",
    "section": "Bro do you even know what a parameter is?",
    "text": "Bro do you even know what a parameter is?\nYou don’t. No one does. They’re not real.\nParameters are polite fictions that we use to get through the day. They’re our weapons of mass destruction. They’re the magazines we only bought for the articles. They are our girlfriends who live in Canada4.\nOne way we can see this is to ask ourselves a simple5: \\[\ny_i \\sim \\text{Negative-Binomial}(\\mu, \\alpha), \\qquad i = 1,\\ldots, n\\text{?}\n\\]\nThe answer6 7 would be two.\nBut let me ask a different question. How many parameters are there in this model8 \\[\\begin{align*}\ny_i\\mid u_i &\\sim \\text{Poisson}(\\mu u_i) \\\\\nu_i &\\sim \\text{Gamma}(\\alpha^{-1}, \\alpha^{-1}),\\qquad i=1,\\ldots, n\\text{?}\n\\end{align*}\\]\nOne answer to this question would be \\(n+2\\). In this interpretation of the question everything in the model that isn’t directly observed is a parameter.\nBut there is another view.\nMathematically, these two models are equivalent. That is, if you marginalise9 out the \\(u_i\\) you get \\[\\begin{align*}\n\\Pr(y=k) &=\\frac{\\mu^k\\alpha^{-1/\\alpha}}{\\Gamma(\\alpha^{-1})\\Gamma(k+1)} \\int_0^\\infty u^k e^{-\\mu u} u^{1/\\alpha-1}e^{-u/\\alpha}\\,du \\\\\n&= \\frac{\\mu^k\\alpha^{-1/\\alpha}}{\\Gamma(\\alpha^{-1})\\Gamma(k+1)}\\int_0^\\infty u^{k + 1/\\alpha-1}e^{-(\\mu + \\alpha^{-1})u}\\,du \\\\\n&= \\frac{\\mu^k\\alpha^{-1/\\alpha}}{\\Gamma(\\alpha^{-1})\\Gamma(k+1)}\\int_0^\\infty \\left(\\frac{t}{\\mu+\\alpha^{-1}}\\right)^{k + 1/\\alpha-1}e^{-t}\\frac{1}{\\mu + \\alpha^{-1}}\\,dt \\\\\n&=\\frac{\\Gamma(k + \\alpha^{-1})}{\\Gamma(\\alpha^{-1})\\Gamma(k+1)} \\left(\\frac{\\mu}{\\mu + \\alpha^{-1}}\\right)^k \\left(\\frac{\\alpha^{-1}}{\\mu + \\alpha^{-1}}\\right)^{1/\\alpha} .\n\\end{align*}\\] This is exactly the negative binomial distribution with mean \\(\\mu\\) and variance \\(\\mu(1 + \\alpha \\mu)\\).\nSo maybe there are two parameters.\nDoes it make a difference? Sometimes. For instance, if you were following ordinary practice in Bayesian machine learning, you would (approximately) marginalise out \\((\\mu, \\lambda)\\) in the first model, but in the second model you’d probably treat them as tuning hyper-parameters10 in the second and optimise11 over them.\nMoreover, in the second model we can ask what other priors could we put on the \\(u_i\\)?. There is no equivalent question for the first model. This could be useful, for instance, if we believe that the overdispersion may differ among population groups. It is considerably easier to extend the random effects formulation into a multilevel model.\nOk. So it doesn’t really matter too much. It really depends on what you’re going to do with the model when you’re breaking your model into things that we need to set priors for and things where the priors are a structural part of the model."
  },
  {
    "objectID": "posts/2022-08-29-priors4/priors4.html#a-hello-boys-into-a-party-date-on-flexibility",
    "href": "posts/2022-08-29-priors4/priors4.html#a-hello-boys-into-a-party-date-on-flexibility",
    "title": "Priors part 4: Specifying priors that appropriately penalise complexity",
    "section": "A hello boys into a party date: on flexibility",
    "text": "A hello boys into a party date: on flexibility\nThere are a lot of ways to set prior distributions. I’ve covered some in previous posts and there are certainly more. But today I’m going to focus on one constructive method that I’m particular fond of: penalised complexity priors.\nThese priors fall out from a certain way of seeing parameters. The idea is that some parameters in a model function as flexibility parameters. These naturally have a base value, which corresponds to the simplest model that they index. I’ll refer to the distribution you get when the parameter takes its base value as the base model.\n\nExample 1 (Overdispersion of a negative binomial) The negative binomial distribution has two parameters: a mean \\(\\mu\\) and an overdispersion parameter \\(\\alpha\\) so the variance is \\(\\mu(1 + \\alpha \\mu)\\). The mean parameter is not a flexibility parameter. Conceptually, changing the mean12 does not make a distribution more or less complex, it simply shuttles it around.\nOn the other hand, the overdispersion parameter \\(\\alpha\\) is a flexibility parameter. It’s special value is \\(\\alpha =0\\), which corresponds to a Poisson distribution, which is the base model for the negative binomial distribution.\n\n\nExample 2 (Student-t degrees of freedom) The three parameter student-t distribution has density (parameterised by its standard deviation assuming \\(\\nu > 2\\)!) \\[\np(y \\mid \\mu, \\sigma, \\nu) = \\frac{\\Gamma\\left(\\frac{\\nu + 1}{2}\\right)}{\\sigma\\nu \\sqrt{\\frac{\\pi}{\\nu-2}} \\Gamma\\left(\\frac{\\nu}{2}\\right)}\\left(1 + \\frac{\\frac{\\nu-2}{\\nu}\\left(\\frac{y - \\mu}{\\sigma}\\right)^2}{\\nu}\\right)^{-\\frac{\\nu+1}{2}}, \\qquad \\nu > 2.\n\\] This has mean \\(\\mu\\) and variance \\(\\sigma^2\\). The slightly strange parameterisation and the restriction to \\(\\nu>0\\) is useful because it lets us specify a prior on the variance itself and not some parameter that is the variance divided by some function13 of \\(\\nu\\).\nThe natural base model here is \\(N(\\mu, \\sigma^2)\\), which corresponds to \\(\\nu = \\infty\\).\n\n\nExample 3 (Variance of a Gaussian random effect) A Gaussian distribution has two parameters: a mean \\(\\mu\\) and a standard deviation \\(\\tau\\). Once again, \\(\\mu\\) is not a flexibility parameter, but in some circumstances \\(\\tau\\) can be.\nTo see this, imagine that we have a simple random intercept model \\[\\begin{align*}\ny_{ij} \\mid u_j &\\sim N(u_j, \\sigma^2),\\qquad i=1,\\ldots,n, j =1,\\ldots,J \\\\\nu_j &\\sim N(\\mu, \\tau).\n\\end{align*}\\] In this case, we don’t really view \\(\\sigma\\) as a flexibility parameter, but \\(\\tau\\) is. Why the distinction? Well let’s think about what happens at special value \\(0\\).\nWhen \\(\\sigma = 0\\) we are saying that there is no variability in the data if we know the corresponding \\(u_i\\). This is, frankly, quite weird and it’s not necessarily a base model we would believe14 in.\nOn the other hand, if \\(\\tau =0\\), then we are say that all of the groups have the same mean. This is a useful and interesting base model that could absolutely happen in most data. So we say that while \\(\\sigma\\) isn’t necessarily a flexibility parameter in the model, \\(\\tau\\) definitely is.\nIn this case the base model is the degenerate distribution15 where the mean of each group is equal to \\(\\mu\\).\n\nThe second example shows that the idea of a flexibility parameter is deeply contextual. Once again, we run into the idea that Statistical Arianism16 is bad. Parameters and their prior distributions can only be fully understood if you know their context within the entire model."
  },
  {
    "objectID": "posts/2022-08-29-priors4/priors4.html#sure-youre-flexible-but-lets-not-over-do-the-dutch-wink",
    "href": "posts/2022-08-29-priors4/priors4.html#sure-youre-flexible-but-lets-not-over-do-the-dutch-wink",
    "title": "Priors part 4: Specifying priors that appropriately penalise complexity",
    "section": "Sure you’re flexible, but let’s not over-do the Dutch wink",
    "text": "Sure you’re flexible, but let’s not over-do the Dutch wink\nNow that we have the concept of a flexibility parameter, let’s think about how we should use it. In particular, we should ask exactly what we want our prior to do. In the paper we listed 8 things that we want the prior to do:\n\nThe prior should contain information17 18 19\nThe prior should be aware of model structure\nIf we move our model to a new application, it should be clear how we can change the information contained in our prior. We can do this by explicitly including specific information in the prior.\nThe prior should limit20 the flexibility of an overparameterised model\nRestrictions of the prior to identifiable sub-manifolds21 of the parameter space should be sensible.\nThe prior should be specified to control what a parameter does in the context22 of the model (rather than its numerical value)\nThe prior should be computationally23 feasible\nThe prior should perform well24.\n\nThese desiderata are aspirational and I in no way claim that we successfully satisfied them. But we tried. And we came up with a pretty useful proposal.\nThe idea is simple: if our model has a flexibility parameter we should put a prior on it that penalises the complexity of the model. That is, we want most of the prior mass to be near25 the base value.\nIn practice, we try to do this by penalising the complexity of each component of a model. For instance, consider the following model for a flexible regression: \\[\\begin{align*}\ny_i \\mid f, u_i &\\sim N(u_i +f(z_i), \\sigma^2) \\\\\nf &\\sim \\text{Smoothing-spline}(\\lambda)\\\\\nu_i &\\sim N( \\mu + x_i^T\\beta , \\tau^2).\n\\end{align*}\\] The exact definition26 of a smoothing spline that we are using is not wildly important, but it is specified27 by a smoothing parameter \\(\\lambda\\), and when \\(\\lambda=\\infty\\) we get our base model (a function that is equal to zero everywhere). This model has two components (\\(f\\) and \\(u\\)) and they each have one smoothing parameter (\\(\\lambda\\), with base model at \\(\\lambda = \\infty\\), and \\(\\tau\\), with base model at \\(\\tau = 0\\)).\nThe nice thing about splitting a model up into components and building priors for each component is that we can build generic priors for each component that can be potentially be tuned to make them appropriate for the global model. Is this a perfect way to realise our second aim? No. But it’s an ok place to start28."
  },
  {
    "objectID": "posts/2022-08-29-priors4/priors4.html#the-speed-of-a-battered-sav-proximity-to-the-base-model",
    "href": "posts/2022-08-29-priors4/priors4.html#the-speed-of-a-battered-sav-proximity-to-the-base-model",
    "title": "Priors part 4: Specifying priors that appropriately penalise complexity",
    "section": "The speed of a battered sav: proximity to the base model",
    "text": "The speed of a battered sav: proximity to the base model\nOk. So you’re Brad Pitt. Wait. No.\nOk. So we need to build a prior that penalises complexity by putting most of its prior mass near the base model. In order to do this we need to first specify what we mean by near.\nThere are a lot of things that we could mean. The easiest choice would be to just use the natural distance from the base model in the parameter space. But this isn’t necessarily a good idea. Firstly, it falls flat when the base model is at infinity. But more importantly, it violates our 6th aim by ignoring the context of the parameter and just setting a prior on its numerical value.\nSo instead we are going to parameterise distance by asking ourselves a simple question: for a component with flexibility parameter \\(\\xi\\), how much more complex would our model component be if we used the value \\(\\xi\\) instead of the base value \\(\\xi_\\text{base}\\)?\nWe can measure this complexity using the Kullback-Leibler divergence (or KL divergence if you’re nasty) \\[\n\\operatorname{KL}(f || g) = \\int_\\Theta f(t) \\log\\left(\\frac{f(t)}{g(t)}\\right)\\,dt.\n\\] This is a quantity from information theory that directly measures how much information would be lost29 if we replaced the more complex model \\(f\\) with the simpler model \\(g\\). The more information that would be lost, the more complex \\(f\\) is relative to \\(g\\).\nWhile the Kullback-Leibler divergence looks a bit intimidating the first time you see it, it’s got a lot of nice properties:\n\nIt’s always non-negative.\nIt doesn’t depend on how you parameterise the distribution. If you do a smooth, invertible change of variables to both distribution the KL divergence remains unchanged.\nIt’s related to the information matrix and the Fisher distance. In particular, let \\(f(\\theta \\mid \\xi)\\) be a family of distributions parameterised by \\(\\xi\\). Then, near \\(\\xi_0\\), \\[\n\\operatorname{KL}(f(\\cdot \\mid \\xi_0 +\\delta)  || f(\\cdot \\mid \\xi_0)) = \\frac{\\delta^2}{2} I(\\xi_0) + o(\\delta^2),\n\\] where \\(I(\\xi) = \\mathbb{E}(\\log p(f(y \\mid \\xi))^2)\\) is the Fisher information. The quantity on the right hand side is the square of a distance from the base model.\nIt can be related to the total variation distance30 \\[\n\\|f - g\\|_\\text{TV} \\leq \\sqrt{\\frac{1}{2} \\operatorname{KL}(f || g)}.\n\\]\n\nBut it also has some less charming properties:\n\nThe KL divergence is not a distance!\nThe KL divergence is not symmetric, that is \\(\\operatorname{KL}(f || g) \\neq \\operatorname{KL}(g || f)\\)\n\nThe first of these properties is irrelevant to us. The second interesting. I’d argue that it is an advantage. We can think in an analogy: if your base model is a point at the bottom of a valley, there is a big practical difference between how much effort it takes to get from the base model to another model that is on top of a hill compared to the amount of effort it takes to go in the other direction. This type of asymmetry is relevant to us: it’s easier for data to tell a simple model that it should be more complex than it is to tell a complex model to be simpler. We want our prior information to somewhat even this out, so we put less prior mass on models that are more complex and more on models that are more complex.\nThere is one more little annoyance: if you look at the two distance measures that the KL divergence is related to, you’ll notice that in both cases, the KL divergence is related to the square of the distance and not the distance itself.\nIf we use the KL divergence itself as a distance proxy, it will increase too sharply31 and we may end up over-penalising. To that end, we use the following “distance” measure \\[\nd(\\xi) = \\sqrt{2 \\operatorname{KL}(f(\\cdot \\mid \\xi) || f(\\cdot \\mid \\xi_0))}.\n\\] If you’re wondering about that 2, it doesn’t really matter but it makes a couple of things ever so slightly cleaner down the road.\nOk. Let’s compute some of these distances!\n\nExample 4 (Overdispersion of a negative binomial (continued)) The negative binomial distribution is discrete so \\[\\begin{multline}\n\\frac{1}{2}d^2(\\alpha) = \\sum_{k=1}^\\infty \\frac{\\Gamma(k + \\alpha^{-1})}{\\Gamma(\\alpha^{-1})\\Gamma(k+1)}  \\left(\\frac{\\mu}{\\mu + \\alpha^{-1}}\\right)^k \\left(\\frac{\\alpha^{-1}}{\\mu + \\alpha^{-1}}\\right)^{1/\\alpha} \\\\\n\\times \\left[\\log \\Gamma(k  +\\alpha^{-1}) - \\log \\Gamma(\\alpha^{-1})  - k \\log(\\mu + \\alpha^{-1}) + \\alpha^{-1}\\log \\alpha^{-1} - \\alpha^{-1}\\log(\\mu + \\alpha^{-1})  + \\mu \\right].\n\\end{multline}\\] This has two problems: I can’t work out what it is and it might32 end up depending on \\(\\mu\\).\nThankfully we can use our alternative representation of the negative binomial to note that \\(u_i \\sim \\text{Gamma}(\\alpha^{-1}, \\alpha^{-1})\\) and so we could just as well consider \\(u_i\\) the model component that we want to penalise the complexity of. In this case we need the KL divergence33 between Gamma distributions \\[\\begin{multline}\n\\operatorname{KL}(\\text{Gamma}(a^{-1},a^{-1}) || \\text{Gamma}(b^{-1},b^{-1})) = (a^{-1}-b^{-1}) \\psi(a^{-1}) - \\log\\Gamma(a^{-1}) + \\log\\Gamma(b^{-1}) \\\\\n+ b^{-1}(\\log a^{-1} - \\log b^{-1}) + b^{-1}-a^{-1},\n\\end{multline}\\] where \\(\\psi(a)\\) is the digamma function.\nAs \\(b\\rightarrow 0\\), the KL divergence becomes34 \\[\\begin{align*}\n&b^{-1}  (\\log(a^{-1}) - \\psi(a^{-1})) + \\log\\Gamma(b^{-1}) - b^{-1}\\log b^{-1} + b^{-1}  + o(b^{-1})\\\\\n=& b^{-1} (\\log(a^{-1}) - \\psi(a^{-1})) + b^{-1} \\log b^{-1} - b^{-1} - b^{-1}\\log b^{-1} + b^{-1} \\\\\n= &b^{-1}  (\\log(a^{-1}) - \\psi(a^{-1})) + o(b^{-1}).\n\\end{align*}\\]\nNow, you will notice that as \\(b\\rightarrow 0\\) the KL divergence heads off to infinity. This happens a lot when the base model is much simpler than the flexible model. Thankfully, we will see later that we can ignore the factor of \\(b^{-1}\\) and get a PC prior that’s valid against the base model \\(\\text{Gamma}(b^{-1}, b^{-1})\\) for all sufficiently small \\(b>0\\). This is not legally the same thing as having one for \\(b=0\\), but it is morally the same.\nWith this, we get \\[\nd(\\alpha) = \\sqrt{2\\log(\\alpha^{-1}) - 2\\psi(\\alpha^{-1}) }.\n\\]\nIf the digamma function is a bit too hardcore for you, the approximation \\[\n\\psi(\\alpha^{-1}) = \\log(\\alpha^{-1}) - \\frac{\\alpha}{2} + \\mathcal{O}(\\alpha^2)\n\\] gives the approximate distance \\[\nd(\\alpha) \\approx \\sqrt{\\alpha}.\n\\] That is, the distance we are using is approximately the standard deviation of \\(u_i\\).\nLet’s see if this approximation35 is any good.\n\nlibrary(tidyverse)\ntibble(alpha = seq(0.01, 20, length.out = 1000),\n       exact = sqrt(2*log(1/alpha) - 2*digamma(1/alpha)),\n       approx = sqrt(alpha)\n       ) |>\n  ggplot(aes(x = alpha, y = exact)) + \n  geom_line(colour = \"red\") +\n  geom_line(aes(y = approx), colour = \"blue\", linetype = \"dashed\") +\n  theme_bw()\n\n\n\n\nIt’s ok but it’s not perfect.\n\n\nExample 5 (Student-t degrees of freedom (Continued)) In our original paper, we computed the distance for the degrees of freedom numerically. However, Yongqiang Tang derived an analytic expression for it. \\[\nd(\\nu) = \\sqrt{1 + \\log \\left(\\frac{2}{\\nu-2}\\right) + 2 \\log\\left(\\frac{\\Gamma((\\nu+1)/2)}{\\Gamma(\\nu/2)}\\right) - (\\nu + 1)(\\psi((\\nu+1)/2) - \\psi(\\nu/2))}.\n\\]\nIf we note that \\[\n\\log(\\Gamma(z)) = \\left(z- \\frac{1}{2}\\right)\\log z - z + \\frac{1}{2}\\log(2\\pi)  + \\frac{1}{12z} + \\mathcal{O}(z^{-1}),\n\\] we can use this (and the above asymptotic expansion of the digamma function) to get We can use the same asymptotic approximations as above to get \\[\\begin{align*}\nd(\\nu)^2 \\approx& {} 1 + \\log \\left(\\frac{2}{\\nu-2}\\right) \\\\\n&\\quad {} + 2\\left(\\frac{\\nu}{2}\\log \\frac{\\nu+1}{2} - \\frac{\\nu+1}{2} + \\frac{1}{2}\\log(2\\pi)  + \\frac{1}{6(\\nu+1)}\\right) \\\\\n&\\quad -2\\left(\\frac{\\nu-1}{2}\\log \\frac{\\nu}{2} - \\frac{\\nu}{2} + \\frac{1}{2}\\log(2\\pi)  + \\frac{1}{6\\nu}\\right) \\\\\n&\\quad {} - (\\nu + 1)(\\log((\\nu+1)/2) - \\frac{1}{\\nu+1}- \\log(\\nu/2) + \\frac{1}{\\nu}) \\\\\n=& \\log \\left(\\frac{\\nu^2}{(\\nu+1)(\\nu-2)}\\right)   - \\frac{\\nu +2}{3\\nu(\\nu+1)}.\n\\end{align*}\\]\nLet’s check this approximation numerically.\n\ntibble(nu = seq(2.1, 300, length.out = 1000),\n       exact = sqrt(1 + log(2/(nu-2)) + \n                      2*lgamma((nu+1)/2) - 2*lgamma(nu/2) - \n                      (nu + 1)* (digamma((nu+1)/2)-\n                                   digamma(nu/2))),\n       approx = sqrt(log(nu^2/((nu-2)*(nu+1))) - (nu+2)/(3*nu*(nu+1)))\n       ) |>\n  ggplot(aes(x = nu, y = exact)) + \n  geom_line(colour = \"red\") +\n  geom_line(aes(y = approx), colour = \"blue\", linetype = \"dashed\") +\n  theme_bw()\n\n\n\n\nOnce again, this is not a terrible approximation, but it’s also not an excellent one.\n\n\nExample 6 (Variance of a Gaussian random effect (Continued)) The distance calculation for the standard deviation of a Gaussian random effect has a very similar structure to the negative binomial case. We note, via wikipedia, that \\[\\begin{align*}\n\\operatorname{KL}(N(\\mu, \\tau^2) || N(\\mu, \\epsilon^2)) &= \\log \\frac{\\tau}{\\epsilon} + \\frac{\\tau^2}{\\epsilon^2} - \\frac{1}{2}  \\\\\n&= \\frac{\\tau^2}{\\epsilon^2}\\left(1 + \\frac{\\epsilon^2}{\\tau^2}\\log \\frac{\\tau}{\\epsilon}- \\frac{\\epsilon^2}{2\\tau^2}\\right).\n\\end{align*}\\]\nThis implies that \\[\nd(\\tau) = \\epsilon^{-1}\\tau + o(\\epsilon^{-1}).\n\\] We shall see later that the scaling on the \\(\\tau\\) doesn’t matter so for all intents and purposed \\[\nd(\\tau) = \\tau.\n\\]"
  },
  {
    "objectID": "posts/2022-08-29-priors4/priors4.html#spinning-off-the-flute-into-a-flat-bag-turning-a-distance-into-a-prior",
    "href": "posts/2022-08-29-priors4/priors4.html#spinning-off-the-flute-into-a-flat-bag-turning-a-distance-into-a-prior",
    "title": "Priors part 4: Specifying priors that appropriately penalise complexity",
    "section": "Spinning off the flute into a flat bag: Turning a distance into a prior",
    "text": "Spinning off the flute into a flat bag: Turning a distance into a prior\nSo now that we have a distance measure, we need to turn it into a prior. There are lots of ways we can do this. Essentially any prior we put on the distance \\(d(\\xi)\\) can be transformed into a prior on the flexibility parameter \\(\\xi\\). We do this through the change of variables formula \\[\np_\\xi(\\xi) = p_d(d(\\xi))\\left|\\frac{d}{d\\xi} d(\\xi)\\right|,\n\\] where \\(p_d(\\cdot)\\) is the prior density for the distance parameterisation\nBut which prior should we use on the distance? A good default choice is a prior that penalises at a constant rate. That is, we want \\[\n\\frac{p_d(d + \\delta)}{p_d(d)} = r^{\\delta}\n\\] for some \\(0<r<1\\). This condition says that the rate at which the density decreases does not change as we move through the parameter space. This is extremely useful because any other (monotone) distribution is going to have a point at which the bulk changes to the tail. As we are putting our prior on \\(d\\), we won’t necessarily be able to reason about this point.\nConstant-rate penalisation implies that the prior on the distance scale is an exponential distribution and, hence, we get our generic PC prior for a flexibility parameter \\(\\xi\\) \\[\np(\\xi) = \\lambda e^{-\\lambda d(\\xi)}\\left|\\frac{d}{d\\xi} d(\\xi)\\right|.\n\\]\n\nExample 7 (Overdispersion of a negative binomial (continued)) The exact PC prior for the overdispersion parameter in the negative binomial distribution is \\[\np(\\alpha) = \\frac{\\lambda}{\\alpha^{2}}\\frac{\\left|\\psi'\\left(\\alpha^{-1}\\right)-\\alpha\\right|}{ \\sqrt{2 \\log (\\alpha^{-1}) - 2 \\psi(\\alpha^{-1})}} \\exp \\left[ -\\lambda \\sqrt{2 \\log (\\alpha^{-1}) - 2 \\psi(\\alpha^{-1})}\\right],\n\\] where \\(\\psi'(\\cdot)\\) is the derivative of the digamma function.\nOn the other hand, if we use the approximate distance we get \\[\np_\\text{approx}(\\alpha) = \\frac{\\lambda}{2\\sqrt{\\alpha}} e^{-\\lambda \\sqrt{\\alpha}}.\n\\]\n\nlambda <- 1\ndat <- tibble(alpha = seq(0.01, 20, length.out = 1000),\n       exact = lambda / alpha^2 * abs(trigamma(1/alpha) - alpha)/\n         sqrt(2*log(1/alpha) -\n                2*digamma(1/alpha))*\n         exp(-lambda*sqrt(2*log(1/alpha) - \n                            2*digamma(1/alpha))),\n       approx = lambda/(2*sqrt(alpha))*exp(-lambda*sqrt(alpha))\n       ) \ndat |>\n  ggplot(aes(x = alpha, y = exact)) + \n  geom_line(colour = \"red\") +\n  geom_line(aes(y = approx), colour = \"blue\", linetype = \"dashed\") +\n  theme_bw()\n\n\n\ndat |>\n  ggplot(aes(x = alpha, y = exact - approx)) + \n  geom_line(colour = \"black\") +\n  theme_bw()\n\n\n\n\nThat’s a pretty good agreement!\n\n\nExample 8 (Student-t degrees of freedom (Continued)) An interesting feature of the PC prior (and any prior where the density on the distance scale takes its maximum at the base model) is that the implied prior on \\(\\nu\\) has no finite moments. In fact, if your prior on \\(\\nu\\) has finite moments, the density on the distance scale is zero at zero!\nThe exact PC prior for the degrees of freedom in a Student-t distribution is \\[\np(\\nu) = \\lambda \\frac{\\frac{1}{\\nu-2} + \\frac{\\nu+1}{2}\\left[\\psi'\\left(\\frac{\\nu+1}{2}\\right)-\\psi'\\left(\\frac{\\nu}{2}\\right)\\right]}{4d(\\nu)}e^{-\\lambda d(\\nu)},\n\\] where \\(d(\\nu)\\) is given above.\nThe approximate PC prior is \\[\np_\\text{approx}(\\nu) = \\lambda\\frac{\\nu(\\nu+2)(2\\nu+9) + 4}{3\\nu^2(\\nu+1)^2(\\nu-2)} \\left(\\frac{\\nu^2}{(\\nu+1)(\\nu-2)}\\right)^\\lambda e^{   - \\lambda\\frac{\\nu +2}{3\\nu(\\nu+1)}}.\n\\] Let’s look at the difference.\n\ndist_ex <- \\(nu) sqrt(1 + log(2/(nu-2)) + \n                      2*lgamma((nu+1)/2) - 2*lgamma(nu/2) - \n                      (nu + 1)* (digamma((nu+1)/2)-\n                                   digamma(nu/2)))\ndist_ap <- \\(nu) sqrt(log(nu^2/((nu-2)*(nu+1))) - (nu+2)/(3*nu*(nu+1)))\n\nlambda <- 1\ndat <- tibble(nu = seq(2.1, 30, length.out = 1000),\n       exact = lambda * (1/(nu-2) + (nu+1)/2 * (trigamma((nu+1)/2) - trigamma(nu/2)))/(4*dist_ex(nu)) * exp(-lambda*dist_ex(nu)),\n       approx = lambda * (nu*(nu+2)*(2*nu + 9) + 4)/(3*nu^2*(nu+1)^2*(nu-2)) * exp(-lambda*dist_ap(nu))\n       ) \ndat |>\n  ggplot(aes(x = nu, y = exact)) + \n  geom_line(colour = \"red\") +\n  geom_line(aes(y = approx), colour = \"blue\", linetype = \"dashed\") +\n  theme_bw()\n\n\n\ndat |>\n  ggplot(aes(x = nu, y = exact - approx)) + \n  geom_line(colour = \"black\") +\n  theme_bw()\n\n\n\n\nThe approximate prior isn’t so good for \\(\\nu\\) near 2. In the original paper, the distance was tabulated for \\(\\nu < 9\\) and a different high-precision asymptotic expansion was given for \\(\\nu>9\\).\nIn the original paper, we also plotted some common priors for the degrees of freedom on the distance scale to show just how informative flat-ish priors on \\(\\nu\\) can be! Note that the wider the uniform prior on \\(\\nu\\) is the more informative it is on the distance scale.\n\n\n\n(Left) Exponential priors on \\(\\nu\\) shown on the distance scale, from right to left the mean of the prior increases (5, 10, 20). (Right) \\(\\text{Uniform}[2, M]\\) priors on \\(\\nu\\) shown on the distance scale. From left to right \\(M\\) increases (20, 50, 100).\n\n\n\n\nExample 9 (Variance of a Gaussian random effect (Continued)) This is the easy one because the distance is equal to the standard deviation! The PC prior for the standard deviation of a Gaussian distribution is an exponential prior \\[\np(\\sigma) = \\lambda e^{-\\lambda \\sigma}.\n\\] More generally, if \\(u \\sim N(0, \\sigma^2 R)\\) is a multivariate normal distribution, than the PC prior for \\(\\sigma\\) is still \\[\np(\\sigma) = \\lambda e^{-\\lambda \\sigma}.\n\\] The corresponding prior on \\(\\sigma^2\\) is \\[\np(\\sigma^2) = \\frac{\\lambda}{2\\sqrt{\\sigma^2}}e^{-\\lambda\\sqrt{\\sigma^2}}.\n\\] Sometimes, for instance if you’re converting a model from BUGS or you’re looking at the smoothing parameter of a smoothing spline, you might specify your normal distribution in terms of the precision, which is the inverse of the variance. If \\(u \\sim N(0, \\gamma^{-1}Q^{-1})\\), then the corresponding PC prior (using the change of variables \\(\\gamma = \\sigma^{-2}\\)) is \\[\np(\\gamma) = \\frac{\\lambda}{2}\\gamma^{-3/2} e^{-\\lambda \\gamma^{-1/2}}.\n\\]\nThis case was explored extensively in the context of structured additive regression models (think GAMs but moreso) by Klein and Kneib, who found that the choice of exponential prior on the distance scale gave more consistent performance than either a half-normal or a half-Cauchy distribution."
  },
  {
    "objectID": "posts/2022-08-29-priors4/priors4.html#closing-the-door-how-to-choose-lambda",
    "href": "posts/2022-08-29-priors4/priors4.html#closing-the-door-how-to-choose-lambda",
    "title": "Priors part 4: Specifying priors that appropriately penalise complexity",
    "section": "Closing the door: How to choose \\(\\lambda\\)",
    "text": "Closing the door: How to choose \\(\\lambda\\)\nThe big unanswered question is how do we choose \\(\\lambda\\). The scaling of a prior distribution is vital to its success, so this is an important question.\nAnd I will just say this: work it out your damn self.\nThe thing about prior distributions that shamelessly include information is that, at some point, you need to include36 some information. And there is no way for anyone other than the data analyst to know what the information to include is.\nBut I can outline a general procedure.\nImagine that for your flexibility parameter \\(\\xi\\) you have some interpretable transformation of it \\(Q(\\xi)\\). For instance if \\(\\xi = \\sigma^2\\), then a good choice for \\(Q(\\cdot)\\) would be \\(Q(\\sigma^2)=\\sigma\\). This is because standard deviations are on the same scale as the observations37, and we have intuition about that happens one standard deviation from the mean.\nWe then use problem-specific information can help us set a natural scale for \\(Q(\\xi)\\). We do this by choosing \\(\\lambda\\) so that \\[\n\\Pr(Q(\\xi) > U) = \\alpha\n\\] for some \\(U\\), which we would consider large38 for our problem, and \\(0<\\alpha<1\\).\nFrom the properties of the exponential distribution, we can see that we can satisfy this if we choose \\[\n\\lambda = - \\frac{\\log(\\alpha)}{d^{-1}(Q^{-1}(U))}.\n\\] This can be found numerically if it needs to be.\nThe simplest case is the standard deviation of the normal distribution, because in this case \\(Q(\\sigma) = \\sigma\\) and \\(d^{-1}(Q^{-1}(U)) = U\\). In general, if \\(u \\sim N(0, \\sigma R)\\) and \\(R\\) is not a correlation matrix, you should take into account the diagonal of \\(R\\) when choosing \\(Q\\). For instance, choosing \\(Q\\) to be the geometric mean39 of the marginal variances of the \\(u_i\\) is a good idea!\nWhen a model has more than one component, or a component has more than one flexibility parameter, it can be the case that \\(Q(\\cdot)\\) depends on multiple parameters. For instance, if I hadn’t reparameterised the Student-t distribution to have variance independent of \\(\\nu\\), a PC prior on \\(\\sigma\\) would have a quantity of interest that depends on \\(\\nu\\). We will also see this if I ever get around to writing about priors for Gaussian processes."
  },
  {
    "objectID": "posts/2022-08-29-priors4/priors4.html#the-dream-pc-priors-in-practice",
    "href": "posts/2022-08-29-priors4/priors4.html#the-dream-pc-priors-in-practice",
    "title": "Priors part 4: Specifying priors that appropriately penalise complexity",
    "section": "The Dream: PC priors in practice",
    "text": "The Dream: PC priors in practice\nThus we can put together a PC prior as the unique prior that follows the following four principles:\n\nOccam’s razor: We have a base model that represents simplicity and we prefer our base model.\nMeasuring complexity: We define the prior using the square root of the KL divergence between the base model and the more flexible model. The square root ensures that the divergence is on a similar scale to a distance, but we maintain the asymmetry of the divergence as as a feature (not a bug).\nConstant penalisation: We use an exponential prior on the distance scale to ensure that our prior mass decreases evenly as we move father away from the base model.\nUser-defined scaling: We need the user to specify a quantity of interest \\(Q(\\xi)\\) and a scale \\(U\\). We choose the scaling of the prior so that \\(\\Pr(Q(\\xi) > U) = \\alpha\\). This ensures that when we move to a new context, we are able to modify the prior by using the relevant information about \\(Q(\\xi)\\).\n\nThese four principles define a PC prior. I think the value of laying them out explicitly is that users and critics can clearly and cleanly identify if these principles are relevant to their problem and, if they are, they can implement them. Furthermore, if you need to modify the principles (say by choosing a different distance measure), there is a clear way to do that.\nI’ve come to the end of my energy for this blog post, so I’m going to try to wrap it up. I will write more on the topic later, but for now there are a couple of things I want to say.\nThese priors can seem quite complex, but I assure you that are a) useful, b) used, and c) not too terrible in practice. Why? Well fundamentally because you usually don’t have to derive them yourselves. Moreover, a lot of that complexity is the price we pay for dealing with densities. We think that this is worth it and the lesson that the parameterisation that you are given may not be the correct parameterisation to use when specifying your prior is an important one!\nThe original paper contains a bunch of other examples. The paper was discussed and we wrote a rejoinder40, which contains an out-of-date list of other PC priors people have derived. If you are interested in some other people’s views of this idea, a good place to start is the discussion of the original paper.\nThere are also PC priors for Gaussian Processes, disease mapping models, AR(p) processes, variance parameters in multilevel models, and many more applications.\nPC priors are all over the INLA software package and its documentation contains a bunch more examples.\nTry them out. They’ll make you happy."
  },
  {
    "objectID": "posts/2022-05-16-design-is-my-passion-sparse-matrices-part-four/design-is-my-passion-sparse-matrices-part-four.html",
    "href": "posts/2022-05-16-design-is-my-passion-sparse-matrices-part-four/design-is-my-passion-sparse-matrices-part-four.html",
    "title": "Sparse Matrices 4: Design is my passion",
    "section": "",
    "text": "This is the fourth post in a series where I try to squeeze autodiffable sparse matrices into JAX with the aim to speed up some model classes in PyMC. So far, I have:\nI am in the process of writing a blog on building new primitives1 into JAX, but as I was doing it I accidentally wrote a long section about options for exposing sparse matrices. It really didn’t fit very well into that blog, so here it is."
  },
  {
    "objectID": "posts/2022-05-16-design-is-my-passion-sparse-matrices-part-four/design-is-my-passion-sparse-matrices-part-four.html#what-are-we-trying-to-do-here",
    "href": "posts/2022-05-16-design-is-my-passion-sparse-matrices-part-four/design-is-my-passion-sparse-matrices-part-four.html#what-are-we-trying-to-do-here",
    "title": "Sparse Matrices 4: Design is my passion",
    "section": "What are we trying to do here?",
    "text": "What are we trying to do here?\nIf you recall from the first blog, we need to be able to compute the value and gradients of the (un-normalised) log-posterior \\[\n\\log(p(\\theta \\mid y)) = \\frac{1}{2} \\mu_{u\\mid y, \\theta}(\\theta)^TA^TW^{-1}y + \\frac{1}{2} \\log(|Q(\\theta)|) - \\frac{1}{2}\\log(|Q_{u\\mid y, \\theta}(\\theta)|) + \\text{const},\n\\] where \\(Q(\\theta)\\) is a sparse matrix, and \\[\n\\mu_{u\\mid y, \\theta}(\\theta) = \\frac{1}{\\sigma^2} Q_{u\\mid y,\\theta}(\\theta)^{-1} A^TW^{-1}y.\n\\]\nOverall, our task is to design a system where this un-normalised log-posterior can be evaluated and differentiated efficiently. As with all design problems, there are a lot of different ways that we can implement it. They share a bunch of similarities, so we will actually end up implementing the guts of all of the systems.\nTo that end, let’s think of all of the ways we can implement our target2."
  },
  {
    "objectID": "posts/2022-05-16-design-is-my-passion-sparse-matrices-part-four/design-is-my-passion-sparse-matrices-part-four.html#option-1-the-direct-design",
    "href": "posts/2022-05-16-design-is-my-passion-sparse-matrices-part-four/design-is-my-passion-sparse-matrices-part-four.html#option-1-the-direct-design",
    "title": "Sparse Matrices 4: Design is my passion",
    "section": "Option 1: The direct design",
    "text": "Option 1: The direct design\n\n\\(A \\rightarrow \\log(|A|)\\), for a sparse, symmetric positive definite matrix \\(A\\)\n\\((A,b) \\rightarrow A^{-1}b\\), for a sparse, symmetric positive definite matrix \\(A\\) and a vector \\(b\\)\n\nThis option is, in some sense, the most straightforward. We implement primitives for both of the major components of our target and combine them using existing JAX primitives (like addition, scalar multiplication, and dot products).\nThis is a bad idea.\nThe problem is that both primitives require the Cholesky decomposition of \\(A\\), so if we take this route we might end up computing an extra Cholesky decomposition. And you may ask yourself: what’s an extra Cholesky decomposition between friends?\nWell, Jonathan, it’s the most expensive operation we are doing for these models, so perhaps we should avoid the 1/3 increase in running time!\nThere are some ways around this. We might implement sparse, symmetric positive definite matrices as a class that, upon instantiation, computes the Cholesky factorisation.\n\nclass SPDSparse: \n  def __init__(self, A_indices, A_indptr, A_x):\n    self._perm, self._iperm = _find_perm(A_indices, A_indptr)\n    self._A_indices, self._A_indptr, self._A_x = _twist(self._perm, A_indices, A_indptr, A_x)\n    try:\n      self._L_indices, self._L_indptr, self._L_x = _compute_cholesky()\n    except SPDError:\n      print(\"Matrix is not symmetric positive definite to machine precision.\")\n  \n  def _find_perm(self, indices, indptr):\n    \"\"\"Finds the best fill-reducing permutation\"\"\"\n    raise NotImplemented(\"_find_perm\")\n  \n  def _twist(self, perm, indices, indptr, x):\n    \"\"\"Returns A[perm, perm]\"\"\"\n    raise NotImplemented(\"_twist\")\n  \n  def _compute_cholesky():\n    \"\"\"Compute the Cholesky decomposition of the permuted matrix\"\"\"\n    raise NotImplemented(\"_compute_cholesky\")\n  \n  # Not pictured: a whole forest of gets\n\nIn contexts where we need a Cholesky decomposition of every SPD matrix we instantiate, this design might be useful. It might also be useful to write a constructor that takes a jax.experimental.CSCMatrix, so that we could build a differentiable matrix and then just absolutely slam it into our filthy little Cholesky context3.\nIn order to use this type of pattern with JAX, we would need to register it as a Pytree class, which involves writing flatten and unflatten routines. The CSCSparse class is a good example of how to implement this type of thing. Some care would be needed to make sure the differentiation rules don’t try to do something stupid like differentiate with respect to self.iperm or self.L_x. This is beyond the extra autodiff sugar in the experimental sparse library.\nImplementing this would be quite an undertaking, but it’s certainly an option. The most obvious downside of this pattern (plus a fully functional sparse matrix class) is that it may end up being quite delicate to have this volume of auxillary information4 in a pytree while making everything differentiate properly. This doesn’t seem to be how most parts of JAX has been built. There are also a couple of sharp corners we could run into with instantiation.\nTo close this out, it’s worth noting a variation on this pattern that comes up: the optional Cholesky. The idea is that rather than compute the permutations and the Cholesky factorisation on initialisation, we store a boolean flag in the class is_cholesky and, whenever we need a Cholesky factor we check is_cholesky and if it’s True we use the computed Cholesky factor and otherwise we compute it and set is_cholesky = True.\nThis pattern introduces state to the object: it is no longer set and forget. This will not work within JAX5, where objects need to be immutable. It’s also not an exceptional pattern in general: it is considerably easier to debug code with stateless objects."
  },
  {
    "objectID": "posts/2022-05-16-design-is-my-passion-sparse-matrices-part-four/design-is-my-passion-sparse-matrices-part-four.html#option-2-implement-all-of-the-combinations-of-functions-that-we-need",
    "href": "posts/2022-05-16-design-is-my-passion-sparse-matrices-part-four/design-is-my-passion-sparse-matrices-part-four.html#option-2-implement-all-of-the-combinations-of-functions-that-we-need",
    "title": "Sparse Matrices 4: Design is my passion",
    "section": "Option 2: Implement all of the combinations of functions that we need",
    "text": "Option 2: Implement all of the combinations of functions that we need\nRather than dicking around with classes, we could just implement primitives that compute\n\n\\(A \\rightarrow \\log(|A|)\\), for a sparse, symmetric positive definite matrix \\(A\\)\n\\((A,b, c) \\rightarrow \\log(|A|) + c^TA^{-1}b\\), for a sparse, symmetric positive definite matrix \\(A\\) and vectors \\(b\\) and \\(c\\).\n\nThis is exactly what we need to do our task and nothing more. It won’t result in any unnecessary Cholesky factors. It doesn’t need us to store computed Cholesky factors. We can simply eat, prey, love.\nThe obvious downside to this option is it’s going to just massively expand the codebase if there are more things that we want to do. It’s also not obvious why we would do this instead of just making \\(\\log p(\\theta \\mid y)\\) a primitive6."
  },
  {
    "objectID": "posts/2022-05-16-design-is-my-passion-sparse-matrices-part-four/design-is-my-passion-sparse-matrices-part-four.html#option-3-just-compute-the-cholesky",
    "href": "posts/2022-05-16-design-is-my-passion-sparse-matrices-part-four/design-is-my-passion-sparse-matrices-part-four.html#option-3-just-compute-the-cholesky",
    "title": "Sparse Matrices 4: Design is my passion",
    "section": "Option 3: Just compute the Cholesky",
    "text": "Option 3: Just compute the Cholesky\nOur third option is to simply compute (and differentiate) the Cholesky factor directly. We can then compute \\(\\log(|A|)\\) and \\(A^{-1}b\\) through a combination of differentiable operations on the elements of the Cholesky factor (for \\(\\log(|A|)\\)) and triangular linear solves \\(L^{-1}b\\) and \\(L^{-T}c\\) (for \\(A^{-1}b\\)).\nHence we require the following two7 JAX primitives:\n\n\\(A \\rightarrow \\operatorname{chol}(A)\\), where \\(\\operatorname{chol}(A)\\) is the Cholesky factor of \\(A\\),\n\\((L, b) \\rightarrow L^{-1} b\\) and \\((L, b) \\rightarrow L^{-T}b\\) for lower-triangular sparse matrix \\(L\\).\n\nThis is pretty close to how the dense version of this function would be implemented.\nThere are two little challenges with this pattern:\n\nWe are adding another large-ish node \\(L\\) to our autodiff tree. As we saw in other patterns, this is unnecessary storage for our problem at hand.\nThe number of non-zeros in \\(L\\) is a function of the non-zero pattern of \\(A\\). This means the Cholesky will need to be implemented very carefully to ensure that its traceable enough.\n\nThe second point here might actually be an issue. To be honest, I have no idea. I think maybe it’s fine? But I need to do a close read on the adding primitives doc. Essentially, as long as the abstract traces just need shapes but not dimensions, we should be ok.\nFor adding this to something like Stan, however, we will likely need to do some extra work to make sure we know the number of parameters.\nThe advantage of this type of design pattern is that it gives users the flexibility to do whatever perverted thing they want to do with the Cholesky triangle. For example, they might want to do a centring/non-centring transformation. In Option 1, we would need to write explicit functions to let them do that (not difficult, but there’s a lot of code to write, which has the annoying tendency to increases the maintainence burden)."
  },
  {
    "objectID": "posts/2022-05-16-design-is-my-passion-sparse-matrices-part-four/design-is-my-passion-sparse-matrices-part-four.html#option-4-functors",
    "href": "posts/2022-05-16-design-is-my-passion-sparse-matrices-part-four/design-is-my-passion-sparse-matrices-part-four.html#option-4-functors",
    "title": "Sparse Matrices 4: Design is my passion",
    "section": "Option 4: Functors!",
    "text": "Option 4: Functors!\nA slightly wilder design pattern would be to abandon sparse matrices and just make functions A(theta, ...) that return a sparse matrix. If that function is differentiable wrt its first argument, then we can build this whole thing up that way.\nIn reality, the only way I can think of to implement this pattern would be to implement a whole differentiable sparse matrix arithmetic (make operations like alpha * A + beta * B, C * D work for sparse matrices). At which point, we’ve basically just recreated option 1.\nI’m really only bringing up functors because unlike sparse matrices, it is actually a pretty good model for implementing Gaussian Processes with general covariance functions. There’s a little bit of the idea in this Stan issue that, to my knowledge, hasn’t gone anywhere. More recently, a variant has been used successfully in the (as yet un-merged) Laplace approximation feature in Stan."
  },
  {
    "objectID": "posts/2022-05-16-design-is-my-passion-sparse-matrices-part-four/design-is-my-passion-sparse-matrices-part-four.html#which-one-should-we-use",
    "href": "posts/2022-05-16-design-is-my-passion-sparse-matrices-part-four/design-is-my-passion-sparse-matrices-part-four.html#which-one-should-we-use",
    "title": "Sparse Matrices 4: Design is my passion",
    "section": "Which one should we use?",
    "text": "Which one should we use?\nWe don’t really need to make that choice yet. So we won’t.\nBut personally, I like option 1. I expect everyone else on earth would prefer option 3. For densities that see a lot of action, it would make quite a bit of sense to consider making that density a primitive when it has a complex derivative (à la option 2).\nBut for now, let’s park this and start getting in on the implementations."
  },
  {
    "objectID": "posts/2022-05-14-jax-ing-a-sparse-cholesky-factorisation-part-3-in-an-ongoing-journey/jax-ing-a-sparse-cholesky-factorisation-part-3-in-an-ongoing-journey.html",
    "href": "posts/2022-05-14-jax-ing-a-sparse-cholesky-factorisation-part-3-in-an-ongoing-journey/jax-ing-a-sparse-cholesky-factorisation-part-3-in-an-ongoing-journey.html",
    "title": "Sparse Matrices 3: Failing at JAX",
    "section": "",
    "text": "This is part three of an ongoing exercise in hubris. Part one is here. Part two is here. The overall aim of this series of posts is to look at how sparse Cholesky factorisations work, how JAX works, and how to marry the two with the ultimate aim of putting a bit of sparse matrix support into PyMC, which should allow for faster inference in linear mixed models, Gaussian spatial models. And hopefully, if anyone ever gets around to putting the Laplace approximation in, all sorts of GLMMs and non-Gaussian models with splines and spatial effects.\nIt’s been a couple of weeks since the last blog, but I’m going to just assume that you are fully on top of all of those details. To that end, let’s jump in."
  },
  {
    "objectID": "posts/2022-05-14-jax-ing-a-sparse-cholesky-factorisation-part-3-in-an-ongoing-journey/jax-ing-a-sparse-cholesky-factorisation-part-3-in-an-ongoing-journey.html#what-is-jax",
    "href": "posts/2022-05-14-jax-ing-a-sparse-cholesky-factorisation-part-3-in-an-ongoing-journey/jax-ing-a-sparse-cholesky-factorisation-part-3-in-an-ongoing-journey.html#what-is-jax",
    "title": "Sparse Matrices 3: Failing at JAX",
    "section": "What is JAX?",
    "text": "What is JAX?\nJAX is a minor miracle. It will take python+numpy code and make it cool. It will let you JIT1 compile it! It will let you differentiate it! It will let you batch2. JAX refers to these three operations as transformations.\nBut, as The Mountain Goats tell us God is present in the sweeping gesture, but the devil is in the details. And oh boy are those details going to be really fucking important to us.\nThere are going to be two key things that will make our lives more difficult:\n\nNot every operation can be transformed by every operation. For example, you can’t always JIT or take gradients of a for loop. This means that some things have to be re-written carefully to make sure it’s possible to get the advantages we need.\nJAX arrays are immutable. That means that once a variable is defined it cannot be changed. This means that things like a = a + 1 is not allowed! If you’ve come from an R/Python/C/Fortran world, this is the weirdest thing to deal with.\n\nThere are really excellent reasons for both of these restrictions. And looking into the reasons is fascinating. But not a topic for this blog3\nJAX has some pretty decent4 documentation, a core piece of which outlines some of the sharp edges you will run into. As you read through the documentation, the design choices become clearer.\nSo let’s go and find some sharp edges together!"
  },
  {
    "objectID": "posts/2022-05-14-jax-ing-a-sparse-cholesky-factorisation-part-3-in-an-ongoing-journey/jax-ing-a-sparse-cholesky-factorisation-part-3-in-an-ongoing-journey.html#to-jax-or-not-to-jax",
    "href": "posts/2022-05-14-jax-ing-a-sparse-cholesky-factorisation-part-3-in-an-ongoing-journey/jax-ing-a-sparse-cholesky-factorisation-part-3-in-an-ongoing-journey.html#to-jax-or-not-to-jax",
    "title": "Sparse Matrices 3: Failing at JAX",
    "section": "To JAX or not to JAX",
    "text": "To JAX or not to JAX\nBut first, we need to ask ourselves which functions do we need to JAX?\nIn the context of our problem we, so far, have three functions:\n\n_symbolic_factor_csc(A_indices, A_indptr), which finds the non-zero indices of the sparse Cholesky factor and return them in CSC format,\n_deep_copy_csc(A_indices, A_indptr, A_x, L_indices, L_indptr), which takes the entries of the matrix \\(A\\) and re-creates them so they can be indexed within the larger pattern of non-zero elements of \\(L\\),\n_sparse_cholesky_csc_impl(L_indices, L_indptr, L_x), which actually does the sparse Cholesky factorisation.\n\nLet’s take them piece by piece, which is also a good opportunity to remind everyone what the code looked like."
  },
  {
    "objectID": "posts/2022-05-14-jax-ing-a-sparse-cholesky-factorisation-part-3-in-an-ongoing-journey/jax-ing-a-sparse-cholesky-factorisation-part-3-in-an-ongoing-journey.html#symbolic-factorisation",
    "href": "posts/2022-05-14-jax-ing-a-sparse-cholesky-factorisation-part-3-in-an-ongoing-journey/jax-ing-a-sparse-cholesky-factorisation-part-3-in-an-ongoing-journey.html#symbolic-factorisation",
    "title": "Sparse Matrices 3: Failing at JAX",
    "section": "Symbolic factorisation",
    "text": "Symbolic factorisation\n\ndef _symbolic_factor_csc(A_indices, A_indptr):\n  # Assumes A_indices and A_indptr index the lower triangle of $A$ ONLY.\n  n = len(A_indptr) - 1\n  L_sym = [np.array([], dtype=int) for j in range(n)]\n  children = [np.array([], dtype=int) for j in range(n)]\n  \n  for j in range(n):\n    L_sym[j] = A_indices[A_indptr[j]:A_indptr[j + 1]]\n    for child in children[j]:\n      tmp = L_sym[child][L_sym[child] > j]\n      L_sym[j] = np.unique(np.append(L_sym[j], tmp))\n    if len(L_sym[j]) > 1:\n      p = L_sym[j][1]\n      children[p] = np.append(children[p], j)\n        \n  L_indptr = np.zeros(n+1, dtype=int)\n  L_indptr[1:] = np.cumsum([len(x) for x in L_sym])\n  L_indices = np.concatenate(L_sym)\n  \n  return L_indices, L_indptr\n\nThis function only needs to be computed once per non-zero pattern. In the applications I outlined in the first post, this non-zero pattern is fixed. This means that you only need to run this function once per analysis (unlike the others, that you will have to run once per iteration!).\nAs a general rule, if you only do something once, it isn’t all that necessary to devote too much time into optimising it. There are, however, some obvious things we could do.\nIt is, for instance, pretty easy to see how you would implement this with an explicit tree5 structure instead of constantly np.appending the children array. This is far better from a memory standpoint.\nIt’s also easy to imagine this as a two-pass algorithm, where you build the tree and count the number of non-zero elements in the first pass and then build and populate L_indices in the second pass.\nThe thing is, neither of these things fixes the core problem for using JAX to JIT this: the dimensions of the internal arrays depend on the values of the inputs. This is not possible.\nIt seems like this would be a huge limitation, but in reality it isn’t. Most functions aren’t like this one! And, if we remember that JAX is a domain language focussing mainly on ML applications, this is very rarely the case. It is always good to remember context!\nSo what are our options? We have two.\n\nLeave it in Python and just eat the speed.\nBuild a new JAX primitive and write the XLA compilation rule6.\n\nToday are opting for the first option!"
  },
  {
    "objectID": "posts/2022-05-14-jax-ing-a-sparse-cholesky-factorisation-part-3-in-an-ongoing-journey/jax-ing-a-sparse-cholesky-factorisation-part-3-in-an-ongoing-journey.html#the-structure-changing-copy",
    "href": "posts/2022-05-14-jax-ing-a-sparse-cholesky-factorisation-part-3-in-an-ongoing-journey/jax-ing-a-sparse-cholesky-factorisation-part-3-in-an-ongoing-journey.html#the-structure-changing-copy",
    "title": "Sparse Matrices 3: Failing at JAX",
    "section": "The structure-changing copy",
    "text": "The structure-changing copy\n\ndef _deep_copy_csc(A_indices, A_indptr, A_x, L_indices, L_indptr):\n  n = len(A_indptr) - 1\n  L_x = np.zeros(len(L_indices))\n  \n  for j in range(0, n):\n    copy_idx = np.nonzero(np.in1d(L_indices[L_indptr[j]:L_indptr[j + 1]],\n                                  A_indices[A_indptr[j]:A_indptr[j+1]]))[0]\n    L_x[L_indptr[j] + copy_idx] = A_x[A_indptr[j]:A_indptr[j+1]]\n  return L_x\n\nThis is, fundamentally, a piece of bookkeeping. An annoyance of sparse matrices. Or, if you will, explicit cast between different sparse matrix types7. This is a thing that we do actually need to be able to differentiate, so it needs to live in JAX.\nSo where are the potential problems? Let’s go line by line.\n\nn = len(A_indptr) - 1: This is lovely. n is used in a for loop later, but because it is a function of the shape of A_indptr, it is considered static and we will be able to JIT over it!\nL_x = np.zeros(len(L_indices)): Again, this is fine. Sizes are derived from shapes, life is peachy.\nfor j in range(0, n):: This could be a problem if n was an argument or derived from values of the arguments, but it’s derived from a shape so it is static. Praise be! Well, actually it’s a bit more involved than that.\n\nThe problem with the for loop is what will happen when it is JIT’d. Essentially, the loop will be statically unrolled8. That is fine for small loops, but it’s a bit of a pain in the arse when n is large.\nIn this case, we might want to use the structured control flow in jax.lax9 In this case we would need jax.lax.fori_loop(start, end, body_fun, init_value). This makes the code look less pythonic, but probably should make it faster. It is also, and I cannot stress this enough, an absolute dick to use.\n(In actuality, we will see that we do not need this particular corner of the language here!)\n\ncopy_idx = np.nonzero(...): This looks like it’s going to be complicated, but actually it is a perfectly reasonable composition of numpy functions. Hence, we can use the same jax.numpy functions with minimal changes. The one change that we are going to need to make in order to end up with a JIT-able and differentiable function is that we need to tell JAX how many non-zero elements there are. Thankfully, we know this! Because the non-zero pattern of \\(A\\) is a subset of the non-zero pattern of \\(L\\), we know that\n\n\nnp.in1d(L_indices[L_indptr[j]:L_indptr[j + 1]], A_indices[A_indptr[j]:A_indptr[j+1]])\n\nwill have exactly len(A_indices[A_indptr[j]:A_indptr[j+1]]) True values, and so np.nonzero(...) will have that many. We can pass this information to jnp.nonzero() using the optional size argument.\nOh no! We have a problem! This return size is a function of the values of A_indptr rather than a function of the shape. This means we’re a bit fucked.\nThere are two routes out:\n\nDeclare A_indptr to be a static parameter, or\nChange the representation from CSC to something more convenient.\n\nIn this case we could do either of these things, but I’m going to opt for the second option, as it’s going to be more useful going forward.\nBut before we do that, let’s look at the final line in the code.\n\nL_x[L_indptr[j] + copy_idx] = A_x[A_indptr[j]:A_indptr[j+1]]: The final non-trivial line of the code is also a problem. The issue is that these arrays are immutable and we are asking to change the values! That is not allowed!\n\nThe solution here is to use a clunkier syntax. In JAX, we need to replace\n\nx[ind] = a\n\nwith the less pleasant\n\nx = x.at[ind].set(a)\n\nWhat is going on under the hood to make the second option ok while the first is an error is well beyond the scope of this little post. But the important thing is that they compile down to an in-place10 update, which is all we really care about."
  },
  {
    "objectID": "posts/2022-05-14-jax-ing-a-sparse-cholesky-factorisation-part-3-in-an-ongoing-journey/jax-ing-a-sparse-cholesky-factorisation-part-3-in-an-ongoing-journey.html#re-doing-the-data-structure.",
    "href": "posts/2022-05-14-jax-ing-a-sparse-cholesky-factorisation-part-3-in-an-ongoing-journey/jax-ing-a-sparse-cholesky-factorisation-part-3-in-an-ongoing-journey.html#re-doing-the-data-structure.",
    "title": "Sparse Matrices 3: Failing at JAX",
    "section": "Re-doing the data structure.",
    "text": "Re-doing the data structure.\nOk. So we need a new data structure. That’s annoying. The rule, I guess, is always that if you need to innovate, you should innovate very little if you can get away with it, or a lot if you have to.\nWe are going to innovate only the tiniest of bits.\nThe idea is to keep the core structure of the CSC data structure, but to replace the indptr array with explicitly storing the row indices and row values as a list of np.arrays. So A_index will now be a list of n arrays that contain the row indices of the non-zero elements of \\(A\\), while A_xwill now be a list of n arrays that contain the values of the non-zero elements of \\(A\\).\nThis means that the matrix \\[\nB = \\begin{pmatrix}\n1 &&5 \\\\\n2&3& \\\\\n&4&6\n\\end{pmatrix}\n\\] would be stored as\n\nB_index = [np.array([0,1]), np.array([1,2]), np.array([0,2])]\nB_x = [np.array([1,2]), np.array([3,4]), np.array([5,6])]\n\nThis is a considerably more pythonic11 version of CSC. So I guess that’s an advantage.\nWe can easily go from CSC storage to this modified storage.\n\ndef to_pythonic_csc(indices, indptr, x):\n  index = np.split(indices, indptr[1:-1])\n  x = np.split(x, indptr[1,-1])\n  return index, x"
  },
  {
    "objectID": "posts/2022-05-14-jax-ing-a-sparse-cholesky-factorisation-part-3-in-an-ongoing-journey/jax-ing-a-sparse-cholesky-factorisation-part-3-in-an-ongoing-journey.html#a-jax-tracable-structure-changing-copy",
    "href": "posts/2022-05-14-jax-ing-a-sparse-cholesky-factorisation-part-3-in-an-ongoing-journey/jax-ing-a-sparse-cholesky-factorisation-part-3-in-an-ongoing-journey.html#a-jax-tracable-structure-changing-copy",
    "title": "Sparse Matrices 3: Failing at JAX",
    "section": "A JAX-tracable structure-changing copy",
    "text": "A JAX-tracable structure-changing copy\nSo now it’s time to come back to that damn for loop. As flagged earlier, for loops can be a bit picky in JAX. If we use them as is, then the code that is generated and then compiled is unrolled. You can think of this as if the JIT compiler automatically writes a C++ program and then compiles it. If you were to examine that code, the for loop would be replaced by n almost identical blocks of code with only the index j changing between them. This leads to a potentially very large program to compile12 and it limits the compiler’s ability to do clever things to make the compiled code run faster13.\nThe lax.fori_loop() function, on the other hand, compiles down to the equivalent of a single operation14. This lets the compiler be super clever.\nBut we don’t actually need this here. Because if you take a look at the original for loop we are just applying the same two lines of code to each triple of lists in A_index, A_x, and L_index (in our new15 data structure).\nThis just screams out for a map applying a single function independently to each column.\nThe challenge is to find the right map function. An obvious hope would be jax.vmap. Sadly, jax.vmap does not do that. (At least not without more padding16 than a drag queen.) The problem here is a misunderstanding of what different parts of JAX are for. Functions like jax.vmap are made for applying the same function to arrays of the same size. This makes sense in their context. (JAX is, after all, made for machine learning and these shape assumptions fit really well in that paradigm. They just don’t fit here.)\nAnd I won’t lie. After this point I went wild. lax.map did not help. And I honest to god tried lax.scan, which is will solve the problem but at what cost?.\nBut at some point, you read enough of the docs to find the answer.\nThe correct answer here is to use the JAX concept of a pytree. Pytrees are essentially17 lists of arrays. They’re very flexible and they have a jax.tree_map function that lets you map over them! We are saved!\n\nimport numpy as np\nfrom jax import numpy as jnp\nfrom jax import tree_map\n\ndef _structured_copy_csc(A_index, A_x, L_index):\n    def body_fun(A_rows, A_vals, L_rows):\n      out = jnp.zeros(len(L_rows))\n      copy_idx =  jnp.nonzero(jnp.in1d(L_rows, A_rows), size = len(A_rows))[0] \n      out = out.at[copy_idx].set(A_vals)\n      return out\n    L_x = tree_map(body_fun, A_index, A_x, L_index)\n    return L_x\n\n\nTesting it out\nOk so now lets see if it works. To do that I’m going to define a very simple function \\[\nf(A, \\alpha, \\beta) = \\|\\alpha I + \\beta \\operatorname{tril}(A)\\|_F^2,\n\\] that is the sum of the squares of all of the elements of \\(\\alpha I + \\beta \\operatorname{tril}(A)\\). There’s obviously an easy way to do this, but I’m going to do it in a way that uses the function we just built.\n\ndef test_func(A_index, A_x, params):\n  I_index = [jnp.array([j]) for j in range(len(A_index))]\n  I_x = [jnp.array([params[0]]) for j in range(len(A_index))]\n  I_x2 = _structured_copy_csc(I_index, I_x, A_index)\n  return jnp.sum((jnp.concatenate(I_x2) + params[1] * jnp.concatenate(A_x))**2)\n\nNext, we need a test case. Once again, we will use the 2D Laplacian on a regular \\(n \\times n\\) grid (up to a scaling). This is a nice little function because it’s easy to make test problems of different sizes.\n\nfrom scipy import sparse\n\ndef make_matrix(n):\n    one_d = sparse.diags([[-1.]*(n-1), [2.]*n, [-1.]*(n-1)], [-1,0,1])\n    A_lower = sparse.tril(sparse.kronsum(one_d, one_d) + sparse.eye(n*n), format = \"csc\")\n    A_index = jnp.split(jnp.array(A_lower.indices), A_lower.indptr[1:-1])\n    A_x = jnp.split(jnp.array(A_lower.data), A_lower.indptr[1:-1])\n    return (A_index, A_x)\n\nWith our test case in hand, we can check to see if JAX will differentiate for us!\n\nfrom jax import grad, jit\nfrom jax.test_util import check_grads\n\ngrad_func = grad(test_func, argnums = 2)\n\nA_index, A_x = make_matrix(50)\nprint(f\"The value at (2.0, 2.0) is {test_func(A_index, A_x, (2.0, 2.0))}.\")\nprint(f\"The gradient is {np.array(grad_func(A_index, A_x, (2.0, 2.0)))}.\")\n\nThe value at (2.0, 2.0) is 379600.0.\n\n\nThe gradient is [ 60000. 319600.].\n\n\nFabulous! That works!"
  },
  {
    "objectID": "posts/2022-05-14-jax-ing-a-sparse-cholesky-factorisation-part-3-in-an-ongoing-journey/jax-ing-a-sparse-cholesky-factorisation-part-3-in-an-ongoing-journey.html#but-what-about-jit",
    "href": "posts/2022-05-14-jax-ing-a-sparse-cholesky-factorisation-part-3-in-an-ongoing-journey/jax-ing-a-sparse-cholesky-factorisation-part-3-in-an-ongoing-journey.html#but-what-about-jit",
    "title": "Sparse Matrices 3: Failing at JAX",
    "section": "But what about JIT?",
    "text": "But what about JIT?\nJIT took fucking ages. I’m talking “it threw a message” amounts of time. I’m not even going to pretend that I understand why. But I can hazard a guess.\nMy running assumption, taken from the docs, is that as long as the function only relies of quantities that are derived from the shapes of the inputs (and not the values), then JAX will be able to trace through and JIT through the functions with ease.\nThis might not be true for tree_maps. The docs are, as far as I can tell, silent on this matter. And a cursory look through the github repo did not give me any hints as to how tree_map() is translated.\nLet’s take a look to see if this is true.\n\nimport timeit\nfrom functools import partial\njit_test_func = jit(test_func)\n\nA_index, A_x = make_matrix(5)\ntimes = timeit.repeat(partial(jit_test_func, A_index, A_x, (2.0, 2.0)), number = 1)\nprint(f\"n = 5: {[round(t, 4) for t in times]}\")\n\nn = 5: [1.6695, 0.0001, 0.0, 0.0, 0.0]\n\n\nWe can see that the first run includes compilation time, but after that it runs a bunch faster. This is how a JIT system is supposed to work! But the question is: will it recompile when we run it for a different matrix?\n\n_ = jit_test_func(A_index, A_x, (2.0, 2.0)) \nA_index, A_x = make_matrix(20)\ntimes = timeit.repeat(partial(jit_test_func, A_index, A_x, (2.0, 2.0)), number = 1)\nprint(f\"n = 20: {[round(t, 4) for t in times]}\")\n\nn = 20: [38.5779, 0.0006, 0.0003, 0.0003, 0.0003]\n\n\nDamn. It recompiles. But, as we will see, it does not recompile if we only change A_x.\n\n# What if we change A_x only\n_ = jit_test_func(A_index, A_x, (2.0, 2.0)) \nA_x2 = tree_map(lambda x: x + 1.0, A_x)\ntimes = timeit.repeat(partial(jit_test_func, A_index, A_x2, (2.0, 2.0)), number = 1)\nprint(f\"n = 20, new A_x: {[round(t, 4) for t in times]}\")\n\nn = 20, new A_x: [0.0006, 0.0007, 0.0005, 0.0003, 0.0003]\n\n\nThis gives us some hope! This is because the structure of A (aka A_index) is fixed in our application, but the values A_x changes. So as long as the initial JIT compilation is reasonable, we should be ok.\nUnfortunately, there is something bad happening with the compilation. For \\(n=10\\), it takes (on my machine) about 2 seconds for the initial compilation. For \\(n=20\\), that increases to 16 seconds. Once \\(n = 30\\), this balloons up to 51 seconds. Once we reach the lofty peaks18 of \\(n=40\\), we are up at 149 seconds to compile.\nThis is not good. The function we are JIT-ing is very simple: just one tree_map. I do not know enough19 about the internals of JAX, so I don’t want to speculate too wildly. But it seems like it might be unrolling the tree_map before compilation, which is … bad."
  },
  {
    "objectID": "posts/2022-05-14-jax-ing-a-sparse-cholesky-factorisation-part-3-in-an-ongoing-journey/jax-ing-a-sparse-cholesky-factorisation-part-3-in-an-ongoing-journey.html#lets-admit-failure",
    "href": "posts/2022-05-14-jax-ing-a-sparse-cholesky-factorisation-part-3-in-an-ongoing-journey/jax-ing-a-sparse-cholesky-factorisation-part-3-in-an-ongoing-journey.html#lets-admit-failure",
    "title": "Sparse Matrices 3: Failing at JAX",
    "section": "Let’s admit failure",
    "text": "Let’s admit failure\nOk. So that didn’t bloody work. I’m not going to make such broad statements as you can’t use the JAX library in python to write a transformable sparse Cholesky factorisation, but I am more than prepared to say that I cannot do such a thing.\nBut, if I’m totally honest, I’m not enormously surprised. Even in looking at the very simple operation we focussed on today, it’s pretty clear that the operations required to work on a sparse matrix don’t look an awful lot like the types of operations you need to do the types of machine learning work that is JAX’s raison d’être.\nAnd it is never surprising to find that a library designed to do a fundamentally different thing does not easily adapt to whatever random task I decide to throw at it.\nBut there is a light: JAX is an extensible language. We can build a new JAX primitive (or, new JAX primitives) and manually write all of the transformations (batching, JIT, and autodiffing).\nAnd that is what we shall do next! It’s gonna be a blast!"
  },
  {
    "objectID": "posts/2021-11-03-yes-but-what-is-a-gaussian-process-or-once-twice-three-times-a-definition-or-a-descent-into-madness/yes-but-what-is-a-gaussian-process-or-once-twice-three-times-a-definition-or-a-descent-into-madness.html",
    "href": "posts/2021-11-03-yes-but-what-is-a-gaussian-process-or-once-twice-three-times-a-definition-or-a-descent-into-madness/yes-but-what-is-a-gaussian-process-or-once-twice-three-times-a-definition-or-a-descent-into-madness.html",
    "title": "Yes but what is a Gaussian process? or, Once, twice, three times a definition; or A descent into madness",
    "section": "",
    "text": "I guess I’m going to talk about Gaussian processes now. This wasn’t the plan but who really expected a) there to be a plan or b) me to stick to the plan. I feel like writing about Gaussian processes and so I shall! It will be grand."
  },
  {
    "objectID": "posts/2021-11-03-yes-but-what-is-a-gaussian-process-or-once-twice-three-times-a-definition-or-a-descent-into-madness/yes-but-what-is-a-gaussian-process-or-once-twice-three-times-a-definition-or-a-descent-into-madness.html#what-is-a-gaussian-process",
    "href": "posts/2021-11-03-yes-but-what-is-a-gaussian-process-or-once-twice-three-times-a-definition-or-a-descent-into-madness/yes-but-what-is-a-gaussian-process-or-once-twice-three-times-a-definition-or-a-descent-into-madness.html#what-is-a-gaussian-process",
    "title": "Yes but what is a Gaussian process? or, Once, twice, three times a definition; or A descent into madness",
    "section": "What is a Gaussian process?",
    "text": "What is a Gaussian process?\nWell I could tell you that a Gaussian process is defined by its joint distribution \\[\nu \\sim N(\\mu, \\Sigma),\n\\] where \\(u_i = u(s_i)\\), \\(\\mu_i = \\mu(s_i)\\) and \\(\\Sigma_{ij} = c(s_i, s_j)\\) for some positive definite covariance (or kernel) function \\(c(\\cdot, \\cdot)\\).\nBut that would be about as useful as presenting you with a dog that can bark “she’s a grand old flag”: perhaps good enough for a novelty hit, but there’s just no longevity in it.\nTo understand a Gaussian process you need to feel it deep down within you where the fear and the detailed mathematical concepts live.\nSo let’s try again."
  },
  {
    "objectID": "posts/2021-11-03-yes-but-what-is-a-gaussian-process-or-once-twice-three-times-a-definition-or-a-descent-into-madness/yes-but-what-is-a-gaussian-process-or-once-twice-three-times-a-definition-or-a-descent-into-madness.html#were-gonna-have-a-you-know-what.-im-not-gonna-do-that.-but-i-am-going-to-define-this-stuff-three-times.-once-for-mum-once-for-dad-and-once-for-the-country.",
    "href": "posts/2021-11-03-yes-but-what-is-a-gaussian-process-or-once-twice-three-times-a-definition-or-a-descent-into-madness/yes-but-what-is-a-gaussian-process-or-once-twice-three-times-a-definition-or-a-descent-into-madness.html#were-gonna-have-a-you-know-what.-im-not-gonna-do-that.-but-i-am-going-to-define-this-stuff-three-times.-once-for-mum-once-for-dad-and-once-for-the-country.",
    "title": "Yes but what is a Gaussian process? or, Once, twice, three times a definition; or A descent into madness",
    "section": "We’re gonna have a … you know what. I’m not gonna do that. But I am going to define this stuff three times. Once for mum, once for dad, and once for the country.",
    "text": "We’re gonna have a … you know what. I’m not gonna do that. But I am going to define this stuff three times. Once for mum, once for dad, and once for the country.\nYou’ve got to wonder why anyone would introduce something three ways. There are some reasons. The first is, of course, that each definition gives you a different insight into different aspects of Gaussian processes (the operational, the boundless generality, the functional). And the second is because I’ve had to use all three of these ideas (and several more) over the years in order to understand how Gaussian processes work.\nI learnt about GPs from several sources (listed not in order):\n\nA Swede1 (so I will rant about random fields in the footnotes eventually);\nA book2 that was introducing GPs in a very general way because they needed the concept in outrageous generality to answer questions about the distribution of the maximum of a Gaussian process;\nA book3 written by a Russian who’s really only into measure theory and doesn’t believe anything is real if it isn’t at least happening on a Frechet space;\nAnd a book4 by a different Russian who’s really only into generalised Markov properties and needed to work with Gaussian processes that are defined over functions.\n\nOf these, the most relevant is probably the first one. I was primarily taught this stuff by Finn Lindgren, who had the misfortune of having the office next to mine when we worked together in Trondheim a very long time ago. (We both had a lot more hair then.)\nOne of the things that I learnt from him is that Gaussian processes can appear in all kinds of contexts, which means you need to understand them as a model for an unknown function rather than as a tool to be used in a specific context (like for Gaussian process regression or Gaussian process classification).\nIt’s some effort to really get a good grip on the whole “Gaussian processes as a model for an unknown function” thing but once you relax into it5, it stops being alarming to see models where you are observing things that aren’t just \\(u(s_k)\\). It is not alarming when you are observing integrals of the GP over regions, or derivatives. And you (or your methods) don’t fall apart when presented with complex non-linear functions on the GP (as happens if you look at\nBayesian inverse problems literature6)."
  },
  {
    "objectID": "posts/2021-11-03-yes-but-what-is-a-gaussian-process-or-once-twice-three-times-a-definition-or-a-descent-into-madness/yes-but-what-is-a-gaussian-process-or-once-twice-three-times-a-definition-or-a-descent-into-madness.html#what-is-a-gaussian-process-version-1",
    "href": "posts/2021-11-03-yes-but-what-is-a-gaussian-process-or-once-twice-three-times-a-definition-or-a-descent-into-madness/yes-but-what-is-a-gaussian-process-or-once-twice-three-times-a-definition-or-a-descent-into-madness.html#what-is-a-gaussian-process-version-1",
    "title": "Yes but what is a Gaussian process? or, Once, twice, three times a definition; or A descent into madness",
    "section": "What is a Gaussian process? (Version 1)",
    "text": "What is a Gaussian process? (Version 1)\nI’m going to start with the most common definition of a Gaussian process7. This is the definition that was alluded to in the first section and it’s also the definition operationalised in books like Rasmussen and Williams’8, which is a bread and butter reference for most machine learners interested in GPs, use.\nThe idea is pretty straightforward: I need to define a stochastic model for an unknown function \\(u(s)\\) and I want it to be, in some sense, Gaussian. So how do I go about doing this?\nFirstly, I probably don’t care too much about the function as an abstract object. For example, if I’m using the Gaussian process to model something like temperature, I am only going to observe it at a fairly small number of places (even though I could choose any set of places I want). This means that for some arbitrary set set of \\(K\\) locations \\(s_1, s_2, \\ldots, s_K\\), I am most interested9 in understanding the joint distribution10 \\[\n(u(s_1), \\dots, u(s_K))^T.\n\\]\nSo how would we model the joint distribution? If we want the model to be tractable, we probably want a nice distribution. This is where the Gaussian part comes in. The Gaussian distribution is an extremely tractable11 distribution in medium-to-high dimensions. So the choice to model our joint distribution (which could be any size \\(K\\)) as \\[\n(u(s_1), \\dots, u(s_K))^T \\sim N\\left(\\mu_{s_1, \\ldots, s_K}, \\Sigma_{s_1, \\ldots, s_K}\\right),\n\\] makes sense from a purely mercenary position12.\nSo how do we choose the mean and the covariance function? We will see that the mean can be selected as \\([\\mu_{s_1, \\ldots, s_K}]_{k} = \\mu(s_k)\\) for pretty much any function13 \\(\\mu(\\cdot)\\), but, when we come to write \\[\n[\\Sigma_{s_1, \\ldots, s_K}]_{ij} = c(s_i, s_j),\n\\] there will be some very strong restrictions on the covariance function \\(c(\\cdot, \\cdot)\\).\nSo where do these restrictions come from?\n\nOh those (gay) Russians!\nAs with all things in probability, all the good shit comes from the Soviets. Kolmogorov14 was a leading light in the Soviet push to formalise probability and one of his many many many contributions is something called the Kolmogorov extension theorem, which gives the exact conditions under which we can go from declaring that the distributions of \\((u(s_1), \\ldots, u(s_K))^T\\) (these are called finite dimensional distributions) are Gaussian to describing a legitimate random function \\(u(s)\\).\nThere are essentially two conditions:\n\nThe order of the observations doesn’t matter in a material way. In our case changing the order just permutes the rows and columns of the mean vector and covariance matrix, which is perfectly ok.\nThere is a consistent way to map between the distributions of \\((u(s_1), \\ldots, u(s_K), u(s_{K+1}))^T\\) and \\((u(s_1), \\ldots, u(s_K))^T\\). This is the condition that puts a strong restriction on the covariance function.\n\nEssentially, we need to make sure that we have a consistent way to add rows and columns to our covariance matrix while ensuring that stays positive definite (that is, while all of the eigenvalues stay non-negative, which is the condition required for a multivariate normal distribution15). The condition—which is really gross—is that for every positive integer \\(K\\) and every set of points \\(s_1, \\ldots, s_k\\), and for every \\(a_1, \\ldots, a_K\\) not all equal to zero, we require that \\[\n\\sum_{i=1}^K \\sum_{j = 1}^K a_ia_j c(s_i, s_j) \\geq 0.\n\\]\nThis condition is obviously very difficult to check. This is why people typically choose their covariance function from a very short list16 that is typically found in a book on Gaussian processes."
  },
  {
    "objectID": "posts/2021-11-03-yes-but-what-is-a-gaussian-process-or-once-twice-three-times-a-definition-or-a-descent-into-madness/yes-but-what-is-a-gaussian-process-or-once-twice-three-times-a-definition-or-a-descent-into-madness.html#but-kolmogorov-said-a-little-bit-more",
    "href": "posts/2021-11-03-yes-but-what-is-a-gaussian-process-or-once-twice-three-times-a-definition-or-a-descent-into-madness/yes-but-what-is-a-gaussian-process-or-once-twice-three-times-a-definition-or-a-descent-into-madness.html#but-kolmogorov-said-a-little-bit-more",
    "title": "Yes but what is a Gaussian process? or, Once, twice, three times a definition; or A descent into madness",
    "section": "But Kolmogorov said a little bit more",
    "text": "But Kolmogorov said a little bit more\nThere’s a weird thing in grad school in North America where they insist on teaching measure theoretic probability theory and then never ever ever ever ever using any of the subtleties. But Gaussian processes (and, in general, stochastic processes on uncountable index spaces) are a great example of when you need these details.\nWhy? Because unlike discrete probability (where the set of events that we can compute the probability of is obvious) or even continuous random variables (where the events that we can’t compute the probability of are so weird we can truly just ignore them unless we are doing something truly exotic), for Gaussian processes,17 the set of allowable events is considerably smaller than the set of all things you might want probabilities of.\nThe gist of it is that we have built up a random function \\(u(s)\\) from a bunch of finite random vectors. This means that we can only assign probabilities to events that can be built up from events on finite random vectors. The resulting set of events (or \\(\\sigma\\)-algebra to use the adult term) is called the cylindrical18 \\(\\sigma\\)-algebra and can be roughly19 thought of as the set of all events that can be evaluated by evaluating \\(u(\\cdot)\\) at most a countable number of times."
  },
  {
    "objectID": "posts/2021-11-03-yes-but-what-is-a-gaussian-process-or-once-twice-three-times-a-definition-or-a-descent-into-madness/yes-but-what-is-a-gaussian-process-or-once-twice-three-times-a-definition-or-a-descent-into-madness.html#things-that-arent-measurable",
    "href": "posts/2021-11-03-yes-but-what-is-a-gaussian-process-or-once-twice-three-times-a-definition-or-a-descent-into-madness/yes-but-what-is-a-gaussian-process-or-once-twice-three-times-a-definition-or-a-descent-into-madness.html#things-that-arent-measurable",
    "title": "Yes but what is a Gaussian process? or, Once, twice, three times a definition; or A descent into madness",
    "section": "Things that aren’t measurable",
    "text": "Things that aren’t measurable\nThis will potentially become a problem if, for instance, you are working with a Gaussian process in a model that uses a Gaussian process in a weird way. When this happens, it is not guaranteed that, for instance, your likelihood is a measurable function, which would mean that you can’t normalise your probability distribution! (I mean, don’t worry. Unless you’re doing something fairly wild it will be, but it has come up especially in the inverse problems literature!)\nThis limited set of measurable events even seems to preclude well studied “events” like “\\(u\\) is continuous” or “\\(u\\) is twice continuously differentiable” or “\\(u\\) has a finite supremum”. All things that we a) want to know about a Gaussian process and b) things people frequently say about Gaussian processes. It is common for people to say that “Brownian motion is continuous” and similar things.\nAs with all of mathematics, there are a lot of work arounds that we can use. For those three statements in particular, there is some really elegant mathematical work (due, again, to Kolmogorov and extended greatly by others). The idea is that we can build another function \\(\\tilde u(s)\\) such that \\(\\Pr(u(s) = \\tilde u(s)) = 1\\) for all20 \\(s\\) such that \\(\\tilde u(s)\\) is continuous (or differentiable or bounded).\nIn the language of stochastic processes, \\(\\tilde u(s)\\) is called a version of \\(u(s)\\) and the more correct, temperate language (aka the one least likely to find in the literature) is that \\(u(s)\\) has a continuous/differentiable/bounded version.\nIf you’re interested in seeing how a differentiable version of a Gaussian process is constructed, you basically have to dick around with dyads for a while. Martin Hairer’s lecture notes21 is a nice clear example.\n\nWhere are the limitations of this definition?\nThere are a few. These are, of course, in the eye of the beer holder. The definition is workable in a lot of situations and, with some explanation can be broadened out a bit more. It’s less of a great definition when you’re trying to manipulate Gaussian processes as mathematical objects, but that’s what the next one is for.\nThe first limitation is maybe not so much a limit of the definition as a bit of work you have to do to make it applicable. And that is: what happens if I am observing (or my likelihood depends on) averages like \\[\n\\left(\\int_S \\ell_1(s) u(s)\\,ds, \\ldots, \\int_S \\ell_K(s) u(s)\\,ds\\right)^T\n\\] instead of simple point evaluations22.\nThis might seem like a massively different problem, until we remember that integrals are just sums dressed up for Halloween, so we can approximate the integrals arbitrarily well by sums23. In fact, if we squint24 a bit, we can see that the above vector will also be multivariate Gaussian with mean vector \\[\n[\\mu]_k = \\int_S \\ell_k(s) \\mu(s)\\,ds\n\\] and covariance matrix with entries \\[\n[\\Sigma]_{ij} = \\int_{S \\times S} \\ell_i(s) \\ell_j(s')c(s, s')\\,dsds'.\n\\] Similar formulas hold for derivative observations.\nProbably the bigger limitation is that in this way of seeing things, your view is tied very tightly to the covariance function. While it is a natural object for defining Gaussian processes, it is fucking inconvenient if you want to understand things like how well approximate Gaussian processes work.\nAnd let’s face it, a big chunk of Gaussian processes we see in practice are approximate because the computational burden on large data sets is too big to do anything but approximate.\n(Fun fact, when I was much much younger I wrote a paper that was a better title than a paper25 called26 In order to make spatial statistics computationally feasible, we need to abandon the covariance function. I copped a lot of shit for it at the time [partly because the title was better than the paper, but partly because some people are dicks], but I think the subsequent 10 years largely proved me (or at least my title) right27.)\nThe focus on the covariance function also hides the strong similarity between Gaussian process literature and the smoothing splines literature starting from Grace Wahba in the 1970s. It’s not that nobody notices this, but it’s work to get there!\nIn a similar way, it hides the fundamental role the reproducing kernel Hilbert space (or Cameron-Martin space) is doing and the ways that Gaussian process regression is (and is not) like kernel smoothing in RKHSs. This, again, isn’t a secret per se—you can find this information if you want it—but it’s confusing to people and the lack of clarity leads to people missing useful connections (or sometimes leads to them drawing mistaken parallels).\nHow many times have you seen someone say that realisations of a Gaussian process are in the RKHS associated with the covariance function? They are not. In fact, every realisation of a Gaussian process is rougher than any function in the RKHS (with probability 1)! Unfortunately, this means that your reason for choosing the kernel in a RKHS regression and for choosing the covariance function in a Gaussian process prior need to be subtly different. Or, to put it differently, a penalty is not a log-prior and interpreting the maximum a penalised likelihood is, in high dimensions, a very distant activity from interpreting a posterior distribution (even when the penalty is the log of the prior)."
  },
  {
    "objectID": "posts/2021-11-03-yes-but-what-is-a-gaussian-process-or-once-twice-three-times-a-definition-or-a-descent-into-madness/yes-but-what-is-a-gaussian-process-or-once-twice-three-times-a-definition-or-a-descent-into-madness.html#what-is-a-gaussian-process-version-2",
    "href": "posts/2021-11-03-yes-but-what-is-a-gaussian-process-or-once-twice-three-times-a-definition-or-a-descent-into-madness/yes-but-what-is-a-gaussian-process-or-once-twice-three-times-a-definition-or-a-descent-into-madness.html#what-is-a-gaussian-process-version-2",
    "title": "Yes but what is a Gaussian process? or, Once, twice, three times a definition; or A descent into madness",
    "section": "What is a Gaussian process? (Version 2)",
    "text": "What is a Gaussian process? (Version 2)\nOk. Let’s do this again. This definition lives in a considerably more mathematical space and while I’m gonna try to explain the key terms, I will fail. But hey. Who doesn’t like googling weird terms?\nA Gaussian process is a collection of random variables \\(u(s)\\), where \\(s \\in S\\) and \\(S\\) is some set of things that isn’t too topologically disastrous28.\nBut what makes it Gaussian? Here’s the general definition.\n\nA stochastic process/random field is Gaussian if and only if every continuous linear functional has a univariate Gaussian distribution.\n\n\nWell that’s very useful Daniel. What the hell is a linear functional?\nGreat question angry man who lives inside my head! It is any function \\(\\ell(\\cdot)\\) that takes the Gaussian process \\(u(s)\\) and an input and spits out a real number that is is\n\nLinear. Aka \\(\\alpha \\ell(u) + \\beta\\ell(v) = \\ell(\\alpha u + \\beta v)\\)\nBounded29.\n\nGreat. Love a definition. Shall we try something more concrete?\nPoint evaluation \\(u(s_j)\\) (aka evaluating the function at a point) is a linear functional (\\((u + v)(s)_j = u(s_j) + v(s_j)\\)). As is a definite integral over a set \\(\\int_A u(s)\\,ds\\).\nIt’s a fun little exercise to convince yourself that this all implies that for any collection \\(\\ell_1(\\cdot), \\ldots, \\ell_J(\\cdot)\\) of continuous linear functionals, then \\(u(s)\\) is a Gaussian process means that the vector \\[\n(\\ell_1(u), \\ldots \\ell_J(u))^T\n\\] is multivariate Gaussian.\nYour idea of fun is not my idea of fun. Anyway. Keep talking.\nIf \\(u\\) lives in a Banach space30 \\(B\\), then the set of all continuous/bounded linear functionals on \\(B\\) is called the dual space and is denoted \\(B^*\\).         \n\n\nI mean, cool I guess but where the merry hell is the covariance function\nIn this context, the most important thing about \\(B^*\\) is it does double duty: it is both a space of linear functionals and a space that can be identified with random variables.\nHow the fuck do you do that?\nWell, the trick is to remember the definition! If \\(\\ell \\in B^*\\), then \\(\\ell(u)\\) is a Gaussian. Similarly, if we have two functionals \\(\\ell, \\ell' \\in B^*\\) we consider the covariance of their associated random variables \\[\nC_u(\\ell, \\ell') = \\mathbb{E}(\\ell(u)\\ell'(u)).\n\\]\n\\(C_u(\\ell, \\ell')\\) is a symmetric, positive definite bilinear form (aka good candidate for an inner product)!\nWe can use this to add more functions to \\(B^*\\), particularly for any sequence \\(b_n \\in B^*\\) that is Cauchy with respect to the norm \\(\\|\\ell\\|_{R_u} = \\sqrt{C_u(\\ell, \\ell)}\\) we append the limit to \\(B^*\\) to complete the space. Once we take equivalence classes, we end up with a Hilbert space \\(R_u\\) that, very unfortunately, probabilists have a tendency to call the reproducing kernel Hilbert space associated with \\(u\\).\nWhy is this unfortunate? Well primarily because it’s not the exact same space that machine learners call the reproducing kernel Hilbert space, which is, to put it mildly, confusing. But we can build the machine learner’s RKHS (known to probabilists as the Cameron-Martin space).\nWhy are you even telling me this? Is this a digression?\nHonestly. Yes. But regardless the space \\(R_u\\) is quite useful to understand what’s going on. To start off, let’s do one example that shows just how different a Gaussian process is from a multivariate normal random vector. We will show that if we multiply a GP by a constant, we completely change its support31! Many a computational and inferential ship have come to grief on these sharp rocks.\nTo do this, though, we need32 to make an assumption on \\(B\\): We assume that \\(B\\) is separable33. This isn’t an vacuous assumption, but in a lot of cases of practical interest, this is basically the same thing as assuming the set \\(S\\) is a nice bounded domain or a friendly compact manifold (and not something like \\(\\mathbb{R}^d\\))34.\nSo. How do we use \\(R_u\\) to show that Gaussian processes are evil? Well we begin by noting that \\(R_u\\) is a separable35 Hilbert space it contains an orthonormal basis \\(e_n\\), \\(n=1, \\ldots, \\infty\\) (that is \\(\\|e_n\\|_{R_u} = 1\\) and \\(\\langle e_n, e_m\\rangle_{R_u} = 0\\) if \\(n\\neq m\\)). We can use this basis to show some really really weird stuff about \\(u(s)\\).\nIn particular, consider another Gaussian process \\(v(s) = c u(s)\\), where \\(c\\) is a non-zero constant. For this process we can build \\(R_v\\) in an analogous way. The \\(e_n\\) are still orthogonal in \\(R_v\\) but now \\(\\|e_n\\|_{R_v} = c^2\\).\nNow consider the functional \\(X_K(\\cdot) = K^{-1}\\sum_{k = 1}^Ke_i(\\cdot)^2\\). We are going to use this function to break stuff! To do this, we are going to define two disjoint sets of functions \\(A_1 = \\{u: \\lim_{K\\rightarrow \\infty} X_K(u) = 1\\}\\) and \\(A_2 = \\{u: \\lim_{K\\rightarrow \\infty} X_K(u) = c^2\\}\\). Clearly \\(A_1\\) and \\(A_2\\) are disjoint if \\(|c|\\neq 1\\).\nBecause \\(e_n(\\cdot)\\) are orthonormal in \\(R_u\\), it follows that that \\(u_n = e_n(u) \\sim N(0,1)\\) are iid. Similarly, \\(v_n = e_n(v) \\sim N(0, c^2)\\) are also independent. Hence it follows from the properties of \\(\\chi^2\\) random variables (aka the mean plus the strong law of large numbers) that \\(X_K(u) \\rightarrow 1\\) and hence \\(\\Pr(u \\in A_1) = 1\\). On the other hand, \\(X_K(v) \\rightarrow c^2\\), so \\(\\Pr(v \\in A_2) = 1\\). As \\(A_1\\) and \\(A_2\\) are disjoint, this means that unless \\(|c|=1\\), the processes \\(u\\) and \\(v\\) are mutually singular (aka they have no overlapping support).\nWhat does this mean? This means the distributions of \\(u\\) and \\(v\\) (which remember is just \\(u\\) multiplied by a constant) are as different from each other as a normal distribution truncated to \\((-\\infty, 1)\\) and another normal distribution truncated to \\((1, \\infty)\\)! Or, more realistically36, as disjoint as a distribution over \\(2\\mathbb{Z}\\) and \\((2\\mathbb{Z} - 1)\\).\nThis is an example of the most annoying phenomena in Gaussian processes37: the slightest change in a Gaussian process can lead to a mutually singular process. In fact, this is not a particularly strange example. It can be shown that Gaussian processes over uncountable index spaces are either absolutely continuous or mutually singular. There is no half-arsing it!\nThis has a lot of implications when it comes to computing38, setting priors on the parameters that control the properties of the covariance function39, and just generally inference40.\n\n\nYes but where’s our reproducing kernel Hilbert space\nWe just saw that if \\(u\\) is a Gaussian process than \\(c u\\) will be a singular GP if \\(|c| \\neq 1\\). What happens if we add things? Well, a result known as the Cameron-Martin theorem says that, for a deterministic \\(h(s) \\in B\\), \\(u(s) + h(s)\\) is absolutely continuous wrt \\(u(s)\\) if and only if \\(h(s)\\) is in the Cameron-Martin space \\(H_u\\) (this is the one that machine learners call the RKHS!).\nBut how do we find this mythical space? I find this quite stressful!\nLike, honey I do not know. But when a probabilist is in distress, we can calm them by screaming characteristic function at the top of our lungs right into their ear. Try it. It definitely works. You won’t be arrested.\nSo let’s do that. The characteristic function of a univariate random variable \\(X\\) is \\[\n\\phi_X(t) = \\mathbb{E}\\left(e^{itX}\\right),\n\\] which doesn’t seem like it’s going to be an amazingly useful thing, but it actually is. It’s how you prove the central limit theorem41, and a few other shiny things.\nWhen we are dealing with more complex random things, like random vectors and Gaussian processes, we can use characteristic functions, but we need to extend beyond the fact that they’re currently only defined for univariate random variables. Conveniently, we have some lying around. In particular, if \\(\\ell \\in B^*\\), we have the associated random variable \\(\\ell(u)\\) and we can compute its characteristic function42, which leads to the definition of a characteristic function of a stochastic process on \\(B\\) \\[\n\\phi_u(\\ell) = \\mathbb{E}(e^{i\\ell(u)}), \\quad \\ell \\in B^*.\n\\]\nNow this feels quite different. It’s no longer a function of some real number \\(t\\) but is instead a function of a linear functional \\(\\ell\\), which feels weird but isn’t.\nCharacteristic functions are immensely useful because if two Gaussian processes have same characteristic function they have the same distribution43.\nBecause \\(u(s)\\) is a Gaussian process, we can compute its characteristic function! We know that \\(\\ell(u)\\) is Gaussian so we can look up its characteristic function on Wikipedia and get that \\[\n\\mathbb{E}(e^{i\\ell(u)}) = \\exp\\left[{i \\mu(\\ell) - \\frac{\\sigma^2(\\ell)}{2}}\\right],\n\\] where \\(\\mu(\\ell) = \\mathbb{E}(\\ell(u))\\) and \\(\\sigma^2(\\ell) = \\mathbb{E}(\\ell(u) - \\mu(\\ell))^2\\).\nWe know that \\[\n\\mu(\\ell) = \\mathbb{E}(\\ell(u))\n\\] and \\[\n\\sigma^2(\\ell) = \\mathbb{E}\\left[(\\ell(u) - \\mu(\\ell)^2\\right],\n\\] the latter of which can be extended naturally to the aforementioned positive definite quadratic form \\[\nC_u(\\ell, \\ell') = \\mathbb{E}\\left[(\\ell(u) - \\mu(\\ell)(\\ell'(u) - \\mu(\\ell'))\\right], \\quad \\ell, \\ell' \\in B^*.\n\\]\nThis leads to the exact form of the characteristic function and to this theorem, which is true.\n\nTheorem 1 A stochastic process \\(u(\\cdot)\\) is a Gaussian process if and only if \\[\n\\phi_u(\\ell) = \\exp\\left[i\\mu(\\ell) - \\frac{1}{2}C_u(\\ell, \\ell)\\right].\n\\]\n\nSo Alf is back. In pog form.\nYes.\nIn this case, we can define the covariance operator \\(C_u: B^* \\rightarrow B\\) as44 \\[\n(C_u \\ell) (\\ell') = \\mathbb{E}\\left[(\\ell(u) - \\mu(\\ell)(\\ell'(u) - \\mu(\\ell'))\\right].\n\\] The definition is cleaner when \\(\\mu(\\ell) = 0\\) (which is why people tend to assume that when writing this shit down45), in which case we get \\[\nC_u\\ell = \\mathbb{E}(u\\ell(u))\n\\] and \\[\nC_u(\\ell, \\ell') = \\ell'(C_u\\ell)\n\\]\nGreat gowns, beautiful gowns.\nWow. Shady.\nAnyway, the whole reason to introduce this is the following:\n\nTheorem 2 Let \\(v = x + h\\). Then \\[\n\\phi_v(\\ell) = e^{i\\ell(h)}\\phi_u(\\ell).\n\\]\n\nThis does not not help us answer the question of whether or not \\(v\\) has the same support as \\(u\\). To do this, we construct a variable that is absolutely continuous with respect to \\(u\\) (we guarantee this because we specify its density46 wrt \\(u\\)).\nTo this end, take some \\(g \\in R_u\\) and define a stochastic process \\(w\\) with density wrt47 u \\[\n\\rho(u) = \\exp\\left[iC_u(g, u) - \\frac{1}{2}C_u(g,g)\\right].\n\\]\nFrom this, we can compute48 the characteristic function of \\(w\\) \\[\\begin{align*}\n\\phi_w(\\ell) &= \\mathbb{E}_w\\left(e^{i\\ell(w)}\\right) \\\\\n&= \\mathbb{E}_u\\left(\\rho(u) e^{i\\ell(u)}\\right) \\\\\n&= \\exp\\left[iC_u(g,\\ell) + i \\mu(\\ell)  - \\frac{1}{2}C_u(\\ell, \\ell)\\right]\n\\end{align*}\\]\nSo we are fine if we can find some \\(h \\in B\\) such that \\[\nC_u(g, \\ell) = \\ell(h).\n\\]\nTo do this, we note that \\[\nC_u(g, \\ell) = \\ell(C_u g),\n\\] so for any \\(g\\) we can find a \\(h \\in B\\) such that \\(h = C_ug\\) and for such a \\(h\\) \\(v(s) = u(s) + h(s)\\) is absolutely continuous with respect to \\(u(s)\\).\nThis gives us our definition of the Cameron-Martin space (aka the RKHS) associated with \\(u\\).\n\nDefinition 1 The Cameron-Martin space (or reproducing kernel Hilbert space, if you must) associated with a Gaussian process \\(u\\) is the Hilbert space \\(H_u = \\{h\\in B: h = C_uh^* \\text{ for some } h^* \\in R_u\\}\\) equipped with the inner product \\[\n\\langle h, h'\\rangle_{H_u} = C_u(h^*, (h')^*)\n\\]\n\nA fun note is that the reason the probabilists don’t call the Cameron-Martin space the reproducing kernel Hilbert space is that there is no earthly reason to think that point evaluation will be bounded in general. So it become a problematique name. (And no, I don’t know why they’re ok with calling \\(R_u\\) that some things are just mysterious.)\nLord in heaven. Any chance of being a bit more concrete?\nSure! Let’s consider the case where \\(u \\in \\mathbb{R}^n\\) is a Gaussian random vector \\[\nu \\sim N(\\mu, \\Sigma).\n\\] While all of this is horribly over-powered for this case, it does help get a grip on what the inner product on \\(H_u\\) is.\nIn this case, \\(B^*\\) is row vectors like \\(f^T\\), \\(f\\in \\mathbb{R}^n\\) and \\[\nC_u(f^T, g^T) = \\operatorname{Cov}(f^Tu, g^Tu) = f^T\\Sigma g.\n\\]\nFurthermore,     the operator \\(C_u = \\Sigma f\\) satisfies \\(g^T(\\Sigma f) = C_u(f^T,g^T)\\).\nSo what is \\(H_u\\)? Well, every \\(n\\) dimensional vector space can be represented as an \\(n\\)-dimensional vector, so what we really need to do is identify \\(h^*\\) from \\(h\\). To do this, we use the relationship \\(C(h^*, \\ell) = \\ell(h)\\) for all \\(\\ell \\in B^*\\). Translating that to our finite dimensional case we get that \\[\n(h^*)^T\\Sigma g = h^T g,\\qquad g \\in \\mathbb{R}^n,\n\\] from which it follows that \\(h^* = \\Sigma^{-1}h\\). Hence we get the inner product between \\(h, k \\in H_u\\) \\[\\begin{align*}\n\\langle h, k\\rangle_{H_u} &= \\langle h^*, k^*\\rangle_{R_h} \\\\\n&= (\\Sigma^{-1} h)^T \\Sigma (\\Sigma^{-1 k}) \\\\\n&= h^T \\Sigma^{-1} k.\n\\end{align*}\\]\nOk! That’s cool!\nYes! And the same thing holds in general, if you squint49. Just replace the covariance matrix \\(\\Sigma\\) with the covariance operator \\[\n(\\mathcal{C}f)(s) = \\int_S c(s, s') f(s') \\, ds'.\n\\]\nThis operator has (in a suitable sense) a symmetric50 non-negative definite (left) (closed) inverse operator \\(\\mathcal{Q}\\), which defines the RKHS inner product by \\[\n\\langle f, g \\rangle_{H_u} = \\int_{S} f(s) (\\mathcal{Q} g)(s) \\,ds,\n\\] where \\(f\\) and \\(g\\) are smooth enough functions for this to make sense. In general, \\(\\mathcal{Q}\\) will be a (very) singular integral operator, but when \\(u(s)\\) has the Markov property, \\(\\mathcal{Q}\\) is a differential operator. In all of these cases the RKHS is the set of functions that are smooth enough that \\(\\langle f, f \\rangle_{H_u} < \\infty\\).\nWe sometimes call the operator \\(\\mathcal{Q}\\) the precision operator and it’s fundamental to thin plate spline theory as well as some nice ways to approximate GPs in 1-4 dimensions. I will blog about this later, probably, but for now if you’re interested Finn Lindgren, Håvard Rue, and David Bolin just released a really nice survey paper about the technique.\n\n\nTell me some things about the Cameron-Martin space\nNow that we’ve gone to the effort of finding it, I should probably tell you why it’s so important. So here are a collection of facts!\nFact 1: The Cameron-Martin space (the set of functions and the inner product) determines a51 Gaussian process, in that if two Gaussian processes have the same mean and the the same Cameron-Martin space, they have the same distribution. In fact, the next definition of a Gaussian process is going to show this constructively.\nThis is nice because it means you can define a Gaussian process without needing to specify its covariance function. You just (just!) need to specify a Hilbert space. It turns out that this is a considerably easier task than trying to find a positive definite covariance function if the domain \\(S\\) is weird.\nFact 2: \\(u(s)\\) is never in the RKHS. That is, \\(\\Pr(u \\in H_u) = 0\\). But52 if, for any \\(\\epsilon>0\\), \\(A_\\epsilon \\subset B\\) is any measurable set of functions with \\(\\Pr(u \\in A) = \\epsilon\\), then \\(\\Pr(u \\in A_\\epsilon + H_u) = 1\\), where \\(A_\\epsilon+H_u = \\{a + h \\in B: a\\in A_\\epsilon, h \\in H_u\\}\\). Or to say it in words, although \\(u\\) is never in \\(H_u\\), if you find a set \\(A_\\epsilon\\) that \\(u\\) could be in (even if it’s extremely unlikely to be there), then \\(u\\) is almost surely made up of a function in \\(A_\\epsilon\\) plus a function in \\(H_u\\).\nThis is wild. It means that while \\(u(\\cdot)\\) is never in the RKHS, all you need to do is add a bit of rough to get all of the stuff out. Another characterisation of the RKHS that are related to this is that it is the intersection of all subsets of \\(B\\) that have full measure under \\(u\\) (aka all sets \\(A\\subset B\\) such that \\(\\Pr(u \\in A) = 1\\)).\nFact 3: If we observe some data \\(y = N(Tu, \\Sigma_y)\\), where \\(Tu = (\\ell_1(u),\\ldots, \\ell_n(u))^T\\) is some observation vector, then the posterior mean \\(\\mathbb{E}(u \\mid y)\\) is in the RKHS and that posterior distribution of \\(u\\mid y\\) is a Gaussian process that’s absolutely continuous with respect to the prior GP u(s). This means that the posterior mean, which is our best point prediction under squared error loss, is always smoother than any of the posterior draws.\nThis kinda makes sense: averaging things smooths out the rough edges. And so when we average a Gaussian process in this way, we make it smoother. But this is a thing that we need to be aware of! Our algorithms, our reasoning for choosing a kernel, and our interpretations of the posterior need to be aware that the space of posterior realizations \\(B\\) is rougher than the space that contains the posterior mean.\nFrequentists / people who penalise likelihoods don’t have to worry about this shit."
  },
  {
    "objectID": "posts/2021-11-03-yes-but-what-is-a-gaussian-process-or-once-twice-three-times-a-definition-or-a-descent-into-madness/yes-but-what-is-a-gaussian-process-or-once-twice-three-times-a-definition-or-a-descent-into-madness.html#so-what-have-we-learnt",
    "href": "posts/2021-11-03-yes-but-what-is-a-gaussian-process-or-once-twice-three-times-a-definition-or-a-descent-into-madness/yes-but-what-is-a-gaussian-process-or-once-twice-three-times-a-definition-or-a-descent-into-madness.html#so-what-have-we-learnt",
    "title": "Yes but what is a Gaussian process? or, Once, twice, three times a definition; or A descent into madness",
    "section": "So what have we learnt?",
    "text": "So what have we learnt?\nSo so so so so so so much notation and weird maths shit.\nBut there are three take aways here:\n\nThe importance of the Fourier transform (aka the characteristic function) when it comes to understanding Gaussian processes.\nThe maths buys us understanding of some of the more delicate properties of a Gaussian process as a random object (in particular it’s joint properties)\nYou can define a Gaussian process exclusively using the RKHS inner product. (You can also do all of the computations that way too, but we’ll cover that later). So you do not need to explicitly specify a covariance function. Grace Wahba started doing this with thin plate splines (and \\(L\\)-splines) in 1974 and it worked out pretty well for her.\n\nSo to finish off this post, let’s show one more way of constructing a Gaussian process. This time we will explicitly start from the RKHS."
  },
  {
    "objectID": "posts/2021-11-03-yes-but-what-is-a-gaussian-process-or-once-twice-three-times-a-definition-or-a-descent-into-madness/yes-but-what-is-a-gaussian-process-or-once-twice-three-times-a-definition-or-a-descent-into-madness.html#what-is-a-gaussian-process-version-3",
    "href": "posts/2021-11-03-yes-but-what-is-a-gaussian-process-or-once-twice-three-times-a-definition-or-a-descent-into-madness/yes-but-what-is-a-gaussian-process-or-once-twice-three-times-a-definition-or-a-descent-into-madness.html#what-is-a-gaussian-process-version-3",
    "title": "Yes but what is a Gaussian process? or, Once, twice, three times a definition; or A descent into madness",
    "section": "What is a Gaussian process? (Version 3)",
    "text": "What is a Gaussian process? (Version 3)\nOur final Gaussian process definition is going to centre the RKHS53 as the fundamental object. This construction, which is known as an abstract Wiener space54 is less general55 than our previous definition, but it covers most of the processes we are going to encounter in applications.\nThis construction is by far the most abstract of the three (it is in the name after all). So buckle up.\nThe jumping off point here is a separable Hilbert space \\(H\\). This has an inner-product \\(\\langle\\cdot, \\cdot \\rangle_H\\) on it, and the associated notion of orthogonality and an orthogonal projector. Consider an \\(n\\)-dimensional subspace \\(V_n \\subset H_u\\). We can, without any trouble, define a Gaussian process on \\(V_n\\) \\(\\tilde u_n\\) with characteristic function \\[\n\\phi_{\\tilde u_n}(h) = \\exp\\left(-\\frac{1}{2}\\langle h,h\\rangle_H\\right).\n\\] We hit no mathematical problems because \\(V_n\\) is finite dimensional and nothing weird happens to Gaussians in finite dimensions.\nThe thing is, we can do this for any finite dimensional subspace \\(V_n\\) and, in particular, if we have a sequence of subspace \\(V_1 \\subset V_2 \\subset \\ldots\\), where \\(\\operatorname{dim}(V_n) =n\\), then we can build a sequence of finite dimensional Gaussian processes \\(\\tilde u_n\\) that are each supported in their respective \\(V_n\\).\nThe question is: can we construct a Gaussian process \\(\\tilde{u}\\) supported56 on \\(H\\) such that \\(P_n \\tilde u \\stackrel{d}{=} \\tilde u_n\\), where \\(P_n\\) is the orthogonal projector from \\(H\\) to \\(V_n\\)?\nYou would think the answer is yes. It is not. In fact, Komolgorov’s extension theorem says that we can build a Gaussian process this way, but it does not guarantee that the process will be supported on \\(H\\). And it is not.\nTo see why this is, we need to look a bit more carefully at the covariance operator of a Gaussian process on a separable Hilbert space. The key mathematical feature of a separable Hilbert space is that it has an57 orthonormal58 basis \\(e_n\\). We can use the orthonormal basis to do a tonne of things, but the one we need right now is the idea of a trace59 \\[\n\\operatorname{tr}(C_u) = \\sum_{n = 1}^\\infty C_u(e_i, e_i).\n\\]\nFor a (zero mean) Gaussian process \\(u\\) supported on \\(H\\), we can see that \\[\\begin{align*}\n\\operatorname{tr}(C_u) &= \\sum_{n = 1}^\\infty \\mathbb{E}\\left[(\\langle e_n, u\\rangle)^2\\right] \\\\\n&= \\mathbb{E}\\left[ \\sum_{n = 1}^\\infty\\langle e_n, u\\rangle_H^2\\right] \\\\\n&= \\mathbb{E}\\left[\\langle u, u\\rangle_H\\right] < \\infty,\n\\end{align*}\\] where the second line is just true because I say it is and the third line is Pythagoras’ theorem writ large (and is finite because Gaussian processes have a lot of moments60!).\nIf we were to say this in words, we would say that the covariance operator of a Gaussian process supported on a separable Hilbert space is a trace-class operator (or has a finite trace).\nAnd this is where we rejoin the main narrative. You see, if \\(\\tilde{u}\\) was a stochastic process on \\(H\\), then its characteristic function would be \\[\n\\phi_{\\tilde u}(h) = \\exp\\left(-\\frac{1}{2}\\langle h, h \\rangle_H\\right).\n\\] But it can’t be! Because \\(H\\) is infinite dimensional and the proposed covariance operator is the identity on \\(H\\), which is not trace class (its trace is clearly infinite).\nSo whatever \\(\\tilde u\\) is61, it is emphatically not a Gaussian process on \\(H\\).\n\nThat doesn’t seem like a very useful trip through abstract land\nWell, while we did not successful make a Gaussian process on \\(H\\) we did actually build the guts of a Gaussian process on a different space. The trick is to use the same idea in reverse. We showed that \\(\\tilde u\\) was not a Gaussian process because its covariance operator wasn’t on trace class. It turns out that the reverse also holds: if \\[\n\\phi_u(h) = \\exp\\left(-\\frac{1}{2}\\langle C_uh, h\\rangle_{H'}\\right)\n\\] and \\(C_u\\) is trace class on \\(H'\\), then \\(u\\) is a Gaussian process supported on \\(H'\\).\nThe hard part is going to be finding another Hilbert space \\(H' \\supset H\\).\nTo do this, we need to recall a definition of a separable Hilbert space \\(H\\) with orthonormal basis \\(e_n\\), \\(n=1, \\ldots, \\infty\\): \\[\nH = \\left\\{\\sum_{n=1}^\\infty a_n e_n: \\sum_{n=1}^\\infty a_n^2 < \\infty\\right\\}.\n\\] From this, we can build a larger separable Hilbert space \\(H'\\) as \\[\nH' = \\left\\{\\sum_{n=1}^\\infty a_n e_n: \\sum_{n=1}^\\infty \\frac{a_n^2}{n^2} < \\infty\\right\\}.\n\\] This is larger because there are sequences of \\(a_n\\)s that are admissible for \\(H'\\) that aren’t admissible for \\(H\\) (for example62, \\(a_n = \\sqrt{n}\\)).\nWe let \\(j:H \\rightarrow H'\\) be the linear embedding that we get by considering an element \\(h \\in H\\) as an element of \\(H'\\). If we let \\(e_n'\\) be an orthonormal basis on \\(H'\\) (note: this is not the same as \\(e_n\\) as it needs to be re-scaled to have unit norm in \\(H'\\)), then we get \\[\nj\\left(\\sum_{n=1}^\\infty \\alpha_n e_n\\right) = \\sum_{n=1}^\\infty  \\frac{\\alpha_n}{n} e_n'.\n\\] Why? Because \\(\\|e_n\\|_{H'} = n^{-1}\\) which means that \\(e_n' = n e_n\\) is an orthonormal basis for \\(H'\\). This means we have to divide the coefficients by \\(n\\) when we move from \\(H\\) to \\(H'\\), otherwise we wouldn’t be representing the same function.\nWith this machinery set up, we can ask if \\(\\tilde u\\) is a Gaussian process on \\(H'\\). Or, more accurately, we can ask if \\(u = j(\\tilde u)\\) is a Gaussian process on \\(H\\).\nWell.\nLet’s compute its characteristic function. \\[\\begin{align*}\n\\phi_u(h') &= \\mathbb{E}\\left(e^{i\\left\\langle u, h' \\right\\rangle_{H'}}\\right) \\\\\n&= \\mathbb{E}\\left[\\exp\\left(i\\left\\langle \\sum_{n=1}^\\infty \\frac{\\langle \\tilde u, e_n\\rangle_H}{n}e_n', \\sum_{n=1}^\\infty h_n'e_n' \\right\\rangle_{H'}\\right) \\right] \\\\\n&= \\mathbb{E}\\left[\\exp\\left(i \\sum_{n=1}^\\infty \\frac{\\langle \\tilde u, e_n\\rangle}{n} h_n\\right) \\right] \\\\\n&= \\exp\\left(-\\frac{1}{2} \\sum_{n=1}^\\infty \\frac{h_n^2}{n^2}\\right).\n\\end{align*}\\] It follows that \\(\\phi_u(e_n') = e^{-1/(2n^2)}\\) and so63 \\[\n\\operatorname{tr}(C_u) = -2\\sum_{n=1}^\\infty \\log \\phi_u(e_n') = \\sum_{n=1}^\\infty \\frac{1}{n^2} < \\infty,\n\\] \\(C_u\\) is a trace class operator on \\(H'\\) and, therefore, \\(u\\) is a Gaussian process on \\(u\\).\nBut wait, there is more! To do the calculation above, we identified elements of \\(H'\\) as infinite sequences \\(h' = (h'_1, h'_2, \\ldots)\\) that satisfy \\(\\sum_{n=1}^\\infty n^{-2}h_n^2 < \\infty\\). In this case the covariance operator is \\(C_{u}\\) is diagonal, so the \\(n\\)th entry of \\(C_u h' = n^{-2}h'_n\\). From this, and the reasoning in the previous section, we see that the Cameron-Martin space can be thought of as a subset of \\(H'\\). The Cameron-Martin inner product can be constructed from the inverse of \\(C_u\\), which gives \\[\n\\langle a, b\\rangle_{H_u} = \\sum_{i=1}^\\infty n^2 a_n b_n.\n\\] Clearly, this will not be finite unless we put much much stronger restrictions on \\(a_n\\) and \\(b_n\\) than that \\(\\sum_{n\\geq 1} n^{-2}a_n^2 < \\infty\\).\nThe Cameron Marin space is the subspace of \\(H'\\) consisting of all functions \\(h' = \\sum_{n=1}^\\infty a_n e_n'\\) such that \\[\n\\sum_{n=1}^\\infty n^2a_n^2 < \\infty.\n\\] This is (isomorphic to) \\(H\\)!\nTo see this, we note that the condition is only going to hold if \\(a_n = n^{-1}\\alpha_n\\) for some sequence \\(\\alpha_n\\) such that \\(\\sum_{n\\geq 1} \\alpha_n^2 < \\infty\\). Remembering that \\(e_n' = n e_n\\), it follows that \\(h \\in H_u\\) if and only if \\[\\begin{align*}\nh &= \\sum_{n=1}^n\\frac{\\alpha_n}{n} e_n' \\\\\n&=\\sum_{n=1}^n\\frac{\\alpha_n}{n} n e_n \\\\\n&=\\sum_{n=1}^n \\alpha_n e_n,\n\\end{align*}\\] which is exactly the definition of \\(H\\).\n\n\nAre you actually trying to kill me?\nYes.\nSo let’s recap what we just did: We took a separable Hilbert space \\(H\\) and used it to construct a Gaussian process on a larger space \\(H'\\) with \\(H\\) as its Cameron-Martin space. And we did all of this without ever touching a covariance function. This is an abstract Wiener space construction of a Gaussian process.\nThe thing is that this construction is a lot more general than this. The following is a (simplified64) version of the abstract Wiener space theorem.\n\nTheorem 3 Let \\(H\\) be a separable Hilbert space and let \\(B\\) be a separable Banach space. Furthermore, we assume that \\(H\\) is dense in \\(B\\). Then there is a unique Gaussian process \\(u\\) with \\(\\Pr(u \\in B) = 1\\) and \\(H_u = H\\). It can be constructed from the canonical cylindrical Gaussian process \\(\\tilde u\\) on \\(H\\) by \\(u = j(\\tilde u)\\), where \\(j:H \\rightarrow E\\) is the natural embedding.\n\n\n\nWas there any point to doing that?\nI mean, probably not. The main thing we did here was see that you can take the RKHS as the primal object when building a Gaussian process. Why that may be a useful observation was not covered.\nWe also saw that there are some restrictions required on the covariance operator to ensure that a Gaussian process is a proper stochastic process on a given space. (For the tech-heads, the problem with \\(\\tilde u\\) is that it’s associated probability measure is not countably additive. That is a bad thing, so we do not allow it.)\n\nThe restrictions are very clear for covariance operators on separable Hilbert spaces (they must be trace class). Unfortunately, there isn’t any clean characterization of all allowable covariance operators on more complex spaces like Banach spaces65."
  },
  {
    "objectID": "posts/2021-11-03-yes-but-what-is-a-gaussian-process-or-once-twice-three-times-a-definition-or-a-descent-into-madness/yes-but-what-is-a-gaussian-process-or-once-twice-three-times-a-definition-or-a-descent-into-madness.html#where-do-we-go-now-but-nowhere",
    "href": "posts/2021-11-03-yes-but-what-is-a-gaussian-process-or-once-twice-three-times-a-definition-or-a-descent-into-madness/yes-but-what-is-a-gaussian-process-or-once-twice-three-times-a-definition-or-a-descent-into-madness.html#where-do-we-go-now-but-nowhere",
    "title": "Yes but what is a Gaussian process? or, Once, twice, three times a definition; or A descent into madness",
    "section": "Where do we go now but nowhere",
    "text": "Where do we go now but nowhere\nAnd with that I have finished my task. I have defined Gaussian processes three different ways and if anyone is still reading at this point: you’re a fucking champion.\nI probably want to talk about other stuff eventually:\n\nUsing all this technology to work out what happens to a posterior when we approximate a Gaussian process (which we usually do for computational reasons)\nUnderstanding how singularity/absolute continuity of Gaussian measures can help you set priors for the parameters in a covariance function\nThe Markov property in space: what is it and how do you use it\nShow how we can use methods for solving PDEs to approximate Gaussian processes.\n\nThe last one has gotten a lot less urgent because Finn, David and Håvard just released a lovely survey paper.\nMaybe by the time I am finished with these things (if that ever happens, I don’t rate my chances), I will have justified all of this technicality. But for now, I am done."
  },
  {
    "objectID": "posts/2022-05-20-to-catch-a-derivative-first-youve-got-to-think-like-a-derivative/to-catch-a-derivative-first-youve-got-to-think-like-a-derivative.html",
    "href": "posts/2022-05-20-to-catch-a-derivative-first-youve-got-to-think-like-a-derivative/to-catch-a-derivative-first-youve-got-to-think-like-a-derivative.html",
    "title": "Sparse matrices 6: To catch a derivative, first you’ve got to think like a derivative",
    "section": "",
    "text": "Welcome to part six!!! of our ongoing series on making sparse linear algebra differentiable in JAX with the eventual hope to be able to do some cool statistical shit. We are nowhere near done.\nLast time, we looked at making JAX primitives. We built four of them. Today we are going to implement the corresponding differentiation rules! For three1 of them.\nSo strap yourselves in. This is gonna be detailed.\nIf you’re interested in the code2, the git repo for this post is linked at the bottom and in there you will find a folder with the python code in a python file."
  },
  {
    "objectID": "posts/2022-05-20-to-catch-a-derivative-first-youve-got-to-think-like-a-derivative/to-catch-a-derivative-first-youve-got-to-think-like-a-derivative.html#she-is-beauty-and-she-is-grace.-she-is-queen-of-50-states.-she-is-elegance-and-taste.-she-is-miss-autodiff",
    "href": "posts/2022-05-20-to-catch-a-derivative-first-youve-got-to-think-like-a-derivative/to-catch-a-derivative-first-youve-got-to-think-like-a-derivative.html#she-is-beauty-and-she-is-grace.-she-is-queen-of-50-states.-she-is-elegance-and-taste.-she-is-miss-autodiff",
    "title": "Sparse matrices 6: To catch a derivative, first you’ve got to think like a derivative",
    "section": "She is beauty and she is grace. She is queen of 50 states. She is elegance and taste. She is miss autodiff",
    "text": "She is beauty and she is grace. She is queen of 50 states. She is elegance and taste. She is miss autodiff\nDerivatives are computed in JAX through the glory and power of automatic differentiation. If you came to this blog hoping for a great description of how autodiff works, I am terribly sorry but I absolutely do not have time for that. Might I suggest google? Or maybe flick through this survey by Charles Margossian..\nThe most important thing to remember about algorithmic differentiation is that it is not symbolic differentiation. That is, it does not create the functional form of the derivative of the function and compute that. Instead, it is a system for cleverly composing derivatives in each bit of the program to compute the value of the derivative of the function.\nBut for that to work, we need to implement those clever little mini-derivatives. In particular, every function \\(f(\\cdot): \\mathbb{R}^n \\rightarrow \\mathbb{R}^m\\) needs to have a function to compute the corresponding Jacobian-vector product \\[\n(\\theta, v) \\rightarrow J(\\theta) v,\n\\] where the \\(n \\times m\\) matrix \\(J(\\theta)\\) has entries \\[\nJ(\\theta)_{ij} = \\frac{\\partial f_j }{\\partial \\theta_j}.\n\\]\nOk. So let’s get onto this. We are going to derive and implement some Jacobian-vector products. And all of the assorted accoutrement. And by crikey. We are going to do it all in a JAX-traceable way."
  },
  {
    "objectID": "posts/2022-05-20-to-catch-a-derivative-first-youve-got-to-think-like-a-derivative/to-catch-a-derivative-first-youve-got-to-think-like-a-derivative.html#jvp-number-one-the-linear-solve.",
    "href": "posts/2022-05-20-to-catch-a-derivative-first-youve-got-to-think-like-a-derivative/to-catch-a-derivative-first-youve-got-to-think-like-a-derivative.html#jvp-number-one-the-linear-solve.",
    "title": "Sparse matrices 6: To catch a derivative, first you’ve got to think like a derivative",
    "section": "JVP number one: The linear solve.",
    "text": "JVP number one: The linear solve.\nThe first of the derivatives that we need to work out is the derivative of a linear solve \\(A^{-1}b\\). Now, intrepid readers, the obvious thing to do is look the damn derivative up. You get exactly no hero points for computing it yourself.\nBut I’m not you, I’m a dickhead.\nSo I’m going to derive it. I could pretend there are reasons3, but that would just be lying. I’m doing it because I can.\nBeyond the obvious fun of working out a matrix derivative from first principles, this is fun because we have two arguments instead of just one. Double the fun.\nAnd we really should make sure the function is differentiated with respect to every reasonable argument. Why? Because if you write code other people might use, you don’t get to control how they use it (or what they will email you about). So it’s always good practice to limit surprises (like a function not being differentiable wrt some argument) to cases4 where it absolutely necessary. This reduces the emails.\nTo that end, let’s take an arbitrary SPD matrix \\(A\\) with a fixed sparsity pattern. Let’s take another symmetric matrix \\(\\Delta\\) with the same sparsity pattern and assume that \\(\\Delta\\) is small enough5 that \\(A + \\Delta\\) is still symmetric positive definite. We also need a vector \\(\\delta\\) with a small \\(\\|\\delta\\|\\).\nNow let’s get algebraing. \\[\\begin{align*}\nf(A + \\Delta, b + \\delta) &= (A+\\Delta)^{-1}(b + \\delta) \\\\\n&= (I + A^{-1}\\Delta)^{-1}A^{-1}(b + \\delta) \\\\\n&= (I - A^{-1}\\Delta + o(\\|\\Delta\\|))A^{-1}(b + \\delta) \\\\\n&= A^{-1}b + A^{-1}(\\delta - \\Delta A^{-1}b ) + o(\\|\\Delta\\| + \\|\\delta\\|)\n\\end{align*}\\]\nEasy6 as.\nWe’ve actually calculated the derivative now, but it’s a little more work to recognise it.\nTo do that, we need to remember the practical definition of the Jacobian of a function \\(f(x)\\) that takes an \\(n\\)-dimensional input and produces an \\(m\\)-dimensional output. It is the \\(n \\times m\\) matrix \\(J_f(x)\\) such that \\[\nf(x + \\delta)  = f(x) + J_f(x)\\delta + o(\\|\\delta\\|).\n\\]\nThe formulas further simplify if we write \\(c = A^{-1}b\\). Then, if we want the Jacobian-vector product for the first argument, it is \\[\n-A^{-1}\\Delta c,\n\\] while the Jacobian-vector product for the second argument is \\[\nA^{-1}\\delta.\n\\]\nThe only wrinkle in doing this is we need to remember that we are only storing the lower triangle of \\(A\\). Because we need to represent \\(\\Delta\\) the same way, it is represented as a vector Delta_x that contains only the lower triangle of \\(\\Delta\\). So we need to make sure we remember to form the whole matrix before we do the matrix-vector product \\(\\Delta c\\)!\nBut otherwise, the implementation is going to be pretty straightforward. The Jacobian-vector product costs one additional linear solve (beyond the one needed to compute the value \\(c = A^{-1}b\\)).\nIn the language of JAX (and autodiff in general), we refer to \\(\\Delta\\) and \\(\\delta\\) as tangent vectors. In search of a moderately coherent naming convention, we are going to refer to the tangent associated with the variable x as xt.\nSo let’s implement this. Remember: it needs7 to be JAX traceable."
  },
  {
    "objectID": "posts/2022-05-20-to-catch-a-derivative-first-youve-got-to-think-like-a-derivative/to-catch-a-derivative-first-youve-got-to-think-like-a-derivative.html#primitive-two-the-triangular-solve",
    "href": "posts/2022-05-20-to-catch-a-derivative-first-youve-got-to-think-like-a-derivative/to-catch-a-derivative-first-youve-got-to-think-like-a-derivative.html#primitive-two-the-triangular-solve",
    "title": "Sparse matrices 6: To catch a derivative, first you’ve got to think like a derivative",
    "section": "Primitive two: The triangular solve",
    "text": "Primitive two: The triangular solve\nFor some sense of continuity, we are going to keep the naming of the primitives from the last blog post, but we are not going to attack them in the same order. Why not? Because we work in order of complexity.\nSo first off we are going to do the triangular solve. As I have yet to package up the code (I promise, that will happen next8), I’m just putting it here under the fold.\n\n\nThe primal implementation\n\n\nfrom scipy import sparse\nimport numpy as np\nfrom jax import numpy as jnp\nfrom jax import core\nfrom jax._src import abstract_arrays\nfrom jax import core\n\nsparse_triangular_solve_p = core.Primitive(\"sparse_triangular_solve\")\n\ndef sparse_triangular_solve(L_indices, L_indptr, L_x, b, *, transpose: bool = False):\n  \"\"\"A JAX traceable sparse  triangular solve\"\"\"\n  return sparse_triangular_solve_p.bind(L_indices, L_indptr, L_x, b, transpose = transpose)\n\n@sparse_triangular_solve_p.def_impl\ndef sparse_triangular_solve_impl(L_indices, L_indptr, L_x, b, *, transpose = False):\n  \"\"\"The implementation of the sparse triangular solve. This is not JAX traceable.\"\"\"\n  L = sparse.csc_array((L_x, L_indices, L_indptr)) \n  \n  assert L.shape[0] == L.shape[1]\n  assert L.shape[0] == b.shape[0]\n  \n  if transpose:\n    return sparse.linalg.spsolve_triangular(L.T, b, lower = False)\n  else:\n    return sparse.linalg.spsolve_triangular(L.tocsr(), b, lower = True)\n\n@sparse_triangular_solve_p.def_abstract_eval\ndef sparse_triangular_solve_abstract_eval(L_indices, L_indptr, L_x, b, *, transpose = False):\n  assert L_indices.shape[0] == L_x.shape[0]\n  assert b.shape[0] == L_indptr.shape[0] - 1\n  return abstract_arrays.ShapedArray(b.shape, b.dtype)\n\n\n\nThe Jacobian-vector product\n\nfrom jax._src import ad_util\nfrom jax.interpreters import ad\nfrom jax import lax\nfrom jax.experimental import sparse as jsparse\n\ndef sparse_triangular_solve_value_and_jvp(arg_values, arg_tangent, *, transpose):\n  \"\"\"\n  A jax-traceable jacobian-vector product. In order to make it traceable, \n  we use the experimental sparse CSC matrix in JAX.\n  \n  Input:\n    arg_values:   A tuple of (L_indices, L_indptr, L_x, b) that describe\n                  the triangular matrix L and the rhs vector b\n    arg_tangent:  A tuple of tangent values (same lenght as arg_values).\n                  The first two values are nonsense - we don't differentiate\n                  wrt integers!\n    transpose:    (boolean) If true, solve L^Tx = b. Otherwise solve Lx = b.\n  Output:         A tuple containing the maybe_transpose(L)^{-1}b and the corresponding\n                  Jacobian-vector product.\n  \"\"\"\n  L_indices, L_indptr, L_x, b = arg_values\n  _, _, L_xt, bt = arg_tangent\n  value = sparse_triangular_solve(L_indices, L_indptr, L_x, b, transpose=transpose)\n  if type(bt) is ad.Zero and type(L_xt) is ad.Zero:\n    # I legit do not think this ever happens. But I'm honestly not sure.\n    print(\"I have arrived!\")\n    return value, lax.zeros_like_array(value) \n  \n  if type(L_xt) is not ad.Zero:\n    # L is variable\n    if transpose:\n      Delta = jsparse.CSC((L_xt, L_indices, L_indptr), shape = (b.shape[0], b.shape[0])).transpose()\n    else:\n      Delta = jsparse.CSC((L_xt, L_indices, L_indptr), shape = (b.shape[0], b.shape[0]))\n\n    jvp_Lx = sparse_triangular_solve(L_indices, L_indptr, L_x, Delta @ value, transpose = transpose) \n  else:\n    jvp_Lx = lax.zeros_like_array(value) \n\n  if type(bt) is not ad.Zero:\n    # b is variable\n    jvp_b = sparse_triangular_solve(L_indices, L_indptr, L_x, bt, transpose = transpose)\n  else:\n    jvp_b = lax.zeros_like_array(value)\n\n  return value, jvp_b - jvp_Lx\n\nad.primitive_jvps[sparse_triangular_solve_p] = sparse_triangular_solve_value_and_jvp\n\nBefore we see if this works, let’s first have talk about the structure of the function I just wrote. Generally speaking, we want a function that takes in the primals and tangents at tuples and then returns the value and the9 Jacobian-vector product.\nThe main thing you will notice in the code is that there is a lot of checking for ad.Zero. This is a special type defined in JAX that is, essentially, telling the autodiff system that we are not differentiating wrt that variable. This is different to a tangent that just happens to be numerically equal to zero. Any code for a Jacobian-vector product needs to handle this special value.\nAs we have two arguments, we have 3 interesting options:\n\nBoth L_xt and bt are ad.Zero: This means the function is a constant and the derivative is zero. I am fairly certain that we do not need to manually handle this case, but because I don’t know and I do not like surprises, it’s in there.\nL_xt is not ad.Zero: This means that we need to differentiate wrt the matrix. In this case we need to compute \\(\\Delta c\\) or \\(\\Delta^T c\\), depending on the transpose argument. In order to do this, I used the jax.experimental.sparse.CSC class, which has some very limited sparse matrix support (basically matrix-vector products). This is extremely convenient because it means I don’t need to write the matrix-vector product myself!\nbt is not ad.Zero: This means that we need to differentiate wrt the rhs vector. This part of the formula is pretty straightforward: just an application of the primal.\n\nIn the case that either L_xt or bt are ad.Zero, we simply set the corresponding contribution to the jvp to zero.\nIt’s worth saying that you can bypass all of this ad.Zero logic by writing separate functions for the JVP contribution from each input and then chaining them together using10 ad.defjvp2() to chain them together. This is what the lax.linalg.triangular_solve() implementation does.\nSo why didn’t I do this? I avoided this because in the other primitives I have to implement, there are expensive computations (like Cholesky factorisations) that I want to share between the primal and the various tangent calculations. The ad.defjvp frameworks don’t allow for that. So I decided not to demonstrate/learn two separate patterns.\n\n\nTransposition\nNow I’ve never actively wanted a Jacobian-vector product in my whole life. I’m sorry. I want a gradient. Gimme a gradient. I am the Veruca Salt of gradients.\nIn may autodiff systems, if you want11 a gradient, you need to implement vector-Jacobian products12 explicitly.\nOne of the odder little innovations in JAX is that instead of forcing you to implement this as well13, you only need to implement half of it.\nYou see, some clever analysis that, as far as I far as I can tell14, is detailed in this paper shows that you only need to form explicit vector-Jacobian products for the structurally linear arguments of the function.\nIn JAX (and maybe elsewhere), this is known as a transposition rule. The combination of a transopition rule and a JAX-traceable Jacobian-vector product is enough for JAX to compute all of the directional derivatives and gradients we could ever hope for.\nAs far as I understand, it is all about functions that are structurally linear in some arguments. For instance, if \\(A(x)\\) is a matrix-valued function and \\(x\\) and \\(y\\) are vectors, then the function \\[\nf(x, y) = A(x)y + g(x)\n\\] is structurally linear in \\(y\\) in the sense that for every fixed value of \\(x\\), the function \\[\nf_x(y) = A(x) y + g(x)\n\\] is linear in \\(y\\). The resulting transpositon rule is then\n\ndef f_transpose(x, y):\n  Ax = A(x)\n  gx = g(x)\n  return (None, Ax.T @ y + gx)\n\nThe first element of the return is None because \\(f(x,y)\\) is not15 structurally linear in \\(x\\) so there is nothing to transpose. The second element simply takes the matrix in the linear function and transposes it.\nIf you know anything about autodiff, you’ll think “this doesn’t feel like enough” and it’s not. JAX deals with the non-linear part of \\(f(x,y)\\) by tracing the evaluation tree for its Jacobian-vector product and … manipulating16 it.\nWe already built the abstract evaluation function last time around, so the tracing part can be done. All we need is the transposition rule.\nThe linear solve \\(f(A, b) = A^{-1}b\\) is non-linear in the first argument but linear in the second argument. So we only need to implement \\[\nJ^T_b(A,b)w = A^{-T}w,\n\\] where the subscript \\(b\\) indicates we’re only computing the Jacobian wrt \\(b\\).\nInitially, I struggled to work out what needed to be implemented here. The thing that clarified the process for me was looking at JAX’s internal implementation of the Jacobian-vector product for a dense matrix. From there, I understood what this had to look like for a vector-valued function and this is the result.\n\ndef sparse_triangular_solve_transpose_rule(cotangent, L_indices, L_indptr, L_x, b, *, transpose):\n  \"\"\"\n  Transposition rule for the triangular solve. \n  Translated from here https://github.com/google/jax/blob/41417d70c03b6089c93a42325111a0d8348c2fa3/jax/_src/lax/linalg.py#L747.\n  Inputs:\n    cotangent: Output cotangent (aka adjoint). (produced by JAX)\n    L_indices, L_indptr, L_x: Represenation of sparse matrix. L_x should be concrete\n    b: The right hand side. Must be an jax.interpreters.ad.UndefinedPrimal\n    transpose: (boolean) True: solve $L^Tx = b$. False: Solve $Lx = b$.\n  Output:\n    A 4-tuple with the adjoints (None, None, None, b_adjoint)\n  \"\"\"\n  assert not ad.is_undefined_primal(L_x) and ad.is_undefined_primal(b)\n  if type(cotangent) is ad_util.Zero:\n    cot_b = ad_util.Zero(b.aval)\n  else:\n    cot_b = sparse_triangular_solve(L_indices, L_indptr, L_x, cotangent, transpose = not transpose)\n  return None, None, None, cot_b\n\nad.primitive_transposes[sparse_triangular_solve_p] = sparse_triangular_solve_transpose_rule\n\nIf this doesn’t make a lot of sense to you, that’s because it’s confusing.\nOne way to think of it is in terms of the more ordinary notation. Mike Giles has a classic paper that covers these results for basic linear algebra. The idea is to imagine that, as part of your larger program, you need to compute \\(c = A^{-1}b\\).\nForward-mode autodiff computes the sensitivity of \\(c\\), usually denoted \\(\\dot c\\) from the sensitivies \\(\\dot A\\) and \\(\\dot b\\). These have already been computed. The formula in Giles is \\[\n\\dot c = A^{-1}(\\dot b - \\dot A c).\n\\] The canny reader will recognise this as exactly17 the formula for the Jacobian-vector product.\nSo what does reverse-mode autodiff do? Well it moves through the program in the other direction. So instead of starting with the sensitivities \\(\\dot A\\) and \\(\\dot b\\) already computed, we instead start with the18 adjoint sensitivity \\(\\bar c\\). Our aim is to compute \\(\\bar A\\) and \\(\\bar b\\) from \\(\\bar c\\).\nThe details of how to do this are19 beyond the scope, but without tooooooo much effort you can show that \\[\n\\bar b = A^{-T} \\bar c,\n\\] which you should recognise as the equation that was just implemented.\nThe thing that we do not have to implement in JAX is the other adjoint that, for dense matrices20, is \\[\n\\bar{A} = -\\bar{b}c^T.\n\\] Through the healing power of … something?—Truly I do not know.— JAX can work that bit out itself. woo.\n\n\nTesting the numerical implementation of the Jacobian-vector product\nSo let’s see if this works. I’m not going to lie, I’m flying by the seat of my pants here. I’m not super familiar with the JAX internals, so I have written a lot of test cases. You may wish to skip this part. But rest assured that almost every single one of these cases was useful to me working out how this thing actually worked!\n\ndef make_matrix(n):\n    one_d = sparse.diags([[-1.]*(n-1), [2.]*n, [-1.]*(n-1)], [-1,0,1])\n    A = (sparse.kronsum(one_d, one_d) + sparse.eye(n*n)).tocsc()\n    A_lower = sparse.tril(A, format = \"csc\")\n    A_index = A_lower.indices\n    A_indptr = A_lower.indptr\n    A_x = A_lower.data\n    return (A_index, A_indptr, A_x, A)\n\nA_indices, A_indptr, A_x, A = make_matrix(10)\n\nThis is the same test case as the last blog. We will just use the lower triangle of \\(A\\) as the test matrix.\nFirst things first, let’s check out the numerical implementation of the function. We will do that by comparing the implemented Jacobian-vector product with the definition of the Jacobian-vector product (aka the forward21 difference approximation).\nThere are lots of things that we could do here to turn these into actual tests. For instance, the test suite inside JAX has a lot of nice convenience functions for checking implementations of derivatives. But I went with homespun because that was how I was feeling.\nYou’ll also notice that I’m using random numbers here, which is fine for a blog. Not so fine for a test that you don’t want to be potentially22 flaky.\nThe choice of eps = 1e-4 is roughly23 because it’s the square root of the single precision machine epsilon24. A very rough back of the envelope calculation for the forward difference approximation to the derivative shows that the square root of the machine epislon is about the size you want your perturbation to be.\n\nb = np.random.standard_normal(100)\n\nbt = np.random.standard_normal(100)\nbt /= np.linalg.norm(bt)\n\nA_xt = np.random.standard_normal(len(A_x))\nA_xt /= np.linalg.norm(A_xt)\n\narg_values = (A_indices, A_indptr, A_x, b )\n\narg_tangent_A = (None, None, A_xt, ad.Zero(type(b)))\narg_tangent_b = (None, None, ad.Zero(type(A_xt)), bt)\narg_tangent_Ab = (None, None, A_xt, bt)\n\np, t_A = sparse_triangular_solve_value_and_jvp(arg_values, arg_tangent_A, transpose = False)\n_, t_b = sparse_triangular_solve_value_and_jvp(arg_values, arg_tangent_b, transpose = False)\n_, t_Ab = sparse_triangular_solve_value_and_jvp(arg_values, arg_tangent_Ab, transpose = False)\npT, t_AT = sparse_triangular_solve_value_and_jvp(arg_values, arg_tangent_A, transpose = True)\n_, t_bT = sparse_triangular_solve_value_and_jvp(arg_values, arg_tangent_b, transpose = True)\n\neps = 1e-4\ntt_A = (sparse_triangular_solve(A_indices, A_indptr, A_x + eps * A_xt, b) - p) /eps\ntt_b = (sparse_triangular_solve(A_indices, A_indptr, A_x, b + eps * bt) - p) / eps\ntt_Ab = (sparse_triangular_solve(A_indices, A_indptr, A_x + eps * A_xt, b + eps * bt) - p) / eps\ntt_AT = (sparse_triangular_solve(A_indices, A_indptr, A_x + eps * A_xt, b, transpose = True) - pT) / eps\ntt_bT = (sparse_triangular_solve(A_indices, A_indptr, A_x, b + eps * bt, transpose = True) - pT) / eps\n\nprint(f\"\"\"\nTranspose = False:\n  Error A varying: {np.linalg.norm(t_A - tt_A): .2e}\n  Error b varying: {np.linalg.norm(t_b - tt_b): .2e}\n  Error A and b varying: {np.linalg.norm(t_Ab - tt_Ab): .2e}\n\nTranspose = True:\n  Error A varying: {np.linalg.norm(t_AT - tt_AT): .2e}\n  Error b varying: {np.linalg.norm(t_bT - tt_bT): .2e}\n\"\"\")\n\n\nTranspose = False:\n  Error A varying:  1.08e-07\n  Error b varying:  0.00e+00\n  Error A and b varying:  4.19e-07\n\nTranspose = True:\n  Error A varying:  1.15e-07\n  Error b varying:  0.00e+00\n\n\n\nBrilliant! Everythign correct withing single precision!\n\n\nChecking on the plumbing\nMaking the numerical implementation work is only half the battle. We also have to make it work in the context of JAX.\nNow I would be lying if I pretended this process went smoothly. But the first time is for experience. It’s mostly a matter of just reading the documentation carefully and going through similar examples that have already been implemented.\nAnd testing. I learnt how this was supposed to work by testing it.\n(For full disclosure, I also wrote a big block f-string in the sparse_triangular_solve() function at one point that told me the types, shapes, and what transpose was, which was how I worked out that my code was breaking because I forgot the first to None outputs in the transposition rule. When it doubt, print shit.)\nAs you will see from my testing code, I was not going for elegance. I was running the damn permutations. If you’re looking for elegance, look elsewhere.\n\nfrom jax import jvp, grad\nfrom jax import scipy as jsp\n\ndef f(theta):\n  Ax_theta = jnp.array(A_x)\n  Ax_theta = Ax_theta.at[A_indptr[20]].add(theta[0])\n  Ax_theta = Ax_theta.at[A_indptr[50]].add(theta[1])\n  b = jnp.ones(100)\n  return sparse_triangular_solve(A_indices, A_indptr, Ax_theta, b, transpose = True)\n\ndef f_jax(theta):\n  Ax_theta = jnp.array(sparse.tril(A).todense())\n  Ax_theta = Ax_theta.at[20,20].add(theta[0])\n  Ax_theta = Ax_theta.at[50,50].add(theta[1])\n  b = jnp.ones(100)\n  return jsp.linalg.solve_triangular(Ax_theta, b, lower = True, trans = \"T\")\n\ndef g(theta):\n  Ax_theta = jnp.array(A_x)\n  b = jnp.ones(100)\n  b = b.at[0].set(theta[0])\n  b = b.at[51].set(theta[1])\n  return sparse_triangular_solve(A_indices, A_indptr, Ax_theta, b, transpose = True)\n\ndef g_jax(theta):\n  Ax_theta = jnp.array(sparse.tril(A).todense())\n  b = jnp.ones(100)\n  b = b.at[0].set(theta[0])\n  b = b.at[51].set(theta[1])\n  return jsp.linalg.solve_triangular(Ax_theta, b, lower = True, trans = \"T\")\n\ndef h(theta):\n  Ax_theta = jnp.array(A_x)\n  Ax_theta = Ax_theta.at[A_indptr[20]].add(theta[0]) \n  b = jnp.ones(100)\n  b = b.at[51].set(theta[1])\n  return sparse_triangular_solve(A_indices, A_indptr, Ax_theta, b, transpose = False)\n\ndef h_jax(theta):\n  Ax_theta = jnp.array(sparse.tril(A).todense())\n  Ax_theta = Ax_theta.at[20,20].add(theta[0])\n  b = jnp.ones(100)\n  b = b.at[51].set(theta[1])\n  return jsp.linalg.solve_triangular(Ax_theta, b, lower = True, trans = \"N\")\n\ndef no_diff(theta):\n  return sparse_triangular_solve(A_indices, A_indptr, A_x, jnp.ones(100), transpose = False)\n\ndef no_diff_jax(theta):\n  return jsp.linalg.solve_triangular(jnp.array(sparse.tril(A).todense()), jnp.ones(100), lower = True, trans = \"N\")\n\nA_indices, A_indptr, A_x, A = make_matrix(10)\nprimal1, jvp1 = jvp(f, (jnp.array([-142., 342.]),), (jnp.array([1., 2.]),))\nprimal2, jvp2 = jvp(f_jax, (jnp.array([-142., 342.]),), (jnp.array([1., 2.]),))\ngrad1 = grad(lambda x: jnp.mean(f(x)))(jnp.array([-142., 342.]))\ngrad2 = grad(lambda x: jnp.mean(f_jax(x)))(jnp.array([-142., 342.]))\n\nprimal3, jvp3 = jvp(g, (jnp.array([-142., 342.]),), (jnp.array([1., 2.]),))\nprimal4, jvp4 = jvp(g_jax, (jnp.array([-142., 342.]),), (jnp.array([1., 2.]),))\ngrad3 = grad(lambda x: jnp.mean(g(x)))(jnp.array([-142., 342.]))\ngrad4 = grad(lambda x: jnp.mean(g_jax(x)))(jnp.array([-142., 342.]))  \n\nprimal5, jvp5 = jvp(h, (jnp.array([-142., 342.]),), (jnp.array([1., 2.]),))\nprimal6, jvp6 = jvp(h_jax, (jnp.array([-142., 342.]),), (jnp.array([1., 2.]),))\ngrad5 = grad(lambda x: jnp.mean(h(x)))(jnp.array([-142., 342.]))\ngrad6 = grad(lambda x: jnp.mean(h_jax(x)))(jnp.array([-142., 342.]))\n\nprimal7, jvp7 = jvp(no_diff, (jnp.array([-142., 342.]),), (jnp.array([1., 2.]),))\nprimal8, jvp8 = jvp(no_diff_jax, (jnp.array([-142., 342.]),), (jnp.array([1., 2.]),))\ngrad7 = grad(lambda x: jnp.mean(no_diff(x)))(jnp.array([-142., 342.]))\ngrad8 = grad(lambda x: jnp.mean(no_diff_jax(x)))(jnp.array([-142., 342.]))\n\nprint(f\"\"\"\nVariable L:\n  Primal difference: {np.linalg.norm(primal1 - primal2): .2e}\n  JVP difference: {np.linalg.norm(jvp1 - jvp2): .2e}\n  Gradient difference: {np.linalg.norm(grad1 - grad2): .2e}\n\nVariable b:\n  Primal difference: {np.linalg.norm(primal3 - primal4): .2e}\n  JVP difference: {np.linalg.norm(jvp3 - jvp4): .2e}\n  Gradient difference: {np.linalg.norm(grad3 - grad4): .2e} \n\nVariable L and b:\n  Primal difference: {np.linalg.norm(primal5 - primal6): .2e}\n  JVP difference: {np.linalg.norm(jvp5 - jvp6): .2e}\n  Gradient difference: {np.linalg.norm(grad5 - grad6): .2e}\n\nNo diff:\n  Primal difference: {np.linalg.norm(primal7 - primal8)}\n  JVP difference: {np.linalg.norm(jvp7 - jvp8)}\n  Gradient difference: {np.linalg.norm(grad7 - grad8)}\n\"\"\")\n\n\nVariable L:\n  Primal difference:  1.98e-07\n  JVP difference:  2.58e-12\n  Gradient difference:  0.00e+00\n\nVariable b:\n  Primal difference:  7.94e-06\n  JVP difference:  1.83e-08\n  Gradient difference:  3.29e-10 \n\nVariable L and b:\n  Primal difference:  2.08e-06\n  JVP difference:  1.08e-08\n  Gradient difference:  2.33e-10\n\nNo diff:\n  Primal difference: 2.2101993124579167e-07\n  JVP difference: 0.0\n  Gradient difference: 0.0\n\n\n\nStunning!"
  },
  {
    "objectID": "posts/2022-05-20-to-catch-a-derivative-first-youve-got-to-think-like-a-derivative/to-catch-a-derivative-first-youve-got-to-think-like-a-derivative.html#primitive-one-the-general-a-1b",
    "href": "posts/2022-05-20-to-catch-a-derivative-first-youve-got-to-think-like-a-derivative/to-catch-a-derivative-first-youve-got-to-think-like-a-derivative.html#primitive-one-the-general-a-1b",
    "title": "Sparse matrices 6: To catch a derivative, first you’ve got to think like a derivative",
    "section": "Primitive one: The general \\(A^{-1}b\\)",
    "text": "Primitive one: The general \\(A^{-1}b\\)\nOk. So this is a very similar problem to the one that we just solved. But, as fate would have it, the solution is going to look quite different. Why? Because we need to compute a Cholesky factorisation.\nFirst things first, though, we are going to need a JAX-traceable way to compute a Cholesky factor. This means that we need25 to tell our sparse_solve function the how many non-zeros the sparse Cholesky will have. Why? Well. It has to do with how the function is used.\nWhen sparse_cholesky() is called with concrete inputs26, then it can quite happily work out the sparsity structure of \\(L\\). But when JAX is preparing to transform the code, eg when it’s building a gradient, it calls sparse_cholesky() using abstract arguments that only share the shape information from the inputs. This is not enough to compute the sparsity structure. We need the indices and indptr arrays.\nThis means that we need sparse_cholesky() to throw an error if L_nse isn’t passed. This wasn’t implemented well last time, so here it is done properly.\n(If you’re wondering about that None argument, it is the identity transform. So if A_indices is a concrete value, ind = A_indices. Otherwise an error is called.)\n\nsparse_cholesky_p = core.Primitive(\"sparse_cholesky\")\n\ndef sparse_cholesky(A_indices, A_indptr, A_x, *, L_nse: int = None):\n  \"\"\"A JAX traceable sparse cholesky decomposition\"\"\"\n  if L_nse is None:\n    err_string = \"You need to pass a value to L_nse when doing fancy sparse_cholesky.\"\n    ind = core.concrete_or_error(None, A_indices, err_string)\n    ptr = core.concrete_or_error(None, A_indptr, err_string)\n    L_ind, _ = _symbolic_factor(ind, ptr)\n    L_nse = len(L_ind)\n  \n  return sparse_cholesky_p.bind(A_indices, A_indptr, A_x, L_nse = L_nse)\n\n\n\nThe rest of the Choleksy code\n\n\n@sparse_cholesky_p.def_impl\ndef sparse_cholesky_impl(A_indices, A_indptr, A_x, *, L_nse):\n  \"\"\"The implementation of the sparse cholesky This is not JAX traceable.\"\"\"\n  \n  L_indices, L_indptr= _symbolic_factor(A_indices, A_indptr)\n  if L_nse is not None:\n    assert len(L_indices) == L_nse\n    \n  L_x = _structured_copy(A_indices, A_indptr, A_x, L_indices, L_indptr)\n  L_x = _sparse_cholesky_impl(L_indices, L_indptr, L_x)\n  return L_indices, L_indptr, L_x\n\ndef _symbolic_factor(A_indices, A_indptr):\n  # Assumes A_indices and A_indptr index the lower triangle of $A$ ONLY.\n  n = len(A_indptr) - 1\n  L_sym = [np.array([], dtype=int) for j in range(n)]\n  children = [np.array([], dtype=int) for j in range(n)]\n  \n  for j in range(n):\n    L_sym[j] = A_indices[A_indptr[j]:A_indptr[j + 1]]\n    for child in children[j]:\n      tmp = L_sym[child][L_sym[child] > j]\n      L_sym[j] = np.unique(np.append(L_sym[j], tmp))\n    if len(L_sym[j]) > 1:\n      p = L_sym[j][1]\n      children[p] = np.append(children[p], j)\n        \n  L_indptr = np.zeros(n+1, dtype=int)\n  L_indptr[1:] = np.cumsum([len(x) for x in L_sym])\n  L_indices = np.concatenate(L_sym)\n  \n  return L_indices, L_indptr\n\n\n\ndef _structured_copy(A_indices, A_indptr, A_x, L_indices, L_indptr):\n  n = len(A_indptr) - 1\n  L_x = np.zeros(len(L_indices))\n  \n  for j in range(0, n):\n    copy_idx = np.nonzero(np.in1d(L_indices[L_indptr[j]:L_indptr[j + 1]],\n                                  A_indices[A_indptr[j]:A_indptr[j+1]]))[0]\n    L_x[L_indptr[j] + copy_idx] = A_x[A_indptr[j]:A_indptr[j+1]]\n  return L_x\n\ndef _sparse_cholesky_impl(L_indices, L_indptr, L_x):\n  n = len(L_indptr) - 1\n  descendant = [[] for j in range(0, n)]\n  for j in range(0, n):\n    tmp = L_x[L_indptr[j]:L_indptr[j + 1]]\n    for bebe in descendant[j]:\n      k = bebe[0]\n      Ljk= L_x[bebe[1]]\n      pad = np.nonzero(                                                       \\\n          L_indices[L_indptr[k]:L_indptr[k+1]] == L_indices[L_indptr[j]])[0][0]\n      update_idx = np.nonzero(np.in1d(                                        \\\n                    L_indices[L_indptr[j]:L_indptr[j+1]],                     \\\n                    L_indices[(L_indptr[k] + pad):L_indptr[k+1]]))[0]\n      tmp[update_idx] = tmp[update_idx] -                                     \\\n                        Ljk * L_x[(L_indptr[k] + pad):L_indptr[k + 1]]\n            \n    diag = np.sqrt(tmp[0])\n    L_x[L_indptr[j]] = diag\n    L_x[(L_indptr[j] + 1):L_indptr[j + 1]] = tmp[1:] / diag\n    for idx in range(L_indptr[j] + 1, L_indptr[j + 1]):\n      descendant[L_indices[idx]].append((j, idx))\n  return L_x\n\n@sparse_cholesky_p.def_abstract_eval\ndef sparse_cholesky_abstract_eval(A_indices, A_indptr, A_x, *, L_nse):\n  return core.ShapedArray((L_nse,), A_indices.dtype),                   \\\n         core.ShapedArray(A_indptr.shape, A_indptr.dtype),             \\\n         core.ShapedArray((L_nse,), A_x.dtype)\n\n\n\nWhy do we need a new pattern for this very very similar problem?\nOk. So now on to the details. If we try to repeat our previous pattern it would look like this.\n\ndef sparse_solve_value_and_jvp(arg_values, arg_tangents, *, L_nse):\n  \"\"\" \n  Jax-traceable jacobian-vector product implmentation for sparse_solve.\n  \"\"\"\n  \n  A_indices, A_indptr, A_x, b = arg_values\n  _, _, A_xt, bt = arg_tangents\n\n  # Needed for shared computation\n  L_indices, L_indptr, L_x = sparse_cholesky(A_indices, A_indptr, A_x)\n\n  # Make the primal\n  primal_out = sparse_triangular_solve(L_indices, L_indptr, L_x, b, transpose = False)\n  primal_out = sparse_triangular_solve(L_indices, L_indptr, L_x, primal_out, transpose = True)\n\n  if type(A_xt) is not ad.Zero:\n    Delta_lower = jsparse.CSC((A_xt, A_indices, A_indptr), shape = (b.shape[0], b.shape[0]))\n    # We need to do Delta @ primal_out, but we only have the lower triangle\n    rhs = Delta_lower @ primal_out + Delta_lower.transpose() @ primal_out - A_xt[A_indptr[:-1]] * primal_out\n    jvp_Ax = sparse_triangular_solve(L_indices, L_indptr, L_x, rhs)\n    jvp_Ax = sparse_triangular_solve(L_indices, L_indptr, L_x, jvp_Ax, transpose = True)\n  else:\n    jvp_Ax = lax.zeros_like_array(primal_out)\n\n  if type(bt) is not ad.Zero:\n    jvp_b = sparse_triangular_solve(L_indices, L_indptr, L_x, bt)\n    jvp_b = sparse_triangular_solve(L_indices, L_indptr, L_x, jvp_b, transpose = True)\n  else:\n    jvp_b = lax.zeros_like_array(primal_out)\n\n  return primal_out, jvp_b - jvp_Ax\n\nThat’s all well and good. Nothing weird there.\nThe problem comes when you need to implement the transposition rule. Remembering that \\(\\bar b = A^{-T}\\bar c = A^{-1}\\bar c\\), you might see the issue: we are going to need the Cholesky factorisation. But we have no way to pass \\(L\\) to the transpose function.\nThis means that we would need to compute two Cholesky factorisations per gradient instead of one. As the Cholesky factorisation is our slowest operation, we do not want to do extra ones! We want to compute the Cholesky triangle once and pass it around like a party bottom27. We do not want each of our functions to have to make a deep and meaningful connection with the damn matrix28.\n\n\nA different solution\nSo how do we pass around our Cholesky triangle? Well, I do love a good class so my first thought was “fuck it. I’ll make a class and I’ll pass it that way”. But the developers of JAX had a much better idea.\nTheir idea was to abstract the idea of a linear solve and its gradients. They do this through lax.custom_linear_solve. This is a function that takes all of the bits that you would need to compute \\(A^{-1}b\\) and all of its derivatives. In particular it takes29:\n\nmatvec: A function that matvec(x) that computes \\(Ax\\). This might seem a bit weird, but it’s the most common atrocity committed by mathematicians is abstracting30 a matrix to a linear mapping. So we might as well just suck it up.\nb: The right hand side vector31\nsolve: A function that takes takes the matvec and a vector so that32 solve(matvec, matvec(x)) == x\nsymmetric: A boolean indicating if \\(A\\) is symmetric.\n\nThe idea (happily copped from the implementation of jax.scipy.linalg.solve) is to wrap our Cholesky decomposition in the solve function. Through the never ending miracle of partial evaluation.\n\nfrom functools import partial\n\ndef sparse_solve(A_indices, A_indptr, A_x, b, *, L_nse = None):\n  \"\"\"\n  A JAX-traceable sparse solve. For this moment, only for vector b\n  \"\"\"\n  assert b.shape[0] == A_indptr.shape[0] - 1\n  assert b.ndim == 1\n  \n  L_indices, L_indptr, L_x = sparse_cholesky(\n    lax.stop_gradient(A_indices), \n    lax.stop_gradient(A_indptr), \n    lax.stop_gradient(A_x), L_nse = L_nse)\n  \n  def chol_solve(L_indices, L_indptr, L_x, b):\n    out = sparse_triangular_solve(L_indices, L_indptr, L_x, b, transpose = False)\n    return sparse_triangular_solve(L_indices, L_indptr, L_x, out, transpose = True)\n  \n  def matmult(A_indices, A_indptr, A_x, b):\n    A_lower = jsparse.CSC((A_x, A_indices, A_indptr), shape = (b.shape[0], b.shape[0]))\n    return A_lower @ b + A_lower.transpose() @ b - A_x[A_indptr[:-1]] * b\n\n  solver = partial(\n    lax.custom_linear_solve,\n    lambda x: matmult(A_indices, A_indptr, A_x, x),\n    solve = lambda _, x: chol_solve(L_indices, L_indptr, L_x, x),\n    symmetric = True)\n\n  return solver(b)\n\nThere are three things of note in that implementation.\n\nThe calls to lax.stop_gradient(): These tell JAX to not bother computing the gradient of these terms. The relevant parts of the derivatives are computed explicitly by lax.custom_linear_solve in terms of matmult and solve, neither of which need the explicit derivative of the cholesky factorisation.!\nThat definition of matmult()33: Look. I don’t know what to tell you. Neither addition nor indexing is implemented for jsparse.CSC objects. So we did it the semi-manual way. (I am thankful that matrix-vector multiplication is available)\nThe definition of solver(): Partial evaluation is a wonderful wonderful thing. functools.partial() transforms lax.custom_linear_solve() from a function that takes 3 arguments (and some keywords), into a function solver() that takes one34 argument35 (b, the only positional argument of lax.custom_linear_solve() that isn’t specified).\n\n\n\nDoes it work?\n\ndef f(theta):\n  Ax_theta = jnp.array(theta[0] * A_x)\n  Ax_theta = Ax_theta.at[A_indptr[:-1]].add(theta[1])\n  b = jnp.ones(100)\n  return sparse_solve(A_indices, A_indptr, Ax_theta, b)\n\ndef f_jax(theta):\n  Ax_theta = jnp.array(theta[0] * A.todense())\n  Ax_theta = Ax_theta.at[np.arange(100),np.arange(100)].add(theta[1])\n  b = jnp.ones(100)\n  return jsp.linalg.solve(Ax_theta, b)\n\ndef g(theta):\n  Ax_theta = jnp.array(A_x)\n  b = jnp.ones(100)\n  b = b.at[0].set(theta[0])\n  b = b.at[51].set(theta[1])\n  return sparse_solve(A_indices, A_indptr, Ax_theta, b)\n\ndef g_jax(theta):\n  Ax_theta = jnp.array(A.todense())\n  b = jnp.ones(100)\n  b = b.at[0].set(theta[0])\n  b = b.at[51].set(theta[1])\n  return jsp.linalg.solve(Ax_theta, b)\n\ndef h(theta):\n  Ax_theta = jnp.array(A_x)\n  Ax_theta = Ax_theta.at[A_indptr[:-1]].add(theta[0])\n  b = jnp.ones(100)\n  b = b.at[51].set(theta[1])\n  return sparse_solve(A_indices, A_indptr, Ax_theta, b)\n\ndef h_jax(theta):\n  Ax_theta = jnp.array(A.todense())\n  Ax_theta = Ax_theta.at[np.arange(100),np.arange(100)].add(theta[0])\n  b = jnp.ones(100)\n  b = b.at[51].set(theta[1])\n  return jsp.linalg.solve(Ax_theta, b)\n\nprimal1, jvp1 = jvp(f, (jnp.array([2., 3.]),), (jnp.array([1., 2.]),))\nprimal2, jvp2 = jvp(f_jax, (jnp.array([2., 3.]),), (jnp.array([1., 2.]),))\ngrad1 = grad(lambda x: jnp.mean(f(x)))(jnp.array([2., 3.]))\ngrad2 = grad(lambda x: jnp.mean(f_jax(x)))(jnp.array([2., 3.]))\n\n\nprimal3, jvp3 = jvp(g, (jnp.array([-142., 342.]),), (jnp.array([1., 2.]),))\nprimal4, jvp4 = jvp(g_jax, (jnp.array([-142., 342.]),), (jnp.array([1., 2.]),))\ngrad3 = grad(lambda x: jnp.mean(g(x)))(jnp.array([-142., 342.]))\ngrad4 = grad(lambda x: jnp.mean(g_jax(x)))(jnp.array([-142., 342.]))\n\nprimal5, jvp5 = jvp(h, (jnp.array([2., 342.]),), (jnp.array([1., 2.]),))\nprimal6, jvp6 = jvp(h_jax, (jnp.array([2., 342.]),), (jnp.array([1., 2.]),))\ngrad5 = grad(lambda x: jnp.mean(f(x)))(jnp.array([2., 342.]))\ngrad6 = grad(lambda x: jnp.mean(f_jax(x)))(jnp.array([2., 342.]))\n\nprint(f\"\"\"\nCheck the plumbing!\nVariable A:\n  Primal difference: {np.linalg.norm(primal1 - primal2): .2e}\n  JVP difference: {np.linalg.norm(jvp1 - jvp2): .2e}\n  Gradient difference: {np.linalg.norm(grad1 - grad2): .2e}\n  \nVariable b:\n  Primal difference: {np.linalg.norm(primal3 - primal4): .2e}\n  JVP difference: {np.linalg.norm(jvp3 - jvp4): .2e}\n  Gradient difference: {np.linalg.norm(grad3 - grad4): .2e} \n    \nVariable A and b:\n  Primal difference: {np.linalg.norm(primal5 - primal6): .2e}\n  JVP difference: {np.linalg.norm(jvp5 - jvp6): .2e}\n  Gradient difference: {np.linalg.norm(grad5 - grad6): .2e}\n  \"\"\")\n\n\nCheck the plumbing!\nVariable A:\n  Primal difference:  1.98e-07\n  JVP difference:  1.43e-07\n  Gradient difference:  0.00e+00\n  \nVariable b:\n  Primal difference:  4.56e-06\n  JVP difference:  6.52e-08\n  Gradient difference:  9.31e-10 \n    \nVariable A and b:\n  Primal difference:  8.10e-06\n  JVP difference:  1.83e-06\n  Gradient difference:  1.82e-12\n  \n\n\nYes.\n\n\nWhy is this better than just differentiating through the Cholesky factorisation?\nThe other option for making this work would’ve been to implement the Cholesky factorisation as a primitive (~which we are about to do!~ which we will do another day) and then write the sparse solver directly as a pure JAX function.\n\ndef sparse_solve_direct(A_indices, A_indptr, A_x, b, *, L_nse = None):\n  L_indices, L_indptr, L_x = sparse_cholesky(A_indices, A_indptr, A_x)\n  out = sparse_triangular_solve(L_indices, L_indptr, L_x, b)\n  return sparse_triangular_solve(L_indices, L_indptr, L_x, out, transpose = True)\n\nThis function is JAX-traceable36 and, therefore, we could compute the gradient of it directly. It turns out that this is going to be a bad idea.\nWhy? Because the derivative of sparse_cholesky, which we would have to chain together with the derivatives from the solver, is pretty complicated. Basically, this means that we’d have to do a lot more work37 than we do if we just implement the symbolic formula for the derivatives."
  },
  {
    "objectID": "posts/2022-05-20-to-catch-a-derivative-first-youve-got-to-think-like-a-derivative/to-catch-a-derivative-first-youve-got-to-think-like-a-derivative.html#primitive-three-the-dreaded-log-determinant",
    "href": "posts/2022-05-20-to-catch-a-derivative-first-youve-got-to-think-like-a-derivative/to-catch-a-derivative-first-youve-got-to-think-like-a-derivative.html#primitive-three-the-dreaded-log-determinant",
    "title": "Sparse matrices 6: To catch a derivative, first you’ve got to think like a derivative",
    "section": "Primitive three: The dreaded log determinant",
    "text": "Primitive three: The dreaded log determinant\nOk, so now we get to the good one. The log-determinant of \\(A\\). The first thing that we need to do is wrench out a derivative. This is not as easy as it was for the linear solve. So what follows is a modification for sparse matrices from Appendix A of Boyd’s convex optimisation book.\nIt’s pretty easy to convince yourself that \\[\\begin{align*}\n\\log(|A + \\Delta|) &= \\log\\left( \\left|A^{1/2}(I + A^{-1/2}\\Delta A^{-1/2})A^{1/2}\\right|\\right) \\\\\n&= \\log(|A|) + \\log\\left( \\left|I + A^{-1/2}\\Delta A^{-1/2}\\right|\\right).\n\\end{align*}\\]\nIt is harder to convince yourself how this could possibly be a useful fact.\nIf we write \\(\\lambda_i\\), \\(i = 1, \\ldots, n\\) as the eigenvalues of \\(A^{-1/2}\\Delta A^{-1/2}\\), then we have \\[\n\\log(|A + \\Delta |) = \\log(|A|) + \\sum_{i=1}^n \\log( 1 + \\lambda_i).\n\\] Remembering that \\(\\Delta\\) is very small, it follows that \\(A^{-1/2}\\Delta A^{-1/2}\\) will also be small. That translates to the eigenvalues of \\(A^{-1/2}\\Delta A^{-1/2}\\) all being small. Therefore, we can use the approximation \\(\\log(1 + \\lambda_i) = \\lambda_i + \\mathcal{O}(\\lambda_i^2)\\).\nThis means that38 \\[\\begin{align*}\n\\log(|A + \\Delta |) &= \\log(|A|) + \\sum_{i=1}^n  \\lambda_i + \\mathcal{O}\\left(\\|\\Delta\\|^2\\right) \\\\\n&=\\log(|A|) + \\operatorname{tr}\\left(A^{-1/2} \\Delta A^{-1} \\right) + \\mathcal{O}\\left(\\|\\Delta\\|^2\\right) \\\\\n&= \\log(|A|) + \\operatorname{tr}\\left(A^{-1} \\Delta \\right) + \\mathcal{O}\\left(\\|\\Delta\\|^2\\right),\n\\end{align*}\\] which follows from the cyclic property of the trace.\nIf we recall the formula from the last section defining the Jacobian-vector product, in our context \\(m = 1\\), \\(x\\) is the vector of non-zero entries of the lower triangle of \\(A\\) stacked by column, and \\(\\delta\\) is the vector of non-zero entries of the lower triangle of \\(\\Delta\\). That means the Jacobian-vector product is \\[\nJ(x)\\delta = \\operatorname{tr}\\left(A^{-1} \\Delta \\right) = \\sum_{i=1}^n\\sum_{j=1}^n[A^{-1}]_{ij} \\Delta_{ij}.\n\\]\nRemembering that \\(\\Delta\\) is sparse with the same sparsity pattern as \\(A\\), we see that the Jacobian-vector product requires us to know the values of \\(A^{-1}\\) that correspond to non-zero elements of \\(A\\). That’s good news because we will see that these entries are relatively cheap and easy to compute. Whereas the full inverse is dense and very expensive to compute.\nBut before we get to that, I need to point out a trap for young players39. Lest your implementations go down faster than me when someone asks politely.\nThe problem comes from how we store our matrix. A mathematician would suggest that it’s our representation. A physicist40 would shit on about being coordinate free with such passion that he41 will keep going even after you quietly leave the room.\nThe problem is that we only store the non-zero entries of the lower-triangular part of \\(A\\). This means that we need to be careful that when we compute the Jacobian-vector product that we properly compute the Matrix-vector product.\nLet A_indices and A_indptr define the sparsity structure of \\(A\\) (and \\(\\Delta\\)). Then if \\(A_x\\) is our input and \\(v\\) is our vector, then we need to do the follow steps to compute the Jacobian-vector product:\n\nCompute Ainv_x (aka the non-zero elements of \\(A^{-1}\\) that correspond to the sparsity pattern of \\(A\\))\nCompute the matrix vector product as\n\n\njvp = 2 * sum(Ainv_x * v) - sum(Ainv_x[A_indptr[:-1]] * v[A_indptr[:-1]])\n\nWhy does it look like that? Well we need to add the contribution from the upper triangle as well as the lower triangle. And one way to do that is to just double the sum and then subtract off the diagonal terms that we’ve counted twice.\n(I’m making a pretty big assumption here, which is fine in our context, that \\(A\\) has a non-zero diagonal. If that doesn’t hold, it’s just a change of the indexing in the second term to just pull out the diagonal terms.)\nUsing similar reasoning, we can compute the Jacobian as \\[\n[J_f(x)]_{i1} = \\begin{cases}\n\\operatorname{partial-inverse}(x)_i, \\qquad & x_i  \\text{ is a diagonal element of }A \\\\\n2\\operatorname{partial-inverse}(x)_i, \\qquad & \\text{otherwise},\n\\end{cases}\n\\] where \\(\\operatorname{partial-inverse}(x)\\) is the vector that stacks the columns of the elements of \\(A^{-1}\\) that correspond to the non-zero elements of \\(A\\). (Yikes!)\n\nComputing the partial inverse\nSo now we need to actually work out how to compute this partial inverse of a symmetric positive definite matrix \\(A\\). To do this, we are going to steal a technique that goes back to Takahashi, Fagan, and Chen42 in 1973. (For this presentation, I’m basically pillaging Håvard Rue and Sara Martino’s 2007 paper.)\nTheir idea was that if we write \\(A = VDV^T\\), where \\(V\\) is a lower-triangular matrix with ones on the diagonal and \\(D\\) is diagonal. This links up with our usual Cholesky factorisation through the identity \\(L = VD^{1/2}\\). It follows that if \\(S = A^{-1}\\), then \\(VDV^TS = I\\). Then, we make some magic manipulations43. \\[\\begin{align*}\nV^TS &= D^{-1}V^{-1} \\\\\nS + V^TS &= S + D^{-1}V^{-1} \\\\\nS &= D^{-1}V^{-1} + (I - V^T)S.\n\\end{align*}\\]\nOnce again, this does not look super-useful. The trick is to notice 2 things.\n\nBecause \\(V\\) is lower triangular, \\(V^{-1}\\) is also lower triangular and the elements of \\(V^{-1}\\) are the inverse of the diagonal elements of \\(V\\) (aka they are all 1). Therefore, \\(D^{-1}V^{-1}\\) is a lower triangular matrix with a diagonal given by the diagonal of \\(D^{-1}\\).\n\\(I - V^T\\) is an upper triangular matrix and \\([I - V^T]_{nn} = 0\\).\n\nThese two things together lead to the somewhat unexpected situation where the upper triangle of \\(S = D^{-1}V^{-1} + (I- V^T)S\\) defines a set of recursions for the upper triangle of \\(S\\). (And, therefore, all of \\(S\\) because \\(S\\) is symmetric!) These are sometimes referred to as the Takahashi recursions.\nBut we don’t want the whole upper triangle of \\(S\\), we just want the ones that correspond to the non-zero elements of \\(A\\). Unfortunately, the set of recursions are not, in general, solveable using only that subset of \\(S\\). But we are in luck: they are solveable using the elements of \\(S\\) that correspond to the non-zeros of \\(L + L^T\\), which, as we know from a few posts ago, is a superset of the non-zero elements of \\(A\\)!\nFrom this, we get the recursions running from \\(i = n, \\ldots, 1\\), \\(j = n, \\ldots, i\\) (the order is important!) such that \\(L_{ji} \\neq 0\\) \\[\nS_{ji} =   \\begin{cases}\n\\frac{1}{L_{ii}^2} - \\frac{1}{L_{ii}}\\sum_{k=i+1}^{n} L_{ki} S_{kj} \\qquad&  \\text{if } i=j, \\\\         \n- \\frac{1}{L_{ii}}\\sum_{k=i+1}^{n} L_{ki} S_{kj}  & \\text{otherwise}.\n\\end{cases}\n\\]\nIf you recall our discussion way back when about the way the non-zero structure of the \\(j\\) the column of \\(L\\) relates to the non-zero structure of the \\(i\\) th column for \\(j \\geq i\\), it’s clear that we have computed enough44 of \\(S\\) at every step to complete the recursions.\nNow we just need to Python it. (And thanks to Finn Lindgren who helped me understand how to implement this, which he may or may not remember because it happened about five years ago.)\nActually, we need this to be JAX-traceable, so we are going to implement a very basic primitive. In particular, we don’t need to implement a derivative or anything like that, just an abstract evaluation and an implementation.\n\nsparse_partial_inverse_p = core.Primitive(\"sparse_partial_inverse\")\n\ndef sparse_partial_inverse(L_indices, L_indptr, L_x, out_indices, out_indptr):\n  \"\"\"\n  Computes the elements (out_indices, out_indptr) of the inverse of a sparse matrix (A_indices, A_indptr, A_x)\n   with Choleksy factor (L_indices, L_indptr, L_x). (out_indices, out_indptr) is assumed to be either\n   the sparsity pattern of A or a subset of it in lower triangular form. \n  \"\"\"\n  return sparse_partial_inverse_p.bind(L_indices, L_indptr, L_x, out_indices, out_indptr)\n\n@sparse_partial_inverse_p.def_abstract_eval\ndef sparse_partial_inverse_abstract_eval(L_indices, L_indptr, L_x, out_indices, out_indptr):\n  return abstract_arrays.ShapedArray(out_indices.shape, L_x.dtype)\n\n@sparse_partial_inverse_p.def_impl\ndef sparse_partial_inverse_impl(L_indices, L_indptr, L_x, out_indices, out_indptr):\n  n = len(L_indptr) - 1\n  Linv = sparse.dok_array((n,n), dtype = L_x.dtype)\n  counter = len(L_x) - 1\n  for col in range(n-1, -1, -1):\n    for row in L_indices[L_indptr[col]:L_indptr[col+1]][::-1]:\n      if row != col:\n        Linv[row, col] = Linv[col, row] = 0.0\n      else:\n        Linv[row, col] = 1 / L_x[L_indptr[col]]**2\n      L_col  = L_x[L_indptr[col]+1:L_indptr[col+1]] / L_x[L_indptr[col]]\n \n      for k, L_kcol in zip(L_indices[L_indptr[col]+1:L_indptr[col+1]], L_col):\n         Linv[col,row] = Linv[row,col] =  Linv[row, col] -  L_kcol * Linv[k, row]\n        \n  Linv_x = sparse.tril(Linv, format = \"csc\").data\n  if len(out_indices) == len(L_indices):\n    return Linv_x\n\n  out_x = np.zeros(len(out_indices))\n  for col in range(n):\n    ind = np.nonzero(np.in1d(L_indices[L_indptr[col]:L_indptr[col+1]],\n      out_indices[out_indptr[col]:out_indptr[col+1]]))[0]\n    out_x[out_indptr[col]:out_indptr[col+1]] = Linv_x[L_indptr[col] + ind]\n  return out_x\n\nThe implementation makes use of the45 dictionary of keys representation of a sparse matrix from scipy.sparse. This is an efficient storage scheme when you need to modify the sparsity structure (as we are doing here) or do a lot of indexing. It would definitely be possible to implement this directly on the CSC data structure, but it gets a little bit tricky to access the elements of L_inv that are above the diagonal. The resulting code is honestly a mess and there’s lots of non-local memory access anyway, so I implemented it this way.\nBut let’s be honest: this thing is crying out for a proper symmetric matrix class with sensible reverse iterators. But hey. Python.\nThe second chunk of the code is just the opposite of our _structured_copy() function. It takes a matrix with the sparsity pattern of \\(L\\) and returns one with the sparsity pattern of out (which is assumed to be a subset, and is usually the sparsity pattern of \\(A\\) or a diagonal matrix).\nLet’s check that it works.\n\nA_indices, A_indptr, A_x, A = make_matrix(15)\nn = len(A_indptr) - 1\n\n\nL_indices, L_indptr, L_x = sparse_cholesky(A_indices, A_indptr, A_x)\n\na_inv_L = sparse_partial_inverse(L_indices, L_indptr, L_x, L_indices, L_indptr)\n\ncol_counts_L = [L_indptr[i+1] - L_indptr[i] for i in range(n)]\ncols_L = np.repeat(range(n), col_counts_L)\n\ntrue_inv = np.linalg.inv(A.todense())\ntruth_L = true_inv[L_indices, cols_L]\n\na_inv_A = sparse_partial_inverse(L_indices, L_indptr, L_x, A_indices, A_indptr)\ncol_counts_A = [A_indptr[i+1] - A_indptr[i] for i in range(n)]\ncols_A = np.repeat(range(n), col_counts_A)\ntruth_A = true_inv[A_indices, cols_A]\n\nprint(f\"\"\"\nError in partial inverse (all of L): {np.linalg.norm(a_inv_L - truth_L): .2e}\nError in partial inverse (all of A): {np.linalg.norm(a_inv_A - truth_A): .2e}\n\"\"\")\n\n\nError in partial inverse (all of L):  1.57e-15\nError in partial inverse (all of A):  1.53e-15\n\n\n\n\n\nPutting the log-determinant together\nAll of our bits are in place, so now all we need is to implement the primitive for the log-determinant. One nice thing here is that we don’t need to implement a transposition rule as the function is not structurally linear in any of its arguments. At this point we take our small wins where we can get them.\nThere isn’t anything particularly interesting in the implementation. But do note that the trace has been implemented in a way that’s aware that we’re only storing the bottom triangle of \\(A\\).\n\nsparse_log_det_p = core.Primitive(\"sparse_log_det\")\n\ndef sparse_log_det(A_indices, A_indptr, A_x):\n  return sparse_log_det_p.bind(A_indices, A_indptr, A_x)\n\n@sparse_log_det_p.def_impl\ndef sparse_log_det_impl(A_indices, A_indptr, A_x):\n  L_indices, L_indptr, L_x = sparse_cholesky(A_indices, A_indptr, A_x)\n  return 2.0 * jnp.sum(jnp.log(L_x[L_indptr[:-1]]))\n\n@sparse_log_det_p.def_abstract_eval\ndef sparse_log_det_abstract_eval(A_indices, A_indptr, A_x):\n  return abstract_arrays.ShapedArray((1,), A_x.dtype)\n\ndef sparse_log_det_value_and_jvp(arg_values, arg_tangent):\n  A_indices, A_indptr, A_x = arg_values\n  _, _, A_xt = arg_tangent\n  L_indices, L_indptr, L_x = sparse_cholesky(A_indices, A_indptr, A_x)\n  value = 2.0 * jnp.sum(jnp.log(L_x[L_indptr[:-1]]))\n  Ainv_x = sparse_partial_inverse(L_indices, L_indptr, L_x, A_indices, A_indptr)\n  jvp = 2.0 * sum(Ainv_x * A_xt) - sum(Ainv_x[A_indptr[:-1]] * A_xt[A_indptr[:-1]])\n  return value, jvp\n\nad.primitive_jvps[sparse_log_det_p] = sparse_log_det_value_and_jvp\n\nFinally, we can test it out.\n\nld_true = np.log(np.linalg.det(A.todense())) #np.sum(np.log(lu.U.diagonal()))\nprint(f\"Error in log-determinant = {ld_true - sparse_log_det(A_indices, A_indptr, A_x): .2e}\")\n\ndef f(theta):\n  Ax_theta = jnp.array(theta[0] * A_x) / n\n  Ax_theta = Ax_theta.at[A_indptr[:-1]].add(theta[1])\n  return sparse_log_det(A_indices, A_indptr, Ax_theta)\n\ndef f_jax(theta):\n  Ax_theta = jnp.array(theta[0] * A.todense()) / n \n  Ax_theta = Ax_theta.at[np.arange(n),np.arange(n)].add(theta[1])\n  L = jnp.linalg.cholesky(Ax_theta)\n  return 2.0*jnp.sum(jnp.log(jnp.diag(L)))\n\nprimal1, jvp1 = jvp(f, (jnp.array([2., 3.]),), (jnp.array([1., 2.]),))\nprimal2, jvp2 = jvp(f_jax, (jnp.array([2., 3.]),), (jnp.array([1., 2.]),))\n\neps = 1e-4\njvp_fd = (f(jnp.array([2.,3.]) + eps * jnp.array([1., 2.]) ) - f(jnp.array([2.,3.]))) / eps\n\ngrad1 = grad(f)(jnp.array([2., 3.]))\ngrad2 = grad(f_jax)(jnp.array([2., 3.]))\n\nprint(f\"\"\"\nCheck the Derivatives!\nVariable A:\n  Primal difference: {np.linalg.norm(primal1 - primal2)}\n  JVP difference: {np.linalg.norm(jvp1 - jvp2)}\n  JVP difference (FD): {np.linalg.norm(jvp1 - jvp_fd)}\n  Gradient difference: {np.linalg.norm(grad1 - grad2)}\n\"\"\")\n\nError in log-determinant =  0.00e+00\n\n\n\nCheck the Derivatives!\nVariable A:\n  Primal difference: 0.0\n  JVP difference: 0.000885009765625\n  JVP difference (FD): 0.221893310546875\n  Gradient difference: 1.526623782410752e-05\n\n\n\nI’m not going to lie, I am not happy with that JVP difference. I was somewhat concerned that there was a bug somewhere in my code. I did a little bit of exploring and the error got larger as the problem got larger. It also depended a little bit more than I was comfortable on how I had implemented46 the baseline dense version.\nThat second fact suggested to me that it might be a floating point problem. By default, JAX uses single precision (32-bit) floating point. Most modern systems that don’t try and run on GPUs use double precision (64-bit) floating point. So I tried it with double precision and lo and behold, the problem disappears.\nMatrix factorisations are bloody hard in single precision.\n\nfrom jax.config import config\nconfig.update(\"jax_enable_x64\", True)\n\nld_true = np.log(np.linalg.det(A.todense())) #np.sum(np.log(lu.U.diagonal()))\nprint(f\"Error in log-determinant = {ld_true - sparse_log_det(A_indices, A_indptr, A_x): .2e}\")\n\ndef f(theta):\n  Ax_theta = jnp.array(theta[0] * A_x, dtype = jnp.float64) / n\n  Ax_theta = Ax_theta.at[A_indptr[:-1]].add(theta[1])\n  return sparse_log_det(A_indices, A_indptr, Ax_theta)\n\ndef f_jax(theta):\n  Ax_theta = jnp.array(theta[0] * A.todense(), dtype = jnp.float64) / n \n  Ax_theta = Ax_theta.at[np.arange(n),np.arange(n)].add(theta[1])\n  L = jnp.linalg.cholesky(Ax_theta)\n  return 2.0*jnp.sum(jnp.log(jnp.diag(L)))\n\nprimal1, jvp1 = jvp(f, (jnp.array([2., 3.], dtype = jnp.float64),), (jnp.array([1., 2.], dtype = jnp.float64),))\nprimal2, jvp2 = jvp(f_jax, (jnp.array([2., 3.], dtype = jnp.float64),), (jnp.array([1., 2.], dtype = jnp.float64),))\n\neps = 1e-7\njvp_fd = (f(jnp.array([2.,3.], dtype = jnp.float64) + eps * jnp.array([1., 2.], dtype = jnp.float64) ) - f(jnp.array([2.,3.], dtype = jnp.float64))) / eps\n\ngrad1 = grad(f)(jnp.array([2., 3.], dtype = jnp.float64))\ngrad2 = grad(f_jax)(jnp.array([2., 3.], dtype = jnp.float64))\n\nprint(f\"\"\"\nCheck the Derivatives!\nVariable A:\n  Primal difference: {np.linalg.norm(primal1 - primal2)}\n  JVP difference: {np.linalg.norm(jvp1 - jvp2)}\n  JVP difference (FD): {np.linalg.norm(jvp1 - jvp_fd)}\n  Gradient difference: {np.linalg.norm(grad1 - grad2)}\n\"\"\")\n\nError in log-determinant =  0.00e+00\n\n\n\nCheck the Derivatives!\nVariable A:\n  Primal difference: 0.0\n  JVP difference: 8.526512829121202e-13\n  JVP difference (FD): 4.171707900013644e-06\n  Gradient difference: 8.881784197001252e-16\n\n\n\nMuch better!"
  },
  {
    "objectID": "posts/2022-05-20-to-catch-a-derivative-first-youve-got-to-think-like-a-derivative/to-catch-a-derivative-first-youve-got-to-think-like-a-derivative.html#wrapping-up",
    "href": "posts/2022-05-20-to-catch-a-derivative-first-youve-got-to-think-like-a-derivative/to-catch-a-derivative-first-youve-got-to-think-like-a-derivative.html#wrapping-up",
    "title": "Sparse matrices 6: To catch a derivative, first you’ve got to think like a derivative",
    "section": "Wrapping up",
    "text": "Wrapping up\nAnd that is where we will leave it for today. Next up, I’m probably going to need to do the autodiff for the Cholesky factorisation. It’s not hard, but it is tedious47 and this post is already very long.\nAfter that we need a few more things:\n\nCompilation rules for all of these things. For the most part, we can just wrap the relevant parts of Eigen. The only non-trivial code would be the partial inverse. That will allow us to JIT shit.\nWe need to beef up the sparse matrix class a little. In particular, we are going to need addition and scalar multiplication at the very minimum to make this useful.\nWork out how Aesara works so we can try to prototype a PyMC model.\n\nThat will be a lot more blog posts. But I’m having fun. So why the hell not."
  },
  {
    "objectID": "posts/2021-12-08-the-king-must-die-repost/the-king-must-die-repost.html",
    "href": "posts/2021-12-08-the-king-must-die-repost/the-king-must-die-repost.html",
    "title": "The king must die (repost)",
    "section": "",
    "text": "And then there was Yodeling Elaine, the Queen of the Air. She had a dollar sign medallion about as big as a dinner plate around her neck and a tiny bubble of spittle around her nostril and a little rusty tear, for she had lassoed and lost another tipsy sailor—Tom Waits\nIt turns out I turned thirty two1 and became unbearable. Some of you may feel, with an increasing sense of temporal dissonance, that I was already unbearable2. Others will wonder how I can look so good at my age3. None of that matters to me because all I want to do is talk about the evils of marketing like the 90s were a vaguely good idea4.\nThe thing is, I worry that the real problem in academic statistics in 2017 is not a reproducibility crisis, so much as that so many of our methods just don’t work. And to be honest, I don’t really know what to do about that, other than suggest that we tighten our standards and insist that people proposing new methods, models, and algorithms work harder to sketch out the boundaries of their creations. (What a suggestion. Really. Concrete proposals for concrete change. But it’s a blog. If ever there was a medium to be half-arsed in it’s this one. It’s like twitter for people who aren’t pithy.)"
  },
  {
    "objectID": "posts/2021-12-08-the-king-must-die-repost/the-king-must-die-repost.html#berätta-för-mig-om-det-är-sant-att-din-hud-är-doppad-i-honung",
    "href": "posts/2021-12-08-the-king-must-die-repost/the-king-must-die-repost.html#berätta-för-mig-om-det-är-sant-att-din-hud-är-doppad-i-honung",
    "title": "The king must die (repost)",
    "section": "Berätta för mig om det är sant att din hud är doppad i honung",
    "text": "Berätta för mig om det är sant att din hud är doppad i honung\nSo what is the object of my impotent ire today. Well nothing less storied than the Bayesian Lasso.\nIt should be the least controversial thing in this, the year of our lord two thousand and seventeen, to point out that this method bears no practical resemblance to the Lasso. Or, in the words of Law and Order: SVU, “The [Bayesian Lasso] is fictional and does not depict any actual person or event”."
  },
  {
    "objectID": "posts/2021-12-08-the-king-must-die-repost/the-king-must-die-repost.html#who-do-you-think-you-are",
    "href": "posts/2021-12-08-the-king-must-die-repost/the-king-must-die-repost.html#who-do-you-think-you-are",
    "title": "The king must die (repost)",
    "section": "Who do you think you are?",
    "text": "Who do you think you are?\nThe Bayesian Lasso is a good example of what’s commonly known as the Lupita Nyong’o fallacy5, which goes something like this: Lupita Nyong’o had a break out role in Twelve Years a Slave, she also had a heavily disguised role in one of ’ the Star Wars films (the specific Star Wars film is not important. I haven’t seen it and I don’t care). Hence Twelve Years a Slave exists in the extended Star Wars universe.6\nThe key point is that the (classical) Lasso plays a small part within the Bayesian Lasso (it’s the MAP estimate) in the same way that Lupita Nyong’o played a small role in that Star Wars film. But just as the presence of Ms Nyong’o does not turn Star Wars into Twelve Years a Slave, the fact that the classical Lasso can be recovered as the MAP estimate of the Bayesian Lasso does not make the Bayesian Lasso useful.\nAnd yet people still ask if they can be fit in Stan. In that case, Andrew answered the question that was asked, which is typically the best way to deal with software enquiries7. But I am brave and was not asked for my opinion, so I’m going to talk about why the Bayesian Lasso doesn’t work."
  },
  {
    "objectID": "posts/2021-12-08-the-king-must-die-repost/the-king-must-die-repost.html#hiding-all-away",
    "href": "posts/2021-12-08-the-king-must-die-repost/the-king-must-die-repost.html#hiding-all-away",
    "title": "The king must die (repost)",
    "section": "Hiding all away",
    "text": "Hiding all away\nSo why would anyone not know that the Bayesian Lasso doesn’t work? Well, I don’t really know. But I will point out that all of the results that I’ve seen in this directions (not that I’ve been looking hard) have been published in the prestigious but obtuse places like Annals of Statistics, the journal we publish in when we either don’t want people without a graduate degree in mathematical statistics to understand us or when we want to get tenure.\nBy contrast, the original paper is very readable and published in JASA, where we put papers when we are ok with people who do not have a graduate degree in mathematical statistics being able to read them, or when we want to get tenure8.\nTo be fair to Park and Casella, they never really say that the Baysian Lasso should be used for sparsity. Except for one sentence in the introduction where they say the median gives approximately sparse estimators and the title which links it to the most prominent and popular method for estimating a sparse signal. Marketing eh. (See, I’m Canadian now9).\n##The devil has designed my death and is waiting to be sure\nSo what is the Bayesian LASSO (and why did I spend 600 words harping on about something before defining it? The answer will shock you. Actually the answer will not shock you, it’s because it’s kinda hard to do equations on this thing10.)\nFor data observed with Gaussian error, the Bayesian Lasso takes the form \\[\n\\mathbf{y} \\mid \\boldsymbol{\\beta} \\sim N( \\mathbf{X} \\boldsymbol{\\beta}, \\boldsymbol{\\Sigma})\n\\]\nwhere, instead of putting a Normal prior on \\(\\boldsymbol{\\beta}\\) as we would in a bog-standard Bayesian regression, we instead use independent Laplace priors \\[\np(\\beta_i) = \\frac{\\lambda}{2} \\exp(-\\lambda | \\beta_i|).\n\\]\nHere the tuning parameter11 \\(\\lambda = c(p,s_0,\\mathbf{X})\\tilde{\\lambda}\\) where \\(p\\) is the number of covariates, \\(s_0\\) is the number of “true” non-zero elements of \\(\\boldsymbol{\\beta}\\), \\(\\boldsymbol{\\Sigma}\\) is known, and \\(\\tilde{\\lambda}\\) is an unknown scaling parameter that should be \\(\\mathcal{O}(1)\\).\nImportant Side note: This isn’t the exact same model as Park and Castella used as they didn’t use the transformation \\[\n\\lambda = c(p,s_0,\\mathbf{X}) \\tilde{\\lambda}\n\\] but rather just dealt with \\(\\lambda\\) as the parameter. We will see below, and it’s born out by many papers in this field, that the best possible value of \\(\\lambda\\) will depend on this structural/design information\nIf we know how \\(\\lambda\\) varies as the structural/design information changes, it’s a much better idea to put a prior on \\(\\tilde{\\lambda}\\) than on \\(\\lambda\\) directly. Why? Because a prior on \\(\\lambda\\) needs to depend on p, \\(s_0\\), and X and hence needs to be changed for each problem, while a prior on \\(\\tilde{\\lambda}\\) can be used for many problems. One possible option is \\(c(p,s_0,\\mathbf{X}) = 2\\|\\mathbf{X}\\|\\sqrt{\\log p }\\), which is a rate optimal parameter for the (non-Bayesian) Lasso. Later, we’ll do a back-of-the-envelope calculation that suggests we might not need the square root around the logarithmic term.\n\nWhy do we scale priors\nThe critical idea behind the Bayesian Lasso is that we can use the i.i.d. Laplace priors to express the substantive belief that the most of the \\(\\beta_j\\) are (approximately) zero. The reason for scaling the prior is that the values of \\(\\lambda\\) that are consistent with this belief depend on \\(p\\), \\(s_0\\), and \\(X\\).\nFor example, \\(\\lambda = 1\\), the Bayesian Lasso will not give an approximately sparse signal.\nWhile we could just use a prior for \\(\\lambda\\) that has a very heavy right tail (something like an inverse gamma), this is at odds with a good practice principle of making sure all of thee parameters in your models are properly scaled to make them order 1. Why do we do this? Because it makes it much much easier to set sensible priors.\nSome of you may have noticed that the scaling \\(c(p,s_0,\\mathbf{X})\\) can depend on the unknown sparsity \\(s_0\\). This seems like cheating. People who do asymptotic theory call this sort of value for \\(\\lambda\\) an oracle value, mainly because people studying Bayesian asymptotics are really really into database software.\nThe idea is that this is the value of \\(\\lambda\\) that gives the model the best chance of working. When maths-ing, you work out the properties of the posterior with the oracle value of \\(\\lambda\\) and then you use some sort of smoothness argument to show that the actual method that is being used to select (or average over) the parameter gives almost the same answer.\nIt’s also worth noting that the scaling here doesn’t (directly12) depend on the number of observations, only the number of covariates. This is appropriate: it’s ok for priors to depend on things that should be known a priori (like the number of parameters) or things that can be worked with13 (like the scaling of \\(X\\)). It’s a bit weirder if it depends on the number of observations (that tends to break things like coherent Bayesian updating, while the other dependencies don’t)."
  },
  {
    "objectID": "posts/2021-12-08-the-king-must-die-repost/the-king-must-die-repost.html#only-once-in-sheboygan.-only-once.",
    "href": "posts/2021-12-08-the-king-must-die-repost/the-king-must-die-repost.html#only-once-in-sheboygan.-only-once.",
    "title": "The king must die (repost)",
    "section": "Only once in Sheboygan. Only once.",
    "text": "Only once in Sheboygan. Only once.\nSo what’s wrong with the Bayesian Lasso? Well the short version is that the Laplace prior doesn’t have enough mass near zero relative to the mass in the tails to allow for a posterior that has a lot of entries that are almost zero and some entries that are emphatically not zero.\nBecause the Bayesian Lasso prior does not have a spike at zero, none of the entries will be a priori exactly zero, so we need some sort of rule to separate the “zero” entries from the “non-zero” entries. The way that we’re going to do this is to choose a cutoff \\(\\epsilon\\) where we assume that if \\(|\\beta_j| <\\epsilon\\), then \\(\\beta_j =0\\).\nSo how do we know that the Lasso prior doesn’t put enough mass in important parts of the parameter space? Well there are two ways. I learnt it during the exciting process of writing a paper that the reviewers insisted should have an extended section about sparsity (although this was at best tangential to the rest of the paper), so I suddenly needed to know about Bayesian models of sparsity. So I read those Annals of Stats papers. (That’s why I know I should be scaling \\(\\lambda\\)!).\nWhat are the key references? Well all the knowledge that you seek is here and here.\nBut a much easier way to work out that the Bayesian Lasso is bad is to do some simple maths.\nBecause the \\(\\beta_j\\) are a priori independent, we get a prior on the effective sparsity \\(s_\\epsilon = \\#\\{j : |\\beta_j| > \\epsilon\\}\\) \\[\ns_\\epsilon \\sim \\text{Bin}(p, \\Pr(|\\beta_j| > \\epsilon)).\n\\] For the Bayesian Lasso, that probability can be computed as \\[\n\\Pr ( | \\beta_j | > \\epsilon ) = e^{- \\lambda \\epsilon},\n\\] so \\[\ns_\\epsilon \\sim \\text{Bin}\\left(p, e^{-\\lambda \\epsilon}\\right).\n\\]\nIdeally, the distribution of this effective sparsity would be centred on the true sparsity.\nSo we’d like to choose \\(\\lambda\\) so that \\[\n\\mathbb{E}(s_\\epsilon)= p e^{- \\lambda \\epsilon}= s_0.\n\\]\nA quick re-arrangement suggests that \\[\n\\lambda = \\epsilon^{-1} \\log(p) - \\epsilon^{-1} \\log(s_0).\n\\]\nNow, we are interested in signals with \\(s_0 = o(p)\\), i.e. where only a very small number of the \\(\\beta_j\\) are non-zero. This suggests we can safely ignore the second term as it will be much smaller than the first term.\nTo choose \\(\\epsilon\\), we can work from the general principle that we want to choose it so that the effect of the “almost zero” \\(\\beta_j\\) \\[\n\\sum_{j:|\\beta_j| < \\epsilon} \\beta_j X_{:j}\n\\] is small. (here \\(X_{:j}\\) is the \\(j\\)th column of the matrix \\(X\\).)\nFrom this, it’s pretty clear that \\(\\epsilon\\) is going to have to depend on \\(p\\), \\(s_0\\), and \\(X\\) as well! But how?\nWell, first we note that \\[\n\\sum_{j:|\\beta_j| < \\epsilon} \\beta_j X_{:j} \\leq \\epsilon \\max_{i =1,\\ldots, n}\\sum_{j=1}^p |X_{ij}| = \\epsilon \\|X\\|_\\infty.\n\\] Hence we can make this asymptotically small (as \\(p\\rightarrow \\infty\\)) if \\[\n\\epsilon = o\\left(\\|X\\|_\\infty^{-1}\\right).\n\\] Critically, if we have scaled the design matrix so that each covariate is at most \\(1\\), ie \\[\n\\max_{i=1,\\ldots,n} |X_{ij}| \\leq 1, \\qquad \\text{for all } j = 1,\\ldots, p,\n\\] then this reduces to the much more warm and fuzzy \\[\n\\epsilon = o\\left(p^{-1}\\right).\n\\]\nThis means that we need to take \\(\\lambda = \\mathcal{O}(p \\log(p))\\) in order to ensure that we have our prior centred on sparse vectors (in the sense that the prior mean for the number of non-zero components is always much less than \\(p\\))."
  },
  {
    "objectID": "posts/2021-12-08-the-king-must-die-repost/the-king-must-die-repost.html#show-some-emotion",
    "href": "posts/2021-12-08-the-king-must-die-repost/the-king-must-die-repost.html#show-some-emotion",
    "title": "The king must die (repost)",
    "section": "Show some emotion",
    "text": "Show some emotion\n\n\n\n\n\nSo for the Bayesian Lasso, a sensible parameter is \\(\\lambda = p\\log p\\), which will usually have a large number of components less than the threshold \\(\\epsilon\\) and a small number that are larger.\nBut this is still a bad prior.\nTo see this, let’s consider the prior probability of seeing a \\(\\beta_j\\) larger than one \\[\n\\Pr ( | \\beta_j | > 1) = p^{-p} \\downarrow \\downarrow \\downarrow 0.\n\\]\nThis is the problem with the Bayesian Lasso: in order to have a lot of zeros in the signal, you are also forcing the non-zero elements to be very small. A plot of this function is above, and it’s clear that even for very small values of \\(p\\) the probability of seeing a coefficient bigger than one is crushingly small.\nBasically, the Bayesian Lasso can’t give enough mass to both small and large signals simultaneously. Other Bayesian models (such as the horseshoe and the Finnish horseshoe) can support both simultaneously and this type of calculation can show that (although it’s harder. See Theorem 6 here).\n(The scaling that I derived in the previous section is a little different to the standard Lasso scaling of \\(\\lambda = \\mathcal{O} (p \\sqrt{\\log p})\\), but the same result holds: for large \\(p\\) the probability of seeing a large signal is vanishingly small.)"
  },
  {
    "objectID": "posts/2021-12-08-the-king-must-die-repost/the-king-must-die-repost.html#maybe-i-was-mean-but-i-really-dont-think-so",
    "href": "posts/2021-12-08-the-king-must-die-repost/the-king-must-die-repost.html#maybe-i-was-mean-but-i-really-dont-think-so",
    "title": "The king must die (repost)",
    "section": "Maybe I was mean, but I really don’t think so",
    "text": "Maybe I was mean, but I really don’t think so\nThis analysis is all very back of the envelope, but it contains a solid grain of truth14.\nIf you fit a Bayesian Lasso in Stan with an unknown scaling parameter \\(\\lambda\\), you will not see estimates that are all zero, like this analysis suggests. This is because the posterior for \\(\\lambda\\) tries to find the values of the parameters that best fit the data and not the values that give an \\(\\epsilon\\)-sparse signal.\nIn order to fit the data, it is important that the useful covariates have large \\(\\beta\\)s, which, in turn, forces the \\(\\beta\\)s that should be zero to be larger than our dreamt of \\(\\epsilon\\).\nAnd so you see posteriors constructed with the Bayesian Lasso exisiting in some sort of eternal tension: the small \\(\\beta\\)s are too big, and the large \\(\\beta\\)s are typically shrunken towards zero.\nIt’s the sort of compromise that leaves everyone unhappy.\nLet’s close it out with the title song.\n\nAnd I’m so afraid your courtiers\nCannot be called best friends\n\nLightly re-touched from the original, posted on Andrew’s blog. Orignal verison, 2 November, 2017."
  },
  {
    "objectID": "posts/2021-10-14-priors1/priors1.html",
    "href": "posts/2021-10-14-priors1/priors1.html",
    "title": "Priors: Night work (Track 1)",
    "section": "",
    "text": "I have feelings. Too many feelings. And ninety six point seven three percent of them are about prior distributions1. So I am going to write a few blog posts about prior distributions.\nTo be very honest, this is mostly a writing exercise2 to get me out of a slump.\nSo let’s do this."
  },
  {
    "objectID": "posts/2021-10-14-priors1/priors1.html#no-love-deep-web",
    "href": "posts/2021-10-14-priors1/priors1.html#no-love-deep-web",
    "title": "Priors: Night work (Track 1)",
    "section": "No love, deep web",
    "text": "No love, deep web\nAs far as I am concerned it’s really fucking stupid to try to write about priors on their own. They are meaningless outside of their context. But, you know, this is a blog. So I get to be stupid.\nSo what is a prior distribution? It is whatever you want it to be. It is a probability distribution3 that … I don’t know. Exists4.\nOk. This is not going well. Let’s try again.\nA prior distribution is, most of the time, a probability distribution on the parameters of a statistical model. For all practical purposes, we tend to work with its density, so if the parameter \\(\\theta\\), which could be a scalar but, in any interesting case, isn’t, has prior \\(p(\\theta)\\)."
  },
  {
    "objectID": "posts/2021-10-14-priors1/priors1.html#captain-fantastic-and-the-brown-dirt-cowboy",
    "href": "posts/2021-10-14-priors1/priors1.html#captain-fantastic-and-the-brown-dirt-cowboy",
    "title": "Priors: Night work (Track 1)",
    "section": "Captain fantastic and the brown dirt cowboy",
    "text": "Captain fantastic and the brown dirt cowboy\nBut what does it all meeeeeeeean?\nWe have a prior distribution specified, gloriously, by it’s density. And unlike destiny, density is meaningless. It only makes sense when we integrate it up to get a probability \\[\n\\Pr(A) = \\int_A p(\\theta)\\,d\\theta.\n\\]\nSo what does the prior probabilty \\(\\Pr(A)\\) of a set \\(A\\) actually mean in real life? The answer may shock you: it means something between nothing and everything.\nScenario 1: Let’s imagine that we were trying to estimate the probability that someone in some relative homogeneous subgroup of customers completed a purchase on our website. It’s a binary process, so the parameter of interest can probably just be the probability that a sale is made. While we don’t know what the probability of a sale is for the subgroup of interest, we know a lot sales on our website in general (in particular, we know that about 3% of visits result in sales). So if I also believe that it would be wildly unlikely for 20% of visits to result in a sale, I could posit a prior like a \\(\\text{Beta}(0.4,5)\\) prior that captures (a version of) these two pieces of information.\n\n  ## Step 1: \n  \nfn <- \\(x) (qbeta(0.5,x[1], x[2]) - 0.02)^2 + \n  (qbeta(0.9, x[1], x[2]) - 0.2)^2\n\nbest <- optim(c(1/2,1/2), fn)\n\n## Step 3: Profit.\n## (AKA round and check)\nqbeta(0.9, 0.4, 5)\nqbeta(0.5, 0.4, 5)\n\nScenario 2: Let’s imagine I want to do variable selection. I don’t know why. I was just told I want to do variable selection. So I fire up the Bayesian Lasso5 and then threshold in some way. In this case, the prior encode a hoped-for property of my posterior. (To paraphrase Lana, hope is a dangerous thing for a woman like you to have because the Bayeisan Lasso does not work to the point that the original paper doesn’t even suggest using it for variable selection6 it just, idk, liked the name. Statistics is wild.)\nScenario 3: I’m doing a regression with just one variable (because why not) and I think that the relationship between the response \\(y\\) and the covariate \\(x\\) is non-linear. That is, I think there is some unknown to me function \\(f(x)\\) such that \\(\\mathbb{E}(y_i) = f(x_i)\\). So I ask a friend and they tell me to use a Gaussian Process prior for \\(f(\\cdot)\\) with an exponential covariance function.\nWhile I can write down the density for the joint prior of \\((f(x_1), f(x_2,), \\ldots, f(x_n))\\), I do not know7 what this prior means in any substantive sense. But I can tell you, you’re gonna need that maths degree to even try.\nAnd should you look deeper, you will find more and more scenarios where priors are doing different things for different reasons8. For each of these priors in each of these scenarios, we will be able to compute the posterior (or a reasonable computational approximation to it) and then work with that posterior to answer our questions.\nDifferent people9 will use priors different ways even for very similar problems10. This remains true even though they are nominally working under the same inferential framework.\nBayesians are chaotic."
  },
  {
    "objectID": "posts/2021-10-14-priors1/priors1.html#mapping-out-a-sky-what-you-feel-like-planning-a-sky",
    "href": "posts/2021-10-14-priors1/priors1.html#mapping-out-a-sky-what-you-feel-like-planning-a-sky",
    "title": "Priors: Night work (Track 1)",
    "section": "Mapping out a sky / What you feel like, planning a sky",
    "text": "Mapping out a sky / What you feel like, planning a sky\nSondheim’s ode to pointillism feels relevant here. The reality of the prior distribution—and the whole reason the concept is so slippery and chaotic—is that you are, dot by dot, constructing the world of your inference. This act of construction is fundamental to understanding how Bayesian methods work, how to justify your choices, and how to use a Bayesian workflow to solve complex problems.\nTo torture the metaphor, our prior distribution is just our paint, unmixed, slowly congealing, possibly made of ground up mummys. It is nothing without a painter and a brush.\nThe painter is the likelihood or, more generally, the generative link between the parameter values and the actual data, \\(p(y \\mid \\theta)\\). The brush is the computational engine you use to actually produce the posterior painting11.\nThis then speaks to the core challenge with writing about priors: it depends on how you use them. It is a fallacy, or perhaps a foolishness, or perhaps a heresy12. Hell, when trying to understand a single inference The Prior Can Only Be Understood In The Context Of The Likelihood13. In the context of an entire workflow, The Experiment is just as Important as the Likelihood in Understanding the Prior.\nFor instance, using independent Cauchy priors for the coefficients in a linear regression model will result in a perfectly ok posterior. Whereas the same priors used in a logistic regression, you may end up with posteriors with such heavy tails that they don’t have a mean! (Do we care? Well, yes. If we want reasonable uncertainty intervals we probably want 2 or so moments otherwise those large deviations are gonna getcha!)"
  },
  {
    "objectID": "posts/2021-10-14-priors1/priors1.html#so-what",
    "href": "posts/2021-10-14-priors1/priors1.html#so-what",
    "title": "Priors: Night work (Track 1)",
    "section": "So what?",
    "text": "So what?\nAll of this is fascinating. And it is a lot less chaotic than it initially sounds.\nThe reality is that while two Bayesians may use different priors and, hence, produce different posteriors for the same data set.This can be extreme. For example, if I am trying to estimate the mean of data generated by \\(y_i \\sim N(\\mu, 1)\\), then I can choose a prior14 (that depends on the data) so that the posterior mean \\(\\mathbb{E}(\\mu \\mid y) =1\\). Or, to put it differently, I can get any answer I want if I choose an prior carefully (and in a data-dependent manner).\nBut this isn’t necessarily a problem. This is because the posteriors produced by two sensible priors for the same problem will produce fairly similar results15. The prior I used to cheat in the previous example would not be considered sensible by anyone looking at it16.\nBut what is a sensible prior? Can you tell if a prior is sensible or not in its particular context? Well honey, how long have you got. The thing about starting a (potential) series of blog posts is that I don’t really know how far I’m going to get, but I would really like to talk a lot about that over the next little while."
  },
  {
    "objectID": "posts/2022-03-23-getting-jax-to-love-sparse-matrices/getting-jax-to-love-sparse-matrices.html",
    "href": "posts/2022-03-23-getting-jax-to-love-sparse-matrices/getting-jax-to-love-sparse-matrices.html",
    "title": "Sparse Matrices 2: An invitation to a sparse Cholesky factorisation",
    "section": "",
    "text": "This is part two of an ongoing exercise in hubris. Part one is here."
  },
  {
    "objectID": "posts/2022-03-23-getting-jax-to-love-sparse-matrices/getting-jax-to-love-sparse-matrices.html#so-how-do-we-store-a-sparse-matrix",
    "href": "posts/2022-03-23-getting-jax-to-love-sparse-matrices/getting-jax-to-love-sparse-matrices.html#so-how-do-we-store-a-sparse-matrix",
    "title": "Sparse Matrices 2: An invitation to a sparse Cholesky factorisation",
    "section": "So how do we store a sparse matrix?",
    "text": "So how do we store a sparse matrix?\nIf we look at the Cholesky algorithm, we notice that we are scanning through the matrix column-by-column. When a computer stores a matrix, it stores it as a long 1D array with some side information. How this array is constructed from the matrix depends on the language.\nThere are (roughly) two options: column-major or row-major storage. Column major storage (used by Fortran8, R, Matlab, Julia, Eigen, etc) stacks a matrix column by column. A small example: \\[\n\\begin{pmatrix}1&3&5\\\\2&4&6 \\end{pmatrix} \\Rightarrow [1,2,3,4,5,6].\n\\] Row-mjor ordering (C/C++ arrays, SAS, Pascal, numpy9) stores things row-by-row.\nWhich one do we use? Well. If you look at the Cholesky algorithm, it scans through the matrix column-by-column. It is much much much more memory efficient in this case to have the whole column available in one contiguous chunk of memory. So we are going to use column-major storage.\nBut there’s an extra wrinkle: Most of the entries in our matrix are zero. It would be very inefficient to store all of those zeros. You may be sceptical about this, but it’s true. It helps to realize that even in the examples at the bottom of this post that are not trying very hard to minimise the fill in, only 3-4% of the potential elements in \\(L\\) are non-zero.\nIt is far more efficient to just store the locations10 of the non-zeros and their values. If only 4% of your matrix is non-zero, you are saving11 a lot of memory!\nThe storage scheme we are inching towards is called compressed sparse column (CSC) storage. This stores the matrix in three arrays. The first array indices (which has as many entries as there are non-zeros) stores the row numbers for each non-zero element. So if \\[\nB = \\begin{pmatrix}\n1 &&5 \\\\\n2&3& \\\\\n&4&6\n\\end{pmatrix}\n\\] then (using zero-based indices because I’ve to to make this work in Python)\n\nB_indices = [0,1,1,2,0,3]\n\nThe second array indptr is an \\(n+1\\)-dimensional array that indexes the first element of each row. The final element of indptr is nnz(B)12. This leads to\n\nB_indptr = [0,2,4,6]\n\nThis means that the entries in column13 j are have row numbers\n\nB_indices[B_indptr[j]:B_indptr[j+1]]\n\nThe third and final array is x, which stores the values of the non-negative entries of \\(A\\) column-by-column. This gives\n\nB_x = [1,2,3,4,5,6]\n\nUsing these three arrays we can get access to the jth row of \\(B\\) by accessing\n\nB_x[B_indptr[j]:B_indptr[j+1]]\n\nThis storage scheme is very efficient for what we are about to do. But it is fundamentally a static scheme: it is extremely expensive to add a new non-zero element. There are other sparse matrix storage schemes that make this work better."
  },
  {
    "objectID": "posts/2022-03-23-getting-jax-to-love-sparse-matrices/getting-jax-to-love-sparse-matrices.html#how-sparse-is-a-cholesky-factor-of-a-sparse-matrix",
    "href": "posts/2022-03-23-getting-jax-to-love-sparse-matrices/getting-jax-to-love-sparse-matrices.html#how-sparse-is-a-cholesky-factor-of-a-sparse-matrix",
    "title": "Sparse Matrices 2: An invitation to a sparse Cholesky factorisation",
    "section": "How sparse is a Cholesky factor of a sparse matrix?",
    "text": "How sparse is a Cholesky factor of a sparse matrix?\nOk. So now we’ve got that out of the way, we need to work out the sparsity structure of a Choleksy factorisation. At this point we need to close our eyes, pray, and start thinking about graphs.\nWhy graphs? I promise, it is not because I love discrete14 maths. It is because symmetric sparse matrices are strongly related to graphs.\nTo remind people, a graph15 (in a mathematical sense) \\(\\mathcal{G} = (\\mathcal{V}, \\mathcal{E})\\) consists of two lists:\n\nA list of vertices \\(\\mathcal{V}\\) numbered from \\(1\\) to \\(n\\)16.\nA list of edges \\(\\mathcal{E}\\) in the graph (aka all the pairs \\((i,j)\\) such that \\(i<j\\) and there is an edge between \\(i\\) and \\(j\\)).\n\nEvery symmetric sparse matrix \\(A\\) has a graph naturally associated with it. The relationship is that \\((i,j)\\) (for \\(i\\neq j\\)) is an edge in \\(\\mathcal{G}\\) if and only if \\(A_{ij} \\neq 0\\).\nSo, for instance, if \\[\nA = \\begin{pmatrix}\n1&2&&8 \\\\\n2&3&& 5\\\\\n&&4&6 \\\\\n8&5&6&7\n\\end{pmatrix},\n\\]\nthen we can plot the associated graph, \\(\\mathcal{G}\\).\n\n\n\n\n\nBut why do we care about graphs?\nWe care because they let us answer our question for this section: which elements of the Cholesky factor \\(L\\) are non-zero?\nIt is useful to write the algorithm out for a second time17, but this time closer to how we will implement it.\n\n\n\n\nL = np.tril(A)\nfor j in range(n):\n  for k in range(j-1):\n    L[j:n, j] -= L[j, k] * L[j:n, k]\n  L[j,j]= np.sqrt(L[j,j])\n  L[j+1:n, j] = L[j+1:n] / L[j, j]\n\nIf we stare at this long enough we can work out when \\(L_{ij}\\) is going to be potentially non-zero.\nAnd here is where we have to take a quick zoom out. We are not interested if the numerical entry \\(L_{ij}\\) is actually non-zero. We are interested if it could be non-zero. Why? Because this will allow us to set up our storage scheme for the sparse Cholesky factor. And it will tell us exactly which bits of the above loops we actually need to do!\nSo with that motivation in mind, can we spot the non-zeros? Well. I’ll be honest with you. I struggle at this game. This is part of why I do not like thinking about graphs18. But with a piece of paper and a bit of time, I can convince myslef that \\(L_ij\\) is potentially non-zero (or a structural non-zero) if:\n\n\\(A_{ij}\\) is non-zero (because tmp[i-j] is non-zero!), or\n\\(L_{ik} \\neq 0\\) and \\(L_{jk} \\neq 0\\) for some \\(k < \\min\\{i, j\\}\\) (because that is the only time an element of tmp is updated through tmp[i] = tmp[i] - L[i, k] * L[j, k])\n\nIf we dig into the second condition a bit more,19 we notice that the second case can happen if and only if there is a path in \\(\\mathcal{G}\\)20 from node \\(i\\) to node \\(j\\) \\[\ni \\rightarrow v_1 \\rightarrow v_2 \\rightarrow \\ldots \\rightarrow v_{\\ell-1} \\rightarrow j\n\\] with \\(v_1, \\ldots v_{\\ell-1} < \\min\\{i,j\\}\\). The proof is an induction on \\(\\min\\{i,j\\}\\) that I can’t be arsed typing out.\n(As an aside, Theorem 2.8 in Rue and Held’s book gives a very clearn nice statistical proof of this result.)\nThis is enough to see that fill in patterns are going to be a complex thing.\n\nA toy example\nConsider the following graph\n\n\n\n\n\nIt’s pretty clear that there is a path between \\((i,j)\\) for every pair \\((i,j)\\) (the path goes through the fully connected vertex, which is labelled 1).\nAnd indeed, we can check this numerically21\n\nlibrary(Matrix)\nn <- 6\nA <- sparseMatrix(i = c(1:n, rep(1,n)), \n                  j = c(rep(1,n),1:n), \n                  x = -0.2, \n                  dims = c(n,n)) + \n      Diagonal(n)\nA != 0 #print the non-zero structrure\n\n6 x 6 sparse Matrix of class \"lgCMatrix\"\n                \n[1,] | | | | | |\n[2,] | | . . . .\n[3,] | . | . . .\n[4,] | . . | . .\n[5,] | . . . | .\n[6,] | . . . . |\n\nL = t(chol(as.matrix(A))) # transpose is for R reasons\nround(L, digits = 1) # Fully dense!\n\n     [,1] [,2] [,3] [,4] [,5] [,6]\n[1,]  0.8  0.0  0.0  0.0  0.0    0\n[2,] -0.3  1.0  0.0  0.0  0.0    0\n[3,] -0.3 -0.1  1.0  0.0  0.0    0\n[4,] -0.3 -0.1 -0.1  1.0  0.0    0\n[5,] -0.3 -0.1 -0.1 -0.1  1.0    0\n[6,] -0.3 -0.1 -0.1 -0.1 -0.1    1\n\n\nBut what if we changed the labels of our vertices? What is the fill in pattern implied by a labelling where the fully collected vertex is labelled last instead of first?\n\n\n\n\n\nThere are now no paths from \\(i\\) to \\(j\\) that only go through lower-numbered vertices. So there is no fill in! We can check this numerically!22\n\nA2 <- A[n:1,n:1]\nL2 <- t(chol(A2))\nL2!=0\n\n6 x 6 sparse Matrix of class \"ltCMatrix\"\n                \n[1,] | . . . . .\n[2,] . | . . . .\n[3,] . . | . . .\n[4,] . . . | . .\n[5,] . . . . | .\n[6,] | | | | | |\n\n\n\n\nSo what is the lesson here?\nThe lesson is that the sparse Cholesky algorithm cares deeply about what order the rows and columns of the matrix are in. This is why, in the previous post, we put the dense rows and columns of \\(Q_{u \\mid y, \\theta}\\) at the end of the matrix!\nLuckily, a lot of clever graph theorists got on the job a while back and found a number of good algorithms for finding decent23 ways to reorder the vertices of a graph to minimise fill in. There are two particularly well-known reorderings: the approximate minimum degree (AMD) reordering and the nested-dissection reordering. Neither of these are easily available in Python24.\nAMD is a bog-standard black box that is a greedy reordering that tries to label the next vertex so that graph you get after removing that vertex and adding edges between all of the nodes that connect to that vertex isn’t too fucked.\nNested dissection tries to generalise the toy example above by finding nodes that separate the graph into two minimally connected components. The separator node is then labelled last. The process is repeated until you run out of nodes. This algorithm can be very efficient in some cases (eg if the graph is planar25, the sparse Cholesky algorithm using this reordering provably costs at most \\(\\mathcal{O}(n^{3/2})\\)).\nTypically, you compute multiple reorderings26 and pick the one that results in the least fill in."
  },
  {
    "objectID": "posts/2022-03-23-getting-jax-to-love-sparse-matrices/getting-jax-to-love-sparse-matrices.html#which-elements-of-the-cholesky-factor-are-non-zero-aka-symbolic-factorisation",
    "href": "posts/2022-03-23-getting-jax-to-love-sparse-matrices/getting-jax-to-love-sparse-matrices.html#which-elements-of-the-cholesky-factor-are-non-zero-aka-symbolic-factorisation",
    "title": "Sparse Matrices 2: An invitation to a sparse Cholesky factorisation",
    "section": "Which elements of the Cholesky factor are non-zero (aka symbolic factorisation)",
    "text": "Which elements of the Cholesky factor are non-zero (aka symbolic factorisation)\nOk. So I guess we’ve got to work out an algorithm for computing the non-zero structure of a sparse Cholesky factor. Naively, this seems easy: just use the Cholesky algorithm and mark which elements are non-zero.\nBut this is slow and inefficient. You’re not thinking like a programmer! Or a graph theorist. So let’s talk about how to do this efficiently.\n\nThe elimination tree\nLet’s consider the graph \\(\\mathcal{G}_L\\) that contains the sparsity pattern of \\(L\\). We know that the non-zero structure consists of all \\((i,j)\\) such that \\(i < j\\) and there is a path \\(in \\mathcal{G}\\) from \\(i\\) to \\(j\\). This means we could just compute that and make \\(\\mathcal{G}_L\\).\nThe thing that you should notice immediately is that there is a lot of redundancy in this structure. Remember that if \\(L_{ik}\\) is non-zero and \\(L_{jk}\\) is also non-zero, then \\(L_{ij}\\) is also non-zero.\nThis suggests that if we have \\((i,k)\\) and \\((j,k)\\) in the graph, we can remove the edge \\((i,j)\\) from \\(\\mathcal{G}_L\\) and still be able to work out that \\(L_{ij}\\) is non-zero. This new graph is no longer the graph associated with \\(L\\) but, for our purposes, it contains the same information.\nIf we continue pruning the graph this way, we are going to end up with a27 rooted tree! From this tree, which is called the elimination tree of \\(A\\)28 we can easily work out the non-zero structure of \\(L\\).\nThe elimination tree is the fundamental structure needed to build an efficient sparse Cholesky algorithm. We are not going to use it to its full potential, but it is very cheap to compute (roughly29 \\(\\mathcal{O}(\\operatorname{nnz}(A))\\) operations).\nOnce we have the elimination tree, it’s cheap to compute properties of \\(L\\) like the number of non-zeros in a column, the exact sparsity pattern of every column, which columns can be grouped together to form supernodes30, and the approximate minimum degree reordering.\nAll of those things would be necessary for a modern, industrial-strength sparse Cholesky factorisation. But, and I cannot stress this enough, fuck that shit.\n\n\nThe symbolic factorisation\nWe are doing the easy version. Which is to say I refuse to do anything here that couldn’t be easily done in the early 90s. Specifically, we are going to use the version of this thatGeorge, Liu, and Ng wrote about31 in the 90s. Understanding this is, I think, enough to see how things like supernodal factorisations work, but it’s so much less to keep track of.\nThe nice thing about this method is that we compute the elimination tree implicitly as we go along.\nLet \\(\\mathcal{L}_j\\) be the non-zero entries in the \\(j\\)th column of \\(L\\). Then our discussion in the previous section tells us that we need to determine the reach of the node i \\[\n\\text{Reach}(j, S_j) = \\left\\{i: \\text{there is a path from } i\\text{ to }j\\text{ through }S_j\\right\\},\n\\] where \\(S_j = \\{1,\\ldots, j-1\\}\\).\nIf we can compute the reach, then \\(\\mathcal{L}_j = \\text{Reach}(j, S_j) \\cup\\{j\\}\\)!\nThis is where the elimination tree comes in: it is an efficient representation of these sets. Indeed, \\(i \\in \\text{Reach}(j, S_j)\\) if and only if there is a directed32 path from \\(j\\) to \\(i\\) in the elimination tree! Now this tree is ordered33 so that if \\(i\\) is a child of \\(j\\) (aka directly below it in the tree), then \\(i < j\\). This means that its column in the Cholesky factorisation has already been computed. So all of the nodes that can be reached from \\(j\\) by going through \\(i\\) are in \\(\\mathcal{L}_{i} \\cap \\{j+1, \\ldots, n\\}\\).\nThis means that we can compute the non-zeros of the \\(j\\)th column of \\(L\\) efficiently from the non-zeros of all of the (very few, hopefully) columns associated with the child nodes of \\(j\\).\nSo all that’s left is to ask “how can we find the child?” (as phones around the city start buzzing). Well, a little bit of thinking time should convince you that if \\[\np = \\min\\{i : i \\in \\text{Reach}(j, S_j) \\},\n\\] then \\(p\\) is the parent of \\(i\\). Or, the parent of column \\(j\\) is the index of its first34 non-zero below the diagonal.\nWe can put all of these observations together into the following algorithm. We assume that we are given the non-zero structure of tril(A) (aka the lower-triangle of \\(A\\)).\n\nimport numpy as np\n\ndef _symbolic_factor_csc(A_indices, A_indptr):\n  # Assumes A_indices and A_indptr index the lower triangle of $A$ ONLY.\n  n = len(A_indptr) - 1\n  L_sym = [np.array([], dtype=int) for j in range(n)]\n  children = [np.array([], dtype=int) for j in range(n)]\n  \n  for j in range(n):\n    L_sym[j] = A_indices[A_indptr[j]:A_indptr[j + 1]]\n    for child in children[j]:\n      tmp = L_sym[child][L_sym[child] > j]\n      L_sym[j] = np.unique(np.append(L_sym[j], tmp))\n    if len(L_sym[j]) > 1:\n      p = L_sym[j][1]\n      children[p] = np.append(children[p], j)\n        \n  L_indptr = np.zeros(n+1, dtype=int)\n  L_indptr[1:] = np.cumsum([len(x) for x in L_sym])\n  L_indices = np.concatenate(L_sym)\n  \n  return L_indices, L_indptr\n  \n\nThis was the first piece of Python I’ve written in about 13 years35, so it’s a bit shit. Nevertheless, it works. It is possible to replace the children structure by a linked list implemented in an n-dimensional integer array36, but why bother. This function is run once.\nIt’s also worth noting that the children array expresses the elimination tree. If we were going to do something with it explicitly, we could just spit it out and reshape it into a more useful data structure.\nThere’s one more piece of tedium before we can get to the main event: we need to do a deep copy of \\(A\\) into the data structure of \\(L\\). There is no37 avoiding this.\nHere is the code.\n\ndef _deep_copy_csc(A_indices, A_indptr, A_x, L_indices, L_indptr):\n  n = len(A_indptr) - 1\n  L_x = np.zeros(len(L_indices))\n  \n  for j in range(0, n):\n    copy_idx = np.nonzero(np.in1d(L_indices[L_indptr[j]:L_indptr[j + 1]],\n                                  A_indices[A_indptr[j]:A_indptr[j+1]]))[0]\n    L_x[L_indptr[j] + copy_idx] = A_x[A_indptr[j]:A_indptr[j+1]]\n  return L_x"
  },
  {
    "objectID": "posts/2022-03-23-getting-jax-to-love-sparse-matrices/getting-jax-to-love-sparse-matrices.html#computing-the-cholesky-factorisation",
    "href": "posts/2022-03-23-getting-jax-to-love-sparse-matrices/getting-jax-to-love-sparse-matrices.html#computing-the-cholesky-factorisation",
    "title": "Sparse Matrices 2: An invitation to a sparse Cholesky factorisation",
    "section": "Computing the Cholesky factorisation",
    "text": "Computing the Cholesky factorisation\nIt feels like we’ve been going for a really long time and we still don’t have a Cholesky factorisation. Mate. I feel your pain. Believe me.\nBut we are here now: everything is in place. We can now write down the Cholesky algorithm!\nThe algorithm is as it was before, with the main difference being that we now know two things:\n\nWe only need to update tmp with descendent of j in the elimination tree.\nThat’s it. That is the only thing we know.\n\nOf course, we could use the elimination tree to do this very efficiently, but, as per my last email, I do not care. So we will simply build up a copy of all of the descendants. This will obviously be less efficient, but it’s fine for our purposes. Let’s face it, we’re all going to die eventually.\nSo here it goes.\n\ndef _sparse_cholesky_csc_impl(L_indices, L_indptr, L_x):\n    n = len(L_indptr) - 1\n    descendant = [[] for j in range(0, n)]\n    for j in range(0, n):\n        tmp = L_x[L_indptr[j]:L_indptr[j + 1]]\n        for bebe in descendant[j]:\n            k = bebe[0]\n            Ljk= L_x[bebe[1]]\n            pad = np.nonzero(                                                \\\n              L_indices[L_indptr[k]:L_indptr[k+1]] == L_indices[L_indptr[j]])[0][0]\n            update_idx = np.nonzero(np.in1d(                                 \\\n              L_indices[L_indptr[j]:L_indptr[j+1]],                          \\\n              L_indices[(L_indptr[k] + pad):L_indptr[k+1]]))[0]\n            tmp[update_idx] = tmp[update_idx] -                              \\\n              Ljk * L_x[(L_indptr[k] + pad):L_indptr[k + 1]]\n            \n        diag = np.sqrt(tmp[0])\n        L_x[L_indptr[j]] = diag\n        L_x[(L_indptr[j] + 1):L_indptr[j + 1]] = tmp[1:] / diag\n        for idx in range(L_indptr[j] + 1, L_indptr[j + 1]):\n            descendant[L_indices[idx]].append((j, idx))\n    return L_x\n\nThe one thing that you’ll note in this code38 is that we are implicitly using things that we know about the sparsity structure of the \\(j\\)th column. In particular, we know that the sparsity structure of the \\(j\\)th column is the union of the relevant parts of the sparsity structure of their dependent columns. This allows a lot of our faster indexing to work.\nFinally, we can put it all together.\n\ndef sparse_cholesky_csc(A_indices, A_indptr, A_x):\n    L_indices, L_indptr= _symbolic_factor_csc(A_indices, A_indptr)\n    L_x = _deep_copy_csc(A_indices, A_indptr, A_x, L_indices, L_indptr)\n    L_x = _sparse_cholesky_csc_impl(L_indices, L_indptr, L_x)\n    return L_indices, L_indptr, L_x\n\nRight. Let’s test it. We’re going to work on a particular39 sparse matrix.\n\nfrom scipy import sparse\n\nn = 50\none_d = sparse.diags([[-1.]*(n-1), [2.]*n, [-1.]*(n-1)], [-1,0,1])\nA = sparse.kronsum(one_d, one_d) + sparse.eye(n*n)\nA_lower = sparse.tril(A, format = \"csc\")\nA_indices = A_lower.indices\nA_indptr = A_lower.indptr\nA_x = A_lower.data\n\nL_indices, L_indptr, L_x = sparse_cholesky_csc(A_indices, A_indptr, A_x)\nL = sparse.csc_array((L_x, L_indices, L_indptr), shape = (n**2, n**2))\n\nerr = np.sum(np.abs((A - L @ L.transpose()).todense()))\nprint(f\"Error in Cholesky is {err}\")\n\nError in Cholesky is 3.871041263071504e-12\n\nnnz = len(L_x)\nprint(f\"Number of non-zeros is {nnz} (fill in of {len(L_x) - len(A_x)})\")\n\nNumber of non-zeros is 125049 (fill in of 117649)\n\n\nFinally, let’s demonstrate that we can reduce the amount of fill-in with a reordering. Obviously, the built in permutation in scipy is crappy, so we will not see much of a difference. But nevertheless. It’s there.\n\nperm = sparse.csgraph.reverse_cuthill_mckee(A, symmetric_mode=True)\nprint(perm)\n\n[2499 2498 2449 ...   50    1    0]\n\nA_perm = A[perm[:,None], perm]\nA_perm_lower = sparse.tril(A_perm, format = \"csc\")\nA_indices = A_perm_lower.indices\nA_indptr = A_perm_lower.indptr\nA_x = A_perm_lower.data\n\nL_indices, L_indptr, L_x = sparse_cholesky_csc(A_indices, A_indptr, A_x)\nL = sparse.csc_array((L_x, L_indices, L_indptr), shape = (n**2, n**2))\nerr = np.sum(np.abs((A_perm - L @ L.transpose()).todense()))\nprint(f\"Error in Cholesky is {err}\")\n\nError in Cholesky is 3.0580421951974465e-12\n\nnnz_rcm = len(L_x)\nprint(f\"Number of non-zeros is {nnz_rcm} (fill in of {len(L_x) - len(A_x)}),\\nwhich is less than the unpermuted matrix, which had {nnz} non-zeros.\")\n\nNumber of non-zeros is 87025 (fill in of 79625),\nwhich is less than the unpermuted matrix, which had 125049 non-zeros.\n\n\nAnd finally, let’s check that we’ve not made some fake non-zeros. To do this we need to wander back into R because scipy doesn’t have a sparse Cholesky40 factorisation.\n\nind <- py$A_indices\nindptr <- py$A_indptr\nx <- as.numeric(py$A_x)\nA = sparseMatrix(i = ind + 1, p = indptr, x=x, symmetric = TRUE)\n\nL = t(chol(A))\nsum(L@i - py$L_indices)\n\n[1] 0\n\nsum(L@p - py$L_indptr)\n\n[1] 0\n\n\nPerfect."
  },
  {
    "objectID": "posts/2022-03-23-getting-jax-to-love-sparse-matrices/getting-jax-to-love-sparse-matrices.html#ok-we-are-done-for-today.",
    "href": "posts/2022-03-23-getting-jax-to-love-sparse-matrices/getting-jax-to-love-sparse-matrices.html#ok-we-are-done-for-today.",
    "title": "Sparse Matrices 2: An invitation to a sparse Cholesky factorisation",
    "section": "Ok we are done for today.",
    "text": "Ok we are done for today.\nI was hoping that we were going to make it to the JAX implementation, but this is long enough now. And I suspect that there will be some issues that are going to come up.\nIf you want some references, I recommend:\n\nGeorge, Liu, and Ng’s notes (warning: FORTRAN).\nTimothy Davis’ book (warning: pure C).\nLiu’s survey paper about elimination trees (warning: trees).\nRue and Held’s book (Statistically motivated).\n\nObviously this is a massive area and I obviously did not do it justice in a single blog post. It’s well worth looking further into. It is very cool. And obviously, I go through all this41 to get a prototype that I can play with all of the bits of. For the love of god, use Cholmod or Eigen or MUMPS or literally anything else. The only reason to write these yourself is to learn how to understand it."
  },
  {
    "objectID": "posts/2022-03-22-a-linear-mixed-effects-model/a-linear-mixed-effects-model.html",
    "href": "posts/2022-03-22-a-linear-mixed-effects-model/a-linear-mixed-effects-model.html",
    "title": "Sparse Matrices 1: The linear algebra of linear mixed effects models and their generalisations",
    "section": "",
    "text": "Back in the early days of the pandemic I though “I’ll have a pandemic project”. I never did my pandemic project.\nBut I did think briefly about what it would be. I want to get the types of models I like to use in everyday life efficiently implemented inside Stan. These models encapsulate (generalised) linear mixed models1, (generalised) additive models, Markovian spatial models2, and other models. A good description of the types of models I’m talking about can be found here.\nMany of these models can be solved efficiently via INLA3, a great R package for fast posterior inference for an extremely useful set of Bayesian models. In focussing on a particular class of Bayesian models, INLA leverages a bunch of structural features to make a very very fast and accurate posterior approximation. I love this stuff. It’s where I started my stats career.\nNone of the popular MCMC packages really implement the lessons learnt from INLA to help speed up their inference. I want to change that.\nThe closest we’ve gotten so far is the nice work Charles Margossian has been doing to get Laplace approximations into Stan.\nBut I want to focus on the other key tool in INLA: using sparse linear algebra to make things fast and scalable.\nI usually work with Stan, but the scale of the C++ coding4 required to even tell if these ideas are useful in Stan was honestly just too intimidating.\nBut the other day I remembered Python. Now I am a shit Python programmer5 and I’m not fully convinced I ever achieved object permanence. So it took me a while to remember it existed. But eventually I realised that I could probably make a decent prototype6 of this idea using some modern Python tools (specifically JAX). I checked with some PyMC devs and they pointed me at what the appropriate bindings would look like.\nSo I decided to go for it.\nOf course, I’m pretty busy and these sort of projects have a way of dying in the arse. So I’m motivating myself by blogging it. I do not know if these ideas will work7. I do not know if my coding skills are up to it8. I do not know if I will lose interest. But it should be fun to find out.\nSo today I’m going to do the easiest part: I’m going to scope out the project. Read on, MacDuff."
  },
  {
    "objectID": "posts/2022-03-22-a-linear-mixed-effects-model/a-linear-mixed-effects-model.html#a-generalised-linear-mixed-effects-ish-model",
    "href": "posts/2022-03-22-a-linear-mixed-effects-model/a-linear-mixed-effects-model.html#a-generalised-linear-mixed-effects-ish-model",
    "title": "Sparse Matrices 1: The linear algebra of linear mixed effects models and their generalisations",
    "section": "A generalised linear mixed effects-ish model",
    "text": "A generalised linear mixed effects-ish model\nIf you were to open the correct textbook, or the Bates, Mächler, Boler, and Walker 2015 masterpiece paper that describes the workings of lme4, you will see the linear mixed model written as \\[\ny = X\\beta + Zb + \\epsilon,\n\\] where\n\nthe columns of \\(X\\) contain the covariates9,\n\\(\\beta\\) is a vector of unknown regression coefficients,\n\\(Z\\) is a known matrix that describes the random effects (basically which observation is linked to which random effect),\n\\(b \\sim N(0, \\Sigma_b)\\) is the vector of random effects with some unknown covariance matrix \\(\\Sigma_b\\),\nand \\(\\epsilon \\sim N(0 ,\\sigma^2 W)\\) is the observation noise (here \\(W\\) is a known diagonal matrix10).\n\nBut unlike Doug Bates and his friends, my aim is to do Bayesian computation. In this situation, \\(\\beta\\) also has a prior on it! In fact, I’m going to put a Gaussian prior \\(\\beta \\sim N(0, R)\\) on it, for some typically known11 matrix \\(R\\).\nThis means that I can treat \\(\\beta\\) and \\(b\\) the same12 way! And I’m going to do just that. I’m going to put them together into a vector \\(u = (\\beta^T, b^T)^T\\). Because the prior on \\(u\\) is Gaussian13, I’m sometimes going to call \\(u\\) the Gaussian component or even the latent14 Gaussian component.\nNow that I’ve smooshed my fixed and random effects together, I don’t really need to keep \\(X\\) and \\(Z\\) separate. So I’m going push them together into a rectangular matrix \\[\nA = [X \\vdots Z].\n\\]\nThis allows us to re-write the model as \\[\\begin{align*}\ny \\mid u, \\sigma & \\sim N(A u, \\sigma^2 W)\\\\\nu \\mid \\theta &\\sim N(0, Q(\\theta)^{-1}).\n\\end{align*}\\]\nWhat the hell is \\(Q(\\theta)\\) and why are we suddenly parameterising a multivariate normal distribution by the inverse of its covariance matrix (which, if you’re curious, is known as a precision matrix)???\nI will take your questions in reverse order.\nWe are parameterising by the precision15 matrix because it will simplify our formulas and lead to faster computations. This will be a major topic for us later!\nAs to what \\(Q(\\theta)\\) is, it is the matrix \\[\nQ(\\theta) = \\begin{pmatrix} \\Sigma_b^{-1} & 0 \\\\ 0 & R^{-1}\\end{pmatrix}\n\\] and \\(\\theta = (\\sigma, \\Sigma_b)\\) is the collection of all16 non-Gaussian parameters in the model. Later, we will assume17 that \\(\\Sigma_b\\) has quite a lot of structure.\nThis is a very generic model. It happily contains things like\n\nLinear regression!\nLinear regression with horseshoe priors!\nLinear mixed effects models!\nLinear regression with splines (smoothing or basis)!\nSpatial models like ICARs, BYMs, etc etc etc\nGaussian processes (with the caveat that we’re mostly focussing on those that can be formulated via precision matrices rather than covariance matrices. A whole blog post, I have.)\nAny combination of these things!\n\nSo if I manage to get this implemented efficiently, all of these models will become efficient too. All it will cost is a truly shithouse18 interface.\nThe only downside of this degree of flexibility compared to just implementing a straight linear mixed model with \\(X\\) and \\(Z\\) and \\(\\beta\\) and \\(b\\) all living separately is that there are a couple of tricks19 to improve numerical stability that we can’t use."
  },
  {
    "objectID": "posts/2022-03-22-a-linear-mixed-effects-model/a-linear-mixed-effects-model.html#lets-get-the-posterior",
    "href": "posts/2022-03-22-a-linear-mixed-effects-model/a-linear-mixed-effects-model.html#lets-get-the-posterior",
    "title": "Sparse Matrices 1: The linear algebra of linear mixed effects models and their generalisations",
    "section": "Let’s get the posterior!",
    "text": "Let’s get the posterior!\nThe nice thing about thing about this model is that it is a normal likelihood with a normal prior, so we can directly compute two key quantities:\n\nThe “full conditional” distribution \\(p(u \\mid y, \\theta)\\), which is useful for getting posterior information about \\(b\\) and \\(\\beta\\), and\nThe marginal posterior \\(p(\\theta \\mid y)\\).\n\nThis means that we do not need to do MCMC on the joint space \\((u, \\theta)\\)! We can instead write a model to draw samples from \\(p(\\theta \\mid y)\\), which is much lower-dimensional and easier20 to sample from, and then compute the joint posterior by sampling from the full conditional.\nI talked a little about the mechanics of this in a previous blog post about conjugate priors, but let’s do the derivations. Why? Because they’re not too hard and it’s useful to have them written out somewhere.\n\nThe full conditional\nFirst we need to compute \\(p(u \\mid y , \\theta)\\). The first thing that we note is that conditional distributions are always proportional to the joint distribution (we’re literally just pretending some things are constant), so we get \\[\\begin{align*}\np(u \\mid y , \\theta) &\\propto p(y \\mid u, \\theta) p(u \\mid \\theta) p(\\theta) \\\\\n&\\propto \\exp\\left[-\\frac{1}{2\\sigma^2} (y - Au)^TW^{-1}(y-Au)\\right]\\exp\\left[-\\frac{1}{2}u^TQ(\\theta)u\\right].\n\\end{align*}\\]\nNow we just need to expand things out and work out what the mean and the precision matrix of \\(p(u \\mid y, \\theta )\\) (which is Gaussian by conjugacy!) are.\nComputing posterior distributions by hand is a dying21 art. So my best and only advice to you: don’t be a hero. Just pattern match like the rest of us. To do this, we need to know what the density of a multivarite normal distribution looks like deep down in its soul.\nBehold: the ugly div box!22\n\nIf \\(u \\sim N(m, P^{-1})\\), then \\[\\begin{align*}\np(u) &\\propto \\exp\\left[- \\frac{1}{2}(u - m)^TP(u-m)\\right] \\\\\n&\\propto \\exp\\left[- \\frac{1}{2}u^TPu + m^TPu\\right],\n\\end{align*}\\] where I just dropped all of the terms that didn’t involve \\(u\\).\n\nThis means the plan is to\n\nExpand out the quadratics in the exponential term so we get something that looks like \\(\\exp\\left[-\\frac{1}{2}u^TPu + z^Tu\\right]\\)\nThe matrix \\(P\\) will be the precision matrix of \\(u \\mid y, \\theta\\).\nThe mean of \\(\\mu \\mid y, \\theta\\) is \\(P^{-1}z\\).\n\nSo let’s do it!\n\\[\\begin{align*}\np(u \\mid y , \\theta) &\\propto \\exp\\left[-\\frac{1}{2\\sigma^2} u^TA^TW^{-1}Au + \\frac{1}{\\sigma^2}(A^TW^{-1}y)^Tu\\right]\\exp\\left[-\\frac{1}{2}u^TQ(\\theta)u\\right] \\\\\n&\\propto \\exp\\left[-\\frac{1}{2}u^T\\left(Q + \\frac{1}{\\sigma^2}A^TW^{-1}A\\right)u +  \\frac{1}{\\sigma^2}(A^TW^{-1}y)^Tu\\right].\n\\end{align*}\\]\nThis means that \\(p(u \\mid y ,\\theta)\\) is multivariate normal with\n\nprecision matrix \\(Q_{u\\mid y,\\theta}(\\theta) = \\left(Q(\\theta) + \\frac{1}{\\sigma^2}A^TW^{-1}A\\right)\\) and\nmean23 \\(\\mu_{u\\mid y,\\theta}(\\theta) = \\frac{1}{\\sigma^2} Q_{u\\mid y,\\theta}(\\theta)^{-1} A^TW^{-1}y\\).\n\nThis means if I build an MCMC scheme to give me \\(B\\) samples \\(\\theta_b \\sim p(\\theta \\mid y)\\), \\(b = 1, \\ldots, B\\), then I can turn them into \\(B\\) samples \\((\\theta_b, u_b)\\) from \\(p(\\theta, u \\mid y)\\) by doing the following.\n\nFor \\(b = 1, \\ldots, B\\)\n\nSimulate \\(u_b \\sim N\\left(\\mu_{u\\mid y,\\theta}(\\theta_b), Q_{u\\mid y,\\theta}(\\theta_b)^{-1}\\right)\\)\nStore the pair \\((\\theta_b, u_b)\\)\n\n\nEasy24 as!\n\n\nWriting down \\(p(\\theta \\mid y)\\)\nSo now we just25 have to get the marginal posterior for the non-Gaussian parameters \\(\\theta\\). We only need it up to a constant of proportionality, so we can express the joint probability \\(p(y, u, \\theta)\\) in two equivalent ways to get \\[\\begin{align*}\np(y, u , \\theta) &= p(y, u, \\theta) \\\\\np(u \\mid \\theta, y) p(\\theta \\mid y) p(y) &= p(y \\mid u, \\theta) p(u \\mid \\theta)p(\\theta). \\\\\n\\end{align*}\\]\nRearranging, we get \\[\\begin{align*}\np(\\theta \\mid y) &= \\frac{p(y \\mid u, \\theta) p(u \\mid \\theta)p(\\theta)}{p(u \\mid \\theta, y)p(y)} \\\\\n&\\propto \\frac{p(y \\mid u, \\theta) p(u \\mid \\theta)p(\\theta)}{p(u \\mid \\theta, y)}.\n\\end{align*}\\]\nThis is a very nice relationship between the functional forms of the various densities we happen to know and the density we are trying to compute. This means that if you have access to the full conditional distribution26 for \\(u\\) you can marginalise \\(u\\) out. No weird integrals required.\nBut there’s one oddity: there is a \\(u\\) on the right hand side, but no \\(u\\) on the left hand side. What we have actually found is a whole continuum of functions that are proportional to \\(p(\\theta \\mid y)\\). It truly does not matter which one we choose.\nBut some choices make the algebra slightly nicer. (And remember, I’m gonna have to implement this later, so I should probably keep and eye on that.)\nA good27 generic choice is \\(u = \\mu_{u\\mid y, \\theta}(\\theta)\\).\nThe algebra here can be a bit tricky28, so let’s write out each function evaluated at \\(u = \\mu_{u\\mid y, \\theta}(\\theta)\\).\nThe bit from the likelihood is \\[\\begin{align*}\np(y \\mid u = \\mu_{u\\mid y, \\theta}(\\theta), \\theta) &\\propto \\sigma^{-n} \\exp\\left[-\\frac{1}{2\\sigma^2}(y - A\\mu_{u\\mid y, \\theta}(\\theta))^TW^{-1}(y-  A\\mu_{u\\mid y, \\theta}(\\theta))\\right]\\\\\n&\\propto \\sigma^{-n}\\exp\\left[\\frac{-1}{2\\sigma^2} \\mu_{u\\mid y, \\theta}(\\theta)^TA^TW^{-1}A\\mu_{u\\mid y, \\theta}(\\theta) + \\frac{1}{\\sigma^2} y^T W^{-1}A \\mu_{u\\mid y, \\theta}(\\theta)\\right],\n\\end{align*}\\] where \\(n\\) is the length of \\(y\\).\nThe bit from the prior on \\(u\\) is \\[\\begin{align*}\np(\\mu_{u\\mid y, \\theta}(\\theta) \\mid \\theta )\n\\propto |Q(\\theta)|^{1/2}\\exp\\left[-\\frac{1}{2} \\mu_{u\\mid y, \\theta}(\\theta)^TQ(\\theta)\\mu_{u\\mid y, \\theta}(\\theta)\\right].\n\\end{align*}\\]\nFinally, we get that the denominator is \\[\np(\\mu_{u\\mid y, \\theta}(\\theta) \\mid y, \\theta) \\propto |Q_{u\\mid y, \\theta}(\\theta)|^{1/2}\n\\] as the exponential term29 cancels!\nOk. Let’s finish this. (Incidentally, if you’re wondering why Bayesians love MCMC, this is why.)\n\\[\\begin{align*}\np(\\theta \\mid y) &\\propto p(\\theta) \\frac{|Q(\\theta)|}{|Q_{u\\mid y, \\theta}(\\theta)|} \\exp\\left[-\\frac{1}{2} \\mu_{u\\mid y, \\theta}(\\theta)^T(Q(\\theta) + \\frac{1}{\\sigma^2}A^TW^{-1}A)\\mu_{u\\mid y, \\theta}(\\theta) + \\frac{1}{\\sigma^2} y^T W^{-1}A \\mu_{u\\mid y, \\theta}(\\theta)\\right] \\\\\n&=  p(\\theta) \\frac{|Q(\\theta)|}{|Q_{u\\mid y, \\theta}(\\theta)|} \\exp\\left[-\\frac{1}{2} \\mu_{u\\mid y, \\theta}(\\theta)^TQ_{u\\mid y, \\theta}(\\theta)\\mu_{u\\mid y, \\theta}(\\theta) + \\frac{1}{\\sigma^2} y^T W^{-1}A \\mu_{u\\mid y, \\theta}(\\theta)\\right].\n\\end{align*}\\]\nWe can now use the fact that \\(Q_{u\\mid y, \\theta}(\\theta)\\mu_{u\\mid y, \\theta}(\\theta) = A^TW^{-1}y\\) to get\n\\[\\begin{align*}\np(\\theta \\mid y) &\\propto p(\\theta) \\frac{|Q(\\theta)|}{|Q_{u\\mid y, \\theta}(\\theta)|} \\exp\\left[-\\frac{1}{2} \\mu_{u\\mid y, \\theta}(\\theta)^TA^TW^{-1}y + \\frac{1}{\\sigma^2} y^T W^{-1}A \\mu_{u\\mid y, \\theta}(\\theta)\\right] \\\\\n&=\\frac{|Q(\\theta)|}{|Q_{u\\mid y, \\theta}(\\theta)|} \\exp\\left[\\frac{1}{2} \\mu_{u\\mid y, \\theta}(\\theta)^TA^TW^{-1}y \\right] .\n\\end{align*}\\]\nFor those who just love a log-density, this is \\[\n\\log(p(\\theta \\mid y)) = \\frac{1}{2} \\mu_{u\\mid y, \\theta}(\\theta)^TA^TW^{-1}y +\\frac{1}{2} \\log(|Q(\\theta)|) - \\frac{1}{2}\\log(|Q_{u\\mid y, \\theta}(\\theta)|).\n\\] A fairly simple expression30 for all of that work."
  },
  {
    "objectID": "posts/2022-03-22-a-linear-mixed-effects-model/a-linear-mixed-effects-model.html#so-why-isnt-this-just-a-gaussian-process",
    "href": "posts/2022-03-22-a-linear-mixed-effects-model/a-linear-mixed-effects-model.html#so-why-isnt-this-just-a-gaussian-process",
    "title": "Sparse Matrices 1: The linear algebra of linear mixed effects models and their generalisations",
    "section": "So why isn’t this just a Gaussian process?",
    "text": "So why isn’t this just a Gaussian process?\nThese days, people31 are more than passingly familiar32 with Gaussian processes. And so they’re quite possibly wondering why this isn’t all just an extremely inconvenient way to do the exact same computations you do with a GP.\nLet me tell you. It is all about \\(Q(\\theta)\\) and \\(A\\).\nThe prior precision matrix \\(Q(\\theta)\\) is typically block diagonal. This special structure makes it pretty easy to compute the \\(|Q(\\theta)|\\) term33. But, of course, there’s more going on here.\nIn linear mixed effects models, these blocks on the diagonal matrix are typically fairly small (their size is controlled by the number of levels in the variable you’re stratifying by). Moreover, the matrices on the diagonal of \\(Q(\\theta)\\) are the inverses of either diagonal or block diagonal matrices that themselves have quite small blocks34.\nIn models that have more structured random effects35, the diagonal blocks of \\(Q(\\theta)\\) can get quite large36. Moreover, the matrices on these blocks are usually not block diagonal.\nThankfully, these prior precision matrices do have something going for them: most of their entries are zero. We refer to these types of matrices as sparse matrices. There are some marvelous algorithms for factorising sparse matrices that are usually a lot more efficient37 than algorithms for dense matrices.\nMoreover, the formulation here decouples the dimension of the latent Gaussian component from the number of observations. The data only enters the posterior through the reduction \\(A^Ty\\), so if the number of observations is much larger than the number of latent variables38 and \\(A\\) is sparse39, the operation scales linearly in the number of observations (and obviously superlinearly40 in the row-dimension of \\(A\\)).\nSo the prior precision41 is a sparse matrix. What about the precision matrix of \\([u \\mid y, \\theta]\\)?\nIt is also sparse! Recall that \\(A = [Z \\vdots X]\\). This means that \\[\n\\frac{1}{\\sigma^2}A^TW^{-1}A = \\frac{1}{\\sigma^2}\\begin{pmatrix} Z^T W^{-1}Z & Z^T W^{-1}X \\\\ X^T W^{-1} Z & X^TW^{-1}X \\end{pmatrix}.\n\\] \\(Z\\) is a matrix that links the stacked vector of random effects \\(b\\) to each observation. Typically, the likelihood \\(p(y_i \\mid \\theta)\\) will only depend on a small number of entries of \\(b\\), which suggests that most elements in each row of \\(Z\\) will be zero. This, in turn, implies that \\(Z\\) is sparse and so is42 \\(Z^TW^{-1}Z\\).\nOn the other hand, the other three blocks are usually43 fully dense. Thankfully, though, the usual situation is that \\(b\\) has far more elements that \\(\\beta\\), which means that \\(A^TW^{-1}A\\) is still sparse and we can still use our special algorithms44\nAll of this suggests that, under usual operating conditions, \\(Q_{u\\mid y, \\theta}\\) is also a sparse matrix.\nAnd that’s great because that means that we can compute the log-posterior using only 3 main operations:\n\nComputing \\(\\log(|Q(\\theta)|)\\). This matrix is block diagonal so you can just multiply together the determinants45 of the diagonal blocks, which are relatively cheap to compute.\nComputing \\(\\mu_{u \\mid y, \\theta}(\\theta)\\). This requires solving the sparse linear system \\(Q_{u \\mid y, \\theta} \\mu_{u \\mid y, \\theta} = \\frac{1}{\\sigma^2}A^TW^{-1}y\\). This is going to rely on some fancy pants sparse matrix algorithm.\nComputing \\(\\log(|Q_{u \\mid y, \\theta}(\\theta)|)\\). This is, thankfully, a by-product of the things we need to compute to solve the linear system in the previous task."
  },
  {
    "objectID": "posts/2022-03-22-a-linear-mixed-effects-model/a-linear-mixed-effects-model.html#what-i-what-i-what-i-gotta-do-what-i-gotta-do-to-get-this-model-in-pymc",
    "href": "posts/2022-03-22-a-linear-mixed-effects-model/a-linear-mixed-effects-model.html#what-i-what-i-what-i-gotta-do-what-i-gotta-do-to-get-this-model-in-pymc",
    "title": "Sparse Matrices 1: The linear algebra of linear mixed effects models and their generalisations",
    "section": "What I? What I? What I gotta do? What I gotta do to get this model in PyMC?",
    "text": "What I? What I? What I gotta do? What I gotta do to get this model in PyMC?\nSo this is where shit gets real.\nEssentially, I want to implement a new distribution in PyMC that will take approprite inputs and output the log-density and its gradient. There are two ways to do this:\n\nPanic\nPray\n\nFor the first option, you write a C++46 backend and register it as an Aesara node. This is how, for example, differential equation solvers migrated into PyMC.\nFor the second option, which is going to be our goal, we light our Sinead O’Connor votive candle and program up the model using JAX. JAX is a glorious feat of engineering that makes compilable and autodiff-able Python code. In a lot of cases, it seamlessly lets you shift from CPUs to GPUs and is all around quite cool.\nIt also has approximately zero useful sparse matrix support. (It will let you do very basic things47 but nothing as complicated as we are going to need.)\nSo why am I taking this route? Well firstly I’m curious to see how well it works. So I am going to write JAX code to do all of my sparse matrix operations and see how efficiently it autodiffs it.\nNow I’m going to pre-register my expectations. I expect it to be a little bit shit. Or, at least, I expect to be able to make it do better.\nThe problem is that computing a gradient requires a single reverse-mode48 autodiff sweep. This does not seem like a problem until you look at how this sort of thing needs to be implemented and you realise that every gradient call is going to need to generate and store the entire damn autodiff tree for the log-density evaluation. And that autodiff tree is going to be large. So I am expecting the memory scaling on this to be truly shite.\nThankfully there are two ways to fix this. One of them is to implement a custom Jacobian-vector product49 and register it with JAX so it knows most of how to do the derivative. The other way is to implement this shit in C++ and register it as a JAX primitive. And to be honest I’m very tempted. But that is not where I am starting.\nThe other problem is going to be exposing this to users. The internal interface is going to be an absolute shit to use. So we are gonna have to get our Def Leppard on and sprinkle some syntactical sugar all over it.\nI’m honestly less concerned about this challenge. It’s important but I am not expecting to produce anything good enough to put into PyMC (or any other package). But I do think it’s a good idea to keep this sort of question in mind: it can help you make cleaner, more useful code.\n\nWhat comes next?\nWell you will not get a solution today. This blog post is more than long enough.\nMy plan is to do three things.\n\nImplement the relevant sparse matrix solver in a JAX-able form. (This is mostly gonna be me trying to remember how to do something I haven’t done in a very long time.)\nBind50 the (probably) inefficient version into PyMC to see how that process works.\nTry the custom jvp and vjp interfaces in JAX to see if they speed things up relative to just autodiffing through my for loops.\n(Maybe) Look into whether hand-rolling some C++ is worth the effort.\n\nWill I get all of this done? I mean, I’m skeptical. But hey. If I do it’ll be nice."
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Un garçon pas comme les autres (Bayes)",
    "section": "",
    "text": "Multilevel models\n\n\nVisual diagnostics\n\n\nPrior distributions\n\n\nfundamentals\n\n\n\n\nA small introduction to multilevel models. Why? Because I said so, that’s why. And you will simply not believe what happens to residual plots.\n\n\n\n\n\n\nSep 6, 2022\n\n\nDan Simpson\n\n\n\n\n\n\n  \n\n\n\n\n\n\n\n\n\n\nPrior distributions\n\n\nfundamentals\n\n\nPC priors\n\n\n\n\nLet us not lie. Specifying priors are hard. This post steps through a technique for setting priors that I think gives a good basis for realistically complex problems.\n\n\n\n\n\n\nSep 3, 2022\n\n\nDan Simpson\n\n\n\n\n\n\n  \n\n\n\n\n\n\n\n\n\n\nImportance sampling\n\n\nComputation\n\n\nTruncated importance sampling\n\n\nWindsorized importance sampling\n\n\nPareto smoothed importance sampling\n\n\nPSIS\n\n\n\n\nLook. I had to do it so I wrote it out in detail. This is some of the convergence theory for truncated and winzorised importance sampling estimators\n\n\n\n\n\n\nJun 15, 2022\n\n\nDan Simpson\n\n\n\n\n\n\n  \n\n\n\n\n\n\n\n\n\n\nJAX\n\n\nSparse matrices\n\n\nAutodiff\n\n\n\n\nOpen up the kennels, Kenneth. Mamma’s coming home tonight.\n\n\n\n\n\n\nMay 30, 2022\n\n\nDan Simpson\n\n\n\n\n\n\n  \n\n\n\n\n\n\n\n\n\n\nSparse matrices\n\n\nSparse Cholesky factorisation\n\n\nPython\n\n\nJAX\n\n\n\n\nA new JAX primitive? In this economy?\n\n\n\n\n\n\nMay 20, 2022\n\n\nDan Simpson\n\n\n\n\n\n\n  \n\n\n\n\n\n\n\n\n\n\nSparse matrices\n\n\nSparse Cholesky factorisation\n\n\nPython\n\n\nJAX\n\n\n\n\nJust some harmeless notes. Like the ones Judy Dench took in that movie.\n\n\n\n\n\n\nMay 16, 2022\n\n\nDan Simpson\n\n\n\n\n\n\n  \n\n\n\n\n\n\n\n\n\n\nSparse matrices\n\n\nSparse Cholesky factorisation\n\n\nPython\n\n\nJAX\n\n\n\n\nTakes a long drag on cigarette. JAX? Where was he when I had my cancer?\n\n\n\n\n\n\nMay 14, 2022\n\n\nDan Simpson\n\n\n\n\n\n\n  \n\n\n\n\n\n\n\n\n\n\nSparse matrices\n\n\nSparse Cholesky factorisation\n\n\nPython\n\n\n\n\nCome for the details, stay for the shitty Python, leave with disappointment. Not unlike the experience of dating me.\n\n\n\n\n\n\nMar 31, 2022\n\n\nDan Simpson\n\n\n\n\n\n\n  \n\n\n\n\n\n\n\n\n\n\nSparse matrices\n\n\nLinear mixed models\n\n\n\n\nHubris. Just hubris. But before the fall comes the statement of purpose. This is that statement.\n\n\n\n\n\n\nMar 22, 2022\n\n\nDan Simpson\n\n\n\n\n\n\n  \n\n\n\n\n\n\n\n\n\n\nComputation\n\n\nAssessing algorithms\n\n\n\n\nA repost from Andrew’s blog about comparing computational methods for performing a task. (Lightly edited.) Original posted 20 October, 2017.\n\n\n\n\n\n\nJan 26, 2022\n\n\nDan Simpson\n\n\n\n\n\n\n  \n\n\n\n\n\n\n\n\n\n\nPrior distributions\n\n\nFundamentals\n\n\nDesign dependence\n\n\n\n\nA repost from Andrew’s blog about how design information infects multivariate priors. (Lightly edited. Well, a bit more than lightly because the last version didn’t fully make sense. But whatever. Blogs, eh.) Original posted 5 November, 2017.\n\n\n\n\n\n\nDec 9, 2021\n\n\nDan Simpson, Dan Simpson\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nBayesian Lasso\nVariable Selection\nFundamentals\nTheory\nThings that don't work\n\n\n\nA repost (with edits, revisions, and footnotes) from Andrew's blog about how much I hate the Bayesian Lasso. Originally published 2nd November, 2017.\n\n\n\nDec 8, 2021\nDan Simpson, Dan Simpson\n\n\n\n\n  \n\n\n\n\n\n\n\n\n\n\nGaussian processes\n\n\nFundamentals\n\n\nTheory\n\n\n\n\nFuck man, I don’t know about this one. A lot of stuff happens. At some point there’s a lot of PDEs. There are proofs. Back away.\n\n\n\n\n\n\nNov 24, 2021\n\n\nDan Simpson\n\n\n\n\n\n\n  \n\n\n\n\n\n\n\n\n\n\nGaussian processes\n\n\nFundamentals\n\n\nTheory\n\n\nDeep dive\n\n\n\n\nGaussian processes. As narrated by an increasingly deranged man during a day of torrential rain.\n\n\n\n\n\n\nNov 3, 2021\n\n\nDan Simpson\n\n\n\n\n\n\n  \n\n\n\n\n\n\n\n\n\n\nPrior distributions\n\n\nFundamentals\n\n\n\n\nObjective priors? In finite dimensions? A confidence trick? Yes.\n\n\n\n\n\n\nOct 17, 2021\n\n\nDan Simpson\n\n\n\n\n\n\n  \n\n\n\n\n\n\n\n\n\n\nPrior distributions\n\n\nFundamentals\n\n\n\n\nConjugate Priors? The crystal deoderant of Bayesian statistics\n\n\n\n\n\n\nOct 16, 2021\n\n\nDan Simpson\n\n\n\n\n\n\n  \n\n\n\n\n\n\n\n\n\n\nPrior distributions\n\n\nFundamentals\n\n\n\n\nPriors? Defined. Questions? Outlined. Purpose? Declared.\n\n\n\n\n\n\nOct 15, 2021\n\n\nDan Simpson\n\n\n\n\n\n\n  \n\n\n\n\n\n\n\n\n\n\nTeaching\n\n\nFundamentals\n\n\nOpinionated\n\n\n\n\nWindmills? Tilted. Topic? Boring. (n-1)? No.\n\n\n\n\n\n\nOct 14, 2021\n\n\nDan Simpson\n\n\n\n\n\n\nNo matching items"
  },
  {
    "objectID": "about.html",
    "href": "about.html",
    "title": "About this blog",
    "section": "",
    "text": "A footnote that got out of control."
  }
]